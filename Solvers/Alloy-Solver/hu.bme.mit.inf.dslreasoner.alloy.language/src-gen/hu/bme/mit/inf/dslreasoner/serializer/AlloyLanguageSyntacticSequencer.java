/*
 * generated by Xtext
 */
package hu.bme.mit.inf.dslreasoner.serializer;

import com.google.inject.Inject;
import hu.bme.mit.inf.dslreasoner.services.AlloyLanguageGrammarAccess;
import java.util.List;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.IGrammarAccess;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.nodemodel.INode;
import org.eclipse.xtext.serializer.analysis.GrammarAlias.AbstractElementAlias;
import org.eclipse.xtext.serializer.analysis.GrammarAlias.AlternativeAlias;
import org.eclipse.xtext.serializer.analysis.GrammarAlias.TokenAlias;
import org.eclipse.xtext.serializer.analysis.ISyntacticSequencerPDAProvider.ISynNavigable;
import org.eclipse.xtext.serializer.analysis.ISyntacticSequencerPDAProvider.ISynTransition;
import org.eclipse.xtext.serializer.sequencer.AbstractSyntacticSequencer;

@SuppressWarnings("all")
public class AlloyLanguageSyntacticSequencer extends AbstractSyntacticSequencer {

	protected AlloyLanguageGrammarAccess grammarAccess;
	protected AbstractElementAlias match_ALSAnd_AmpersandAmpersandKeyword_1_1_0_or_AndKeyword_1_1_1;
	protected AbstractElementAlias match_ALSBasicRelationTerm_LeftParenthesisKeyword_6_0_a;
	protected AbstractElementAlias match_ALSBasicRelationTerm_LeftParenthesisKeyword_6_0_p;
	protected AbstractElementAlias match_ALSIff_IffKeyword_1_1_1_or_LessThanSignEqualsSignGreaterThanSignKeyword_1_1_0;
	protected AbstractElementAlias match_ALSImpl_EqualsSignGreaterThanSignKeyword_1_1_0_or_ImpliesKeyword_1_1_1;
	protected AbstractElementAlias match_ALSOr_OrKeyword_1_1_1_or_VerticalLineVerticalLineKeyword_1_1_0;
	protected AbstractElementAlias match_ALSPreficed_ExclamationMarkKeyword_0_1_0_0_or_NotKeyword_0_1_0_1;
	
	@Inject
	protected void init(IGrammarAccess access) {
		grammarAccess = (AlloyLanguageGrammarAccess) access;
		match_ALSAnd_AmpersandAmpersandKeyword_1_1_0_or_AndKeyword_1_1_1 = new AlternativeAlias(false, false, new TokenAlias(false, false, grammarAccess.getALSAndAccess().getAmpersandAmpersandKeyword_1_1_0()), new TokenAlias(false, false, grammarAccess.getALSAndAccess().getAndKeyword_1_1_1()));
		match_ALSBasicRelationTerm_LeftParenthesisKeyword_6_0_a = new TokenAlias(true, true, grammarAccess.getALSBasicRelationTermAccess().getLeftParenthesisKeyword_6_0());
		match_ALSBasicRelationTerm_LeftParenthesisKeyword_6_0_p = new TokenAlias(true, false, grammarAccess.getALSBasicRelationTermAccess().getLeftParenthesisKeyword_6_0());
		match_ALSIff_IffKeyword_1_1_1_or_LessThanSignEqualsSignGreaterThanSignKeyword_1_1_0 = new AlternativeAlias(false, false, new TokenAlias(false, false, grammarAccess.getALSIffAccess().getIffKeyword_1_1_1()), new TokenAlias(false, false, grammarAccess.getALSIffAccess().getLessThanSignEqualsSignGreaterThanSignKeyword_1_1_0()));
		match_ALSImpl_EqualsSignGreaterThanSignKeyword_1_1_0_or_ImpliesKeyword_1_1_1 = new AlternativeAlias(false, false, new TokenAlias(false, false, grammarAccess.getALSImplAccess().getEqualsSignGreaterThanSignKeyword_1_1_0()), new TokenAlias(false, false, grammarAccess.getALSImplAccess().getImpliesKeyword_1_1_1()));
		match_ALSOr_OrKeyword_1_1_1_or_VerticalLineVerticalLineKeyword_1_1_0 = new AlternativeAlias(false, false, new TokenAlias(false, false, grammarAccess.getALSOrAccess().getOrKeyword_1_1_1()), new TokenAlias(false, false, grammarAccess.getALSOrAccess().getVerticalLineVerticalLineKeyword_1_1_0()));
		match_ALSPreficed_ExclamationMarkKeyword_0_1_0_0_or_NotKeyword_0_1_0_1 = new AlternativeAlias(false, false, new TokenAlias(false, false, grammarAccess.getALSPreficedAccess().getExclamationMarkKeyword_0_1_0_0()), new TokenAlias(false, false, grammarAccess.getALSPreficedAccess().getNotKeyword_0_1_0_1()));
	}
	
	@Override
	protected String getUnassignedRuleCallToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		return "";
	}
	
	
	@Override
	protected void emitUnassignedTokens(EObject semanticObject, ISynTransition transition, INode fromNode, INode toNode) {
		if (transition.getAmbiguousSyntaxes().isEmpty()) return;
		List<INode> transitionNodes = collectNodes(fromNode, toNode);
		for (AbstractElementAlias syntax : transition.getAmbiguousSyntaxes()) {
			List<INode> syntaxNodes = getNodesFor(transitionNodes, syntax);
			if (match_ALSAnd_AmpersandAmpersandKeyword_1_1_0_or_AndKeyword_1_1_1.equals(syntax))
				emit_ALSAnd_AmpersandAmpersandKeyword_1_1_0_or_AndKeyword_1_1_1(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_ALSBasicRelationTerm_LeftParenthesisKeyword_6_0_a.equals(syntax))
				emit_ALSBasicRelationTerm_LeftParenthesisKeyword_6_0_a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_ALSBasicRelationTerm_LeftParenthesisKeyword_6_0_p.equals(syntax))
				emit_ALSBasicRelationTerm_LeftParenthesisKeyword_6_0_p(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_ALSIff_IffKeyword_1_1_1_or_LessThanSignEqualsSignGreaterThanSignKeyword_1_1_0.equals(syntax))
				emit_ALSIff_IffKeyword_1_1_1_or_LessThanSignEqualsSignGreaterThanSignKeyword_1_1_0(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_ALSImpl_EqualsSignGreaterThanSignKeyword_1_1_0_or_ImpliesKeyword_1_1_1.equals(syntax))
				emit_ALSImpl_EqualsSignGreaterThanSignKeyword_1_1_0_or_ImpliesKeyword_1_1_1(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_ALSOr_OrKeyword_1_1_1_or_VerticalLineVerticalLineKeyword_1_1_0.equals(syntax))
				emit_ALSOr_OrKeyword_1_1_1_or_VerticalLineVerticalLineKeyword_1_1_0(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_ALSPreficed_ExclamationMarkKeyword_0_1_0_0_or_NotKeyword_0_1_0_1.equals(syntax))
				emit_ALSPreficed_ExclamationMarkKeyword_0_1_0_0_or_NotKeyword_0_1_0_1(semanticObject, getLastNavigableState(), syntaxNodes);
			else acceptNodes(getLastNavigableState(), syntaxNodes);
		}
	}

	/**
	 * Ambiguous syntax:
	 *     'and' | '&&'
	 *
	 * This ambiguous syntax occurs at:
	 *     {ALSAnd.leftOperand=} (ambiguity) rightOperand=ALSComparison
	 */
	protected void emit_ALSAnd_AmpersandAmpersandKeyword_1_1_0_or_AndKeyword_1_1_1(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     '('*
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) (ambiguity) '#' operand=ALSBasicRelationTerm
	 *     (rule start) (ambiguity) '*' operand=ALSBasicRelationTerm
	 *     (rule start) (ambiguity) '-' operand=ALSBasicRelationTerm
	 *     (rule start) (ambiguity) 'Int' (rule start)
	 *     (rule start) (ambiguity) '^' operand=ALSBasicRelationTerm
	 *     (rule start) (ambiguity) 'iden' (rule start)
	 *     (rule start) (ambiguity) 'none' (rule start)
	 *     (rule start) (ambiguity) 'sum' variables+=ALSVariableDeclaration
	 *     (rule start) (ambiguity) 'univ' (rule start)
	 *     (rule start) (ambiguity) '~' operand=ALSBasicRelationTerm
	 *     (rule start) (ambiguity) ('not' | '!') operand=ALSBasicRelationTerm
	 *     (rule start) (ambiguity) referred=[ALSRelationDeclaration|ID]
	 *     (rule start) (ambiguity) referredDefinition=[ALSDefinition|ID]
	 *     (rule start) (ambiguity) referredNumericOperator=ALSNumericOperator
	 *     (rule start) (ambiguity) type=ALSMultiplicity
	 *     (rule start) (ambiguity) value=INT
	 *     (rule start) (ambiguity) {ALSAnd.leftOperand=}
	 *     (rule start) (ambiguity) {ALSDirectProduct.leftOperand=}
	 *     (rule start) (ambiguity) {ALSEquals.leftOperand=}
	 *     (rule start) (ambiguity) {ALSIff.leftOperand=}
	 *     (rule start) (ambiguity) {ALSImpl.leftOperand=}
	 *     (rule start) (ambiguity) {ALSIntersection.leftOperand=}
	 *     (rule start) (ambiguity) {ALSJoin.leftOperand=}
	 *     (rule start) (ambiguity) {ALSLeq.leftOperand=}
	 *     (rule start) (ambiguity) {ALSLess.leftOperand=}
	 *     (rule start) (ambiguity) {ALSMeq.leftOperand=}
	 *     (rule start) (ambiguity) {ALSMinus.leftOperand=}
	 *     (rule start) (ambiguity) {ALSMore.leftOperand=}
	 *     (rule start) (ambiguity) {ALSNotEquals.leftOperand=}
	 *     (rule start) (ambiguity) {ALSOr.leftOperand=}
	 *     (rule start) (ambiguity) {ALSOverride.leftOperand=}
	 *     (rule start) (ambiguity) {ALSPlus.leftOperand=}
	 *     (rule start) (ambiguity) {ALSRangeRestrictionLeft.filter=}
	 *     (rule start) (ambiguity) {ALSRangeRestrictionRight.relation=}
	 *     (rule start) (ambiguity) {ALSSubset.leftOperand=}
	 */
	protected void emit_ALSBasicRelationTerm_LeftParenthesisKeyword_6_0_a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     '('+
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) (ambiguity) '#' operand=ALSBasicRelationTerm
	 *     (rule start) (ambiguity) '*' operand=ALSBasicRelationTerm
	 *     (rule start) (ambiguity) '-' operand=ALSBasicRelationTerm
	 *     (rule start) (ambiguity) '^' operand=ALSBasicRelationTerm
	 *     (rule start) (ambiguity) 'sum' variables+=ALSVariableDeclaration
	 *     (rule start) (ambiguity) '~' operand=ALSBasicRelationTerm
	 *     (rule start) (ambiguity) ('not' | '!') operand=ALSBasicRelationTerm
	 *     (rule start) (ambiguity) referredDefinition=[ALSDefinition|ID]
	 *     (rule start) (ambiguity) referredNumericOperator=ALSNumericOperator
	 *     (rule start) (ambiguity) type=ALSMultiplicity
	 *     (rule start) (ambiguity) {ALSAnd.leftOperand=}
	 *     (rule start) (ambiguity) {ALSDirectProduct.leftOperand=}
	 *     (rule start) (ambiguity) {ALSEquals.leftOperand=}
	 *     (rule start) (ambiguity) {ALSIff.leftOperand=}
	 *     (rule start) (ambiguity) {ALSImpl.leftOperand=}
	 *     (rule start) (ambiguity) {ALSIntersection.leftOperand=}
	 *     (rule start) (ambiguity) {ALSJoin.leftOperand=}
	 *     (rule start) (ambiguity) {ALSLeq.leftOperand=}
	 *     (rule start) (ambiguity) {ALSLess.leftOperand=}
	 *     (rule start) (ambiguity) {ALSMeq.leftOperand=}
	 *     (rule start) (ambiguity) {ALSMinus.leftOperand=}
	 *     (rule start) (ambiguity) {ALSMore.leftOperand=}
	 *     (rule start) (ambiguity) {ALSNotEquals.leftOperand=}
	 *     (rule start) (ambiguity) {ALSOr.leftOperand=}
	 *     (rule start) (ambiguity) {ALSOverride.leftOperand=}
	 *     (rule start) (ambiguity) {ALSPlus.leftOperand=}
	 *     (rule start) (ambiguity) {ALSRangeRestrictionLeft.filter=}
	 *     (rule start) (ambiguity) {ALSRangeRestrictionRight.relation=}
	 *     (rule start) (ambiguity) {ALSSubset.leftOperand=}
	 */
	protected void emit_ALSBasicRelationTerm_LeftParenthesisKeyword_6_0_p(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     'iff' | '<=>'
	 *
	 * This ambiguous syntax occurs at:
	 *     {ALSIff.leftOperand=} (ambiguity) rightOperand=ALSImpl
	 */
	protected void emit_ALSIff_IffKeyword_1_1_1_or_LessThanSignEqualsSignGreaterThanSignKeyword_1_1_0(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     '=>' | 'implies'
	 *
	 * This ambiguous syntax occurs at:
	 *     {ALSImpl.leftOperand=} (ambiguity) rightOperand=ALSAnd
	 */
	protected void emit_ALSImpl_EqualsSignGreaterThanSignKeyword_1_1_0_or_ImpliesKeyword_1_1_1(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     'or' | '||'
	 *
	 * This ambiguous syntax occurs at:
	 *     {ALSOr.leftOperand=} (ambiguity) rightOperand=ALSIff
	 */
	protected void emit_ALSOr_OrKeyword_1_1_1_or_VerticalLineVerticalLineKeyword_1_1_0(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     'not' | '!'
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) '('* (ambiguity) operand=ALSBasicRelationTerm
	 *     (rule start) '('+ (ambiguity) operand=ALSBasicRelationTerm
	 */
	protected void emit_ALSPreficed_ExclamationMarkKeyword_0_1_0_0_or_NotKeyword_0_1_0_1(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
}
