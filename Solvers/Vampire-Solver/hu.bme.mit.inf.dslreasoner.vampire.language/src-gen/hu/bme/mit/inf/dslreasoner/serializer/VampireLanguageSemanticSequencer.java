/*
 * generated by Xtext 2.12.0
 */
package hu.bme.mit.inf.dslreasoner.serializer;

import com.google.inject.Inject;
import hu.bme.mit.inf.dslreasoner.services.VampireLanguageGrammarAccess;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSAnd;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSAnnotation;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSAssignment;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSComment;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSConstant;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSDoubleQuote;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSEquality;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSEquivalent;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSExistentialQuantifier;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSFalse;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSFofFormula;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSFunction;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSFunctionFof;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSImplies;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSInclude;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSInequality;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSInt;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSLess;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSName;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSNand;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSNor;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSOr;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSRational;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSReal;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSRevImplies;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSTrue;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSUnaryNegation;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSUniversalQuantifier;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSVariable;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSXnor;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VampireLanguagePackage;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VampireModel;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class VampireLanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private VampireLanguageGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == VampireLanguagePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case VampireLanguagePackage.VLS_AND:
				sequence_VLSBinary(context, (VLSAnd) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_ANNOTATION:
				if (rule == grammarAccess.getVLSAnnotationTermsRule()) {
					sequence_VLSAnnotationTerms(context, (VLSAnnotation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVLSAnnotationRule()) {
					sequence_VLSAnnotation(context, (VLSAnnotation) semanticObject); 
					return; 
				}
				else break;
			case VampireLanguagePackage.VLS_ASSIGNMENT:
				sequence_VLSUnaryInfix(context, (VLSAssignment) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_COMMENT:
				sequence_VLSComment(context, (VLSComment) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_CONSTANT:
				sequence_VLSAtomicConstant(context, (VLSConstant) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_DOUBLE_QUOTE:
				sequence_VLSDefinedTerm(context, (VLSDoubleQuote) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_EQUALITY:
				sequence_VLSUnaryInfix(context, (VLSEquality) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_EQUIVALENT:
				sequence_VLSBinary(context, (VLSEquivalent) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_EXISTENTIAL_QUANTIFIER:
				sequence_VLSExistentialQuantifier(context, (VLSExistentialQuantifier) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_FALSE:
				sequence_VLSAtomicConstant(context, (VLSFalse) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_FOF_FORMULA:
				sequence_VLSFofFormula(context, (VLSFofFormula) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_FUNCTION:
				sequence_VLSAtomicFunction(context, (VLSFunction) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_FUNCTION_FOF:
				sequence_VLSFunctionFof(context, (VLSFunctionFof) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_IMPLIES:
				sequence_VLSBinary(context, (VLSImplies) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_INCLUDE:
				sequence_VLSInclude(context, (VLSInclude) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_INEQUALITY:
				sequence_VLSUnaryInfix(context, (VLSInequality) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_INT:
				sequence_VLSDefinedTerm(context, (VLSInt) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_LESS:
				sequence_VLSAtomicFunction(context, (VLSLess) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_NAME:
				sequence_VLSName(context, (VLSName) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_NAND:
				sequence_VLSBinary(context, (VLSNand) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_NOR:
				sequence_VLSBinary(context, (VLSNor) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_OR:
				sequence_VLSBinary(context, (VLSOr) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_RATIONAL:
				sequence_VLSDefinedTerm(context, (VLSRational) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_REAL:
				sequence_VLSDefinedTerm(context, (VLSReal) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_REV_IMPLIES:
				sequence_VLSBinary(context, (VLSRevImplies) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_TRUE:
				sequence_VLSAtomicConstant(context, (VLSTrue) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_UNARY_NEGATION:
				sequence_VLSUnaryNegation(context, (VLSUnaryNegation) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_UNIVERSAL_QUANTIFIER:
				sequence_VLSUniversalQuantifier(context, (VLSUniversalQuantifier) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_VARIABLE:
				sequence_VLSVariable(context, (VLSVariable) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_XNOR:
				sequence_VLSBinary(context, (VLSXnor) semanticObject); 
				return; 
			case VampireLanguagePackage.VAMPIRE_MODEL:
				sequence_VampireModel(context, (VampireModel) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     VLSAnnotationTerms returns VLSAnnotation
	 *
	 * Constraint:
	 *     (terms+=VLSAnnotation terms+=VLSAnnotation*)
	 */
	protected void sequence_VLSAnnotationTerms(ISerializationContext context, VLSAnnotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSAnnotation returns VLSAnnotation
	 *
	 * Constraint:
	 *     (((name=LOWER_WORD_ID | name=SINGLE_QUOTE | name=VLSRole) followup=VLSAnnotationTerms) | followup=VLSAnnotationTerms)?
	 */
	protected void sequence_VLSAnnotation(ISerializationContext context, VLSAnnotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSConstant
	 *     VLSBinary returns VLSConstant
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSConstant
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSConstant
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSConstant
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSConstant
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSConstant
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSConstant
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSConstant
	 *     VLSBinary.VLSOr_1_2_0 returns VLSConstant
	 *     VLSUnitaryFormula returns VLSConstant
	 *     VLSUnaryInfix returns VLSConstant
	 *     VLSUnaryInfix.VLSInequality_1_0_0_0 returns VLSConstant
	 *     VLSUnaryInfix.VLSEquality_1_0_1_0 returns VLSConstant
	 *     VLSUnaryInfix.VLSAssignment_1_0_2_0 returns VLSConstant
	 *     VLSAtomic returns VLSConstant
	 *     VLSAtomicConstant returns VLSConstant
	 *
	 * Constraint:
	 *     (name=LOWER_WORD_ID | name=SINGLE_QUOTE | name=DOLLAR_ID | name=DOUBLE_DOLLAR_ID | name=VLSRole)
	 */
	protected void sequence_VLSAtomicConstant(ISerializationContext context, VLSConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSFalse
	 *     VLSBinary returns VLSFalse
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSFalse
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSFalse
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSFalse
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSFalse
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSFalse
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSFalse
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSFalse
	 *     VLSBinary.VLSOr_1_2_0 returns VLSFalse
	 *     VLSUnitaryFormula returns VLSFalse
	 *     VLSUnaryInfix returns VLSFalse
	 *     VLSUnaryInfix.VLSInequality_1_0_0_0 returns VLSFalse
	 *     VLSUnaryInfix.VLSEquality_1_0_1_0 returns VLSFalse
	 *     VLSUnaryInfix.VLSAssignment_1_0_2_0 returns VLSFalse
	 *     VLSAtomic returns VLSFalse
	 *     VLSAtomicConstant returns VLSFalse
	 *
	 * Constraint:
	 *     {VLSFalse}
	 */
	protected void sequence_VLSAtomicConstant(ISerializationContext context, VLSFalse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSTrue
	 *     VLSBinary returns VLSTrue
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSTrue
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSTrue
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSTrue
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSTrue
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSTrue
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSTrue
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSTrue
	 *     VLSBinary.VLSOr_1_2_0 returns VLSTrue
	 *     VLSUnitaryFormula returns VLSTrue
	 *     VLSUnaryInfix returns VLSTrue
	 *     VLSUnaryInfix.VLSInequality_1_0_0_0 returns VLSTrue
	 *     VLSUnaryInfix.VLSEquality_1_0_1_0 returns VLSTrue
	 *     VLSUnaryInfix.VLSAssignment_1_0_2_0 returns VLSTrue
	 *     VLSAtomic returns VLSTrue
	 *     VLSAtomicConstant returns VLSTrue
	 *
	 * Constraint:
	 *     {VLSTrue}
	 */
	protected void sequence_VLSAtomicConstant(ISerializationContext context, VLSTrue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSFunction
	 *     VLSBinary returns VLSFunction
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSFunction
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSFunction
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSFunction
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSFunction
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSFunction
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSFunction
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSFunction
	 *     VLSBinary.VLSOr_1_2_0 returns VLSFunction
	 *     VLSUnitaryFormula returns VLSFunction
	 *     VLSUnaryInfix returns VLSFunction
	 *     VLSUnaryInfix.VLSInequality_1_0_0_0 returns VLSFunction
	 *     VLSUnaryInfix.VLSEquality_1_0_1_0 returns VLSFunction
	 *     VLSUnaryInfix.VLSAssignment_1_0_2_0 returns VLSFunction
	 *     VLSAtomic returns VLSFunction
	 *     VLSAtomicFunction returns VLSFunction
	 *
	 * Constraint:
	 *     (
	 *         (constant=LOWER_WORD_ID | constant=SINGLE_QUOTE | constant=DOLLAR_ID | constant=DOUBLE_DOLLAR_ID | constant=VLSRole) 
	 *         terms+=VLSFofTerm 
	 *         terms+=VLSFofTerm*
	 *     )
	 */
	protected void sequence_VLSAtomicFunction(ISerializationContext context, VLSFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSLess
	 *     VLSBinary returns VLSLess
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSLess
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSLess
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSLess
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSLess
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSLess
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSLess
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSLess
	 *     VLSBinary.VLSOr_1_2_0 returns VLSLess
	 *     VLSUnitaryFormula returns VLSLess
	 *     VLSUnaryInfix returns VLSLess
	 *     VLSUnaryInfix.VLSInequality_1_0_0_0 returns VLSLess
	 *     VLSUnaryInfix.VLSEquality_1_0_1_0 returns VLSLess
	 *     VLSUnaryInfix.VLSAssignment_1_0_2_0 returns VLSLess
	 *     VLSAtomic returns VLSLess
	 *     VLSAtomicFunction returns VLSLess
	 *
	 * Constraint:
	 *     (name='$less' terms+=VLSFofTerm terms+=VLSFofTerm)
	 */
	protected void sequence_VLSAtomicFunction(ISerializationContext context, VLSLess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSAnd
	 *     VLSBinary returns VLSAnd
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSAnd
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSAnd
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSAnd
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSAnd
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSAnd
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSAnd
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSAnd
	 *     VLSBinary.VLSOr_1_2_0 returns VLSAnd
	 *     VLSUnitaryFormula returns VLSAnd
	 *
	 * Constraint:
	 *     (left=VLSBinary_VLSAnd_1_1_0 right=VLSUnitaryFormula)
	 */
	protected void sequence_VLSBinary(ISerializationContext context, VLSAnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSBinaryAccess().getVLSAndLeftAction_1_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSBinaryAccess().getRightVLSUnitaryFormulaParserRuleCall_1_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSEquivalent
	 *     VLSBinary returns VLSEquivalent
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSEquivalent
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSEquivalent
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSEquivalent
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSEquivalent
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSEquivalent
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSEquivalent
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSEquivalent
	 *     VLSBinary.VLSOr_1_2_0 returns VLSEquivalent
	 *     VLSUnitaryFormula returns VLSEquivalent
	 *
	 * Constraint:
	 *     (left=VLSBinary_VLSEquivalent_1_0_0_0_0 right=VLSUnitaryFormula)
	 */
	protected void sequence_VLSBinary(ISerializationContext context, VLSEquivalent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_EQUIVALENT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_EQUIVALENT__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_EQUIVALENT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_EQUIVALENT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSBinaryAccess().getVLSEquivalentLeftAction_1_0_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSBinaryAccess().getRightVLSUnitaryFormulaParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSImplies
	 *     VLSBinary returns VLSImplies
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSImplies
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSImplies
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSImplies
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSImplies
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSImplies
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSImplies
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSImplies
	 *     VLSBinary.VLSOr_1_2_0 returns VLSImplies
	 *     VLSUnitaryFormula returns VLSImplies
	 *
	 * Constraint:
	 *     (left=VLSBinary_VLSImplies_1_0_0_1_0 right=VLSUnitaryFormula)
	 */
	protected void sequence_VLSBinary(ISerializationContext context, VLSImplies semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_IMPLIES__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_IMPLIES__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_IMPLIES__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_IMPLIES__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSBinaryAccess().getVLSImpliesLeftAction_1_0_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSBinaryAccess().getRightVLSUnitaryFormulaParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSNand
	 *     VLSBinary returns VLSNand
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSNand
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSNand
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSNand
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSNand
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSNand
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSNand
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSNand
	 *     VLSBinary.VLSOr_1_2_0 returns VLSNand
	 *     VLSUnitaryFormula returns VLSNand
	 *
	 * Constraint:
	 *     (left=VLSBinary_VLSNand_1_0_0_5_0 right=VLSUnitaryFormula)
	 */
	protected void sequence_VLSBinary(ISerializationContext context, VLSNand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_NAND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_NAND__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_NAND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_NAND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSBinaryAccess().getVLSNandLeftAction_1_0_0_5_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSBinaryAccess().getRightVLSUnitaryFormulaParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSNor
	 *     VLSBinary returns VLSNor
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSNor
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSNor
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSNor
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSNor
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSNor
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSNor
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSNor
	 *     VLSBinary.VLSOr_1_2_0 returns VLSNor
	 *     VLSUnitaryFormula returns VLSNor
	 *
	 * Constraint:
	 *     (left=VLSBinary_VLSNor_1_0_0_4_0 right=VLSUnitaryFormula)
	 */
	protected void sequence_VLSBinary(ISerializationContext context, VLSNor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_NOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_NOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_NOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_NOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSBinaryAccess().getVLSNorLeftAction_1_0_0_4_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSBinaryAccess().getRightVLSUnitaryFormulaParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSOr
	 *     VLSBinary returns VLSOr
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSOr
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSOr
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSOr
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSOr
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSOr
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSOr
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSOr
	 *     VLSBinary.VLSOr_1_2_0 returns VLSOr
	 *     VLSUnitaryFormula returns VLSOr
	 *
	 * Constraint:
	 *     (left=VLSBinary_VLSOr_1_2_0 right=VLSUnitaryFormula)
	 */
	protected void sequence_VLSBinary(ISerializationContext context, VLSOr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSBinaryAccess().getVLSOrLeftAction_1_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSBinaryAccess().getRightVLSUnitaryFormulaParserRuleCall_1_2_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSRevImplies
	 *     VLSBinary returns VLSRevImplies
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSRevImplies
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSRevImplies
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSRevImplies
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSRevImplies
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSRevImplies
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSRevImplies
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSRevImplies
	 *     VLSBinary.VLSOr_1_2_0 returns VLSRevImplies
	 *     VLSUnitaryFormula returns VLSRevImplies
	 *
	 * Constraint:
	 *     (left=VLSBinary_VLSRevImplies_1_0_0_2_0 right=VLSUnitaryFormula)
	 */
	protected void sequence_VLSBinary(ISerializationContext context, VLSRevImplies semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_REV_IMPLIES__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_REV_IMPLIES__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_REV_IMPLIES__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_REV_IMPLIES__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSBinaryAccess().getVLSRevImpliesLeftAction_1_0_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSBinaryAccess().getRightVLSUnitaryFormulaParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSXnor
	 *     VLSBinary returns VLSXnor
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSXnor
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSXnor
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSXnor
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSXnor
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSXnor
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSXnor
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSXnor
	 *     VLSBinary.VLSOr_1_2_0 returns VLSXnor
	 *     VLSUnitaryFormula returns VLSXnor
	 *
	 * Constraint:
	 *     (left=VLSBinary_VLSXnor_1_0_0_3_0 right=VLSUnitaryFormula)
	 */
	protected void sequence_VLSBinary(ISerializationContext context, VLSXnor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_XNOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_XNOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_XNOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_XNOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSBinaryAccess().getVLSXnorLeftAction_1_0_0_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSBinaryAccess().getRightVLSUnitaryFormulaParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSComment returns VLSComment
	 *
	 * Constraint:
	 *     comment=SINGLE_COMMENT
	 */
	protected void sequence_VLSComment(ISerializationContext context, VLSComment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_COMMENT__COMMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_COMMENT__COMMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSCommentAccess().getCommentSINGLE_COMMENTTerminalRuleCall_0(), semanticObject.getComment());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSDoubleQuote
	 *     VLSBinary returns VLSDoubleQuote
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSDoubleQuote
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSDoubleQuote
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSDoubleQuote
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSDoubleQuote
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSDoubleQuote
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSDoubleQuote
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSDoubleQuote
	 *     VLSBinary.VLSOr_1_2_0 returns VLSDoubleQuote
	 *     VLSUnitaryFormula returns VLSDoubleQuote
	 *     VLSUnaryInfix returns VLSDoubleQuote
	 *     VLSUnaryInfix.VLSInequality_1_0_0_0 returns VLSDoubleQuote
	 *     VLSUnaryInfix.VLSEquality_1_0_1_0 returns VLSDoubleQuote
	 *     VLSUnaryInfix.VLSAssignment_1_0_2_0 returns VLSDoubleQuote
	 *     VLSAtomic returns VLSDoubleQuote
	 *     VLSFofTerm returns VLSDoubleQuote
	 *     VLSDefinedTerm returns VLSDoubleQuote
	 *
	 * Constraint:
	 *     value=DOUBLE_QUOTE
	 */
	protected void sequence_VLSDefinedTerm(ISerializationContext context, VLSDoubleQuote semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_DEFINED_TERM__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_DEFINED_TERM__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSDefinedTermAccess().getValueDOUBLE_QUOTETerminalRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSInt
	 *     VLSBinary returns VLSInt
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSInt
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSInt
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSInt
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSInt
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSInt
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSInt
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSInt
	 *     VLSBinary.VLSOr_1_2_0 returns VLSInt
	 *     VLSUnitaryFormula returns VLSInt
	 *     VLSUnaryInfix returns VLSInt
	 *     VLSUnaryInfix.VLSInequality_1_0_0_0 returns VLSInt
	 *     VLSUnaryInfix.VLSEquality_1_0_1_0 returns VLSInt
	 *     VLSUnaryInfix.VLSAssignment_1_0_2_0 returns VLSInt
	 *     VLSAtomic returns VLSInt
	 *     VLSFofTerm returns VLSInt
	 *     VLSDefinedTerm returns VLSInt
	 *
	 * Constraint:
	 *     value=SIGNED_LITERAL
	 */
	protected void sequence_VLSDefinedTerm(ISerializationContext context, VLSInt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_DEFINED_TERM__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_DEFINED_TERM__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSDefinedTermAccess().getValueSIGNED_LITERALTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSRational
	 *     VLSBinary returns VLSRational
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSRational
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSRational
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSRational
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSRational
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSRational
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSRational
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSRational
	 *     VLSBinary.VLSOr_1_2_0 returns VLSRational
	 *     VLSUnitaryFormula returns VLSRational
	 *     VLSUnaryInfix returns VLSRational
	 *     VLSUnaryInfix.VLSInequality_1_0_0_0 returns VLSRational
	 *     VLSUnaryInfix.VLSEquality_1_0_1_0 returns VLSRational
	 *     VLSUnaryInfix.VLSAssignment_1_0_2_0 returns VLSRational
	 *     VLSAtomic returns VLSRational
	 *     VLSFofTerm returns VLSRational
	 *     VLSDefinedTerm returns VLSRational
	 *
	 * Constraint:
	 *     value=SIGNED_RAT_ID
	 */
	protected void sequence_VLSDefinedTerm(ISerializationContext context, VLSRational semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_DEFINED_TERM__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_DEFINED_TERM__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSDefinedTermAccess().getValueSIGNED_RAT_IDTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSReal
	 *     VLSBinary returns VLSReal
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSReal
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSReal
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSReal
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSReal
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSReal
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSReal
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSReal
	 *     VLSBinary.VLSOr_1_2_0 returns VLSReal
	 *     VLSUnitaryFormula returns VLSReal
	 *     VLSUnaryInfix returns VLSReal
	 *     VLSUnaryInfix.VLSInequality_1_0_0_0 returns VLSReal
	 *     VLSUnaryInfix.VLSEquality_1_0_1_0 returns VLSReal
	 *     VLSUnaryInfix.VLSAssignment_1_0_2_0 returns VLSReal
	 *     VLSAtomic returns VLSReal
	 *     VLSFofTerm returns VLSReal
	 *     VLSDefinedTerm returns VLSReal
	 *
	 * Constraint:
	 *     value=SIGNED_REAL_ID
	 */
	protected void sequence_VLSDefinedTerm(ISerializationContext context, VLSReal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_DEFINED_TERM__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_DEFINED_TERM__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSDefinedTermAccess().getValueSIGNED_REAL_IDTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSExistentialQuantifier
	 *     VLSBinary returns VLSExistentialQuantifier
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSExistentialQuantifier
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSExistentialQuantifier
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSExistentialQuantifier
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSExistentialQuantifier
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSExistentialQuantifier
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSExistentialQuantifier
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSExistentialQuantifier
	 *     VLSBinary.VLSOr_1_2_0 returns VLSExistentialQuantifier
	 *     VLSUnitaryFormula returns VLSExistentialQuantifier
	 *     VLSExistentialQuantifier returns VLSExistentialQuantifier
	 *
	 * Constraint:
	 *     (variables+=VLSVariable variables+=VLSVariable* operand=VLSUnitaryFormula)
	 */
	protected void sequence_VLSExistentialQuantifier(ISerializationContext context, VLSExistentialQuantifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSFofFormula returns VLSFofFormula
	 *
	 * Constraint:
	 *     ((name=LOWER_WORD_ID | name=SIGNED_LITERAL | name=SINGLE_QUOTE) fofRole=VLSRole fofFormula=VLSTerm annotations=VLSAnnotation?)
	 */
	protected void sequence_VLSFofFormula(ISerializationContext context, VLSFofFormula semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSFofTerm returns VLSFunctionFof
	 *     VLSFunctionFof returns VLSFunctionFof
	 *
	 * Constraint:
	 *     ((functor=LOWER_WORD_ID | functor=SINGLE_QUOTE | functor=DOLLAR_ID | functor=DOUBLE_DOLLAR_ID) (terms+=VLSFofTerm terms+=VLSFofTerm*)?)
	 */
	protected void sequence_VLSFunctionFof(ISerializationContext context, VLSFunctionFof semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSInclude returns VLSInclude
	 *
	 * Constraint:
	 *     (fileName=SINGLE_QUOTE (names+=VLSName names+=VLSName*)?)
	 */
	protected void sequence_VLSInclude(ISerializationContext context, VLSInclude semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSName returns VLSName
	 *
	 * Constraint:
	 *     (name=LOWER_WORD_ID | name=SINGLE_QUOTE | name=LITERAL | name=SIGNED_LITERAL)
	 */
	protected void sequence_VLSName(ISerializationContext context, VLSName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSAssignment
	 *     VLSBinary returns VLSAssignment
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSAssignment
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSAssignment
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSAssignment
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSAssignment
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSAssignment
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSAssignment
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSAssignment
	 *     VLSBinary.VLSOr_1_2_0 returns VLSAssignment
	 *     VLSUnitaryFormula returns VLSAssignment
	 *     VLSUnaryInfix returns VLSAssignment
	 *
	 * Constraint:
	 *     (left=VLSUnaryInfix_VLSAssignment_1_0_2_0 right=VLSAtomic)
	 */
	protected void sequence_VLSUnaryInfix(ISerializationContext context, VLSAssignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_ASSIGNMENT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_ASSIGNMENT__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_ASSIGNMENT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_ASSIGNMENT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSUnaryInfixAccess().getVLSAssignmentLeftAction_1_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSUnaryInfixAccess().getRightVLSAtomicParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSEquality
	 *     VLSBinary returns VLSEquality
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSEquality
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSEquality
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSEquality
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSEquality
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSEquality
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSEquality
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSEquality
	 *     VLSBinary.VLSOr_1_2_0 returns VLSEquality
	 *     VLSUnitaryFormula returns VLSEquality
	 *     VLSUnaryInfix returns VLSEquality
	 *
	 * Constraint:
	 *     (left=VLSUnaryInfix_VLSEquality_1_0_1_0 right=VLSAtomic)
	 */
	protected void sequence_VLSUnaryInfix(ISerializationContext context, VLSEquality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_EQUALITY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_EQUALITY__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_EQUALITY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_EQUALITY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSUnaryInfixAccess().getVLSEqualityLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSUnaryInfixAccess().getRightVLSAtomicParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSInequality
	 *     VLSBinary returns VLSInequality
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSInequality
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSInequality
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSInequality
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSInequality
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSInequality
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSInequality
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSInequality
	 *     VLSBinary.VLSOr_1_2_0 returns VLSInequality
	 *     VLSUnitaryFormula returns VLSInequality
	 *     VLSUnaryInfix returns VLSInequality
	 *
	 * Constraint:
	 *     (left=VLSUnaryInfix_VLSInequality_1_0_0_0 right=VLSAtomic)
	 */
	protected void sequence_VLSUnaryInfix(ISerializationContext context, VLSInequality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_INEQUALITY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_INEQUALITY__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_INEQUALITY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_INEQUALITY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSUnaryInfixAccess().getVLSInequalityLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSUnaryInfixAccess().getRightVLSAtomicParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSUnaryNegation
	 *     VLSBinary returns VLSUnaryNegation
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSUnaryNegation
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSUnaryNegation
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSUnaryNegation
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSUnaryNegation
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSUnaryNegation
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSUnaryNegation
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSUnaryNegation
	 *     VLSBinary.VLSOr_1_2_0 returns VLSUnaryNegation
	 *     VLSUnitaryFormula returns VLSUnaryNegation
	 *     VLSUnaryNegation returns VLSUnaryNegation
	 *
	 * Constraint:
	 *     operand=VLSUnitaryFormula
	 */
	protected void sequence_VLSUnaryNegation(ISerializationContext context, VLSUnaryNegation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_UNARY_NEGATION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_UNARY_NEGATION__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSUnaryNegationAccess().getOperandVLSUnitaryFormulaParserRuleCall_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSUniversalQuantifier
	 *     VLSBinary returns VLSUniversalQuantifier
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSUniversalQuantifier
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSUniversalQuantifier
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSUniversalQuantifier
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSUniversalQuantifier
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSUniversalQuantifier
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSUniversalQuantifier
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSUniversalQuantifier
	 *     VLSBinary.VLSOr_1_2_0 returns VLSUniversalQuantifier
	 *     VLSUnitaryFormula returns VLSUniversalQuantifier
	 *     VLSUniversalQuantifier returns VLSUniversalQuantifier
	 *
	 * Constraint:
	 *     (variables+=VLSVariable variables+=VLSVariable* operand=VLSUnitaryFormula)
	 */
	protected void sequence_VLSUniversalQuantifier(ISerializationContext context, VLSUniversalQuantifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSVariable
	 *     VLSBinary returns VLSVariable
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSVariable
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSVariable
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSVariable
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSVariable
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSVariable
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSVariable
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSVariable
	 *     VLSBinary.VLSOr_1_2_0 returns VLSVariable
	 *     VLSUnitaryFormula returns VLSVariable
	 *     VLSUnaryInfix returns VLSVariable
	 *     VLSUnaryInfix.VLSInequality_1_0_0_0 returns VLSVariable
	 *     VLSUnaryInfix.VLSEquality_1_0_1_0 returns VLSVariable
	 *     VLSUnaryInfix.VLSAssignment_1_0_2_0 returns VLSVariable
	 *     VLSAtomic returns VLSVariable
	 *     VLSVariable returns VLSVariable
	 *     VLSFofTerm returns VLSVariable
	 *
	 * Constraint:
	 *     name=UPPER_WORD_ID
	 */
	protected void sequence_VLSVariable(ISerializationContext context, VLSVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSVariableAccess().getNameUPPER_WORD_IDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VampireModel returns VampireModel
	 *
	 * Constraint:
	 *     (includes+=VLSInclude | comments+=VLSComment | formulas+=VLSFofFormula)+
	 */
	protected void sequence_VampireModel(ISerializationContext context, VampireModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
