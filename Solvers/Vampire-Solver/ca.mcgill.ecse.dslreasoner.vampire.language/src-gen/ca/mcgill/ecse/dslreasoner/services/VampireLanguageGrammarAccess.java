/*
 * generated by Xtext 2.14.0
 */
package ca.mcgill.ecse.dslreasoner.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class VampireLanguageGrammarAccess extends AbstractGrammarElementFinder {
	
	public class VampireModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VampireModel");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cCommentsAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cCommentsVLSCommentParserRuleCall_0_0 = (RuleCall)cCommentsAssignment_0.eContents().get(0);
		private final Assignment cConfirmationsAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cConfirmationsVLSConfirmationsParserRuleCall_1_0 = (RuleCall)cConfirmationsAssignment_1.eContents().get(0);
		private final Assignment cFormulasAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cFormulasVLSFofFormulaParserRuleCall_2_0 = (RuleCall)cFormulasAssignment_2.eContents().get(0);
		private final Assignment cTfformulasAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cTfformulasVLSTffFormulaParserRuleCall_3_0 = (RuleCall)cTfformulasAssignment_3.eContents().get(0);
		
		////@@@@@@@@@@@
		////2 things TODO:
		////1. fix anotations (ln77)
		////2. can only use declared variables in formula (ln 158)
		////@@@@@@@@@@@
		//VampireModel:
		//	(comments+=VLSComment | confirmations+=VLSConfirmations | formulas+=VLSFofFormula | tfformulas+=VLSTffFormula)*;
		@Override public ParserRule getRule() { return rule; }
		
		//(comments+=VLSComment | confirmations+=VLSConfirmations | formulas+=VLSFofFormula | tfformulas+=VLSTffFormula)*
		public Alternatives getAlternatives() { return cAlternatives; }
		
		////		includes += VLSInclude |
		//comments+=VLSComment
		public Assignment getCommentsAssignment_0() { return cCommentsAssignment_0; }
		
		//VLSComment
		public RuleCall getCommentsVLSCommentParserRuleCall_0_0() { return cCommentsVLSCommentParserRuleCall_0_0; }
		
		//confirmations+=VLSConfirmations
		public Assignment getConfirmationsAssignment_1() { return cConfirmationsAssignment_1; }
		
		//VLSConfirmations
		public RuleCall getConfirmationsVLSConfirmationsParserRuleCall_1_0() { return cConfirmationsVLSConfirmationsParserRuleCall_1_0; }
		
		//formulas+=VLSFofFormula
		public Assignment getFormulasAssignment_2() { return cFormulasAssignment_2; }
		
		//VLSFofFormula
		public RuleCall getFormulasVLSFofFormulaParserRuleCall_2_0() { return cFormulasVLSFofFormulaParserRuleCall_2_0; }
		
		//tfformulas+=VLSTffFormula
		public Assignment getTfformulasAssignment_3() { return cTfformulasAssignment_3; }
		
		//VLSTffFormula
		public RuleCall getTfformulasVLSTffFormulaParserRuleCall_3_0() { return cTfformulasVLSTffFormulaParserRuleCall_3_0; }
	}
	public class VLSCommentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSComment");
		private final Assignment cCommentAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cCommentSINGLE_COMMENTTerminalRuleCall_0 = (RuleCall)cCommentAssignment.eContents().get(0);
		
		////terminal ID:  ( !('('|')'|'\r'|'\n') )+ ;
		////////////////////////////////////
		//// VLS types
		////////////////////////////////////
		//// <includes>
		////VLSInclude:
		////	'include(' fileName = SINGLE_QUOTE ( ',[' names += VLSName (','  names += VLSName)* ']' )?
		////;
		////VLSName:
		////	name = (LOWER_WORD_ID | SINGLE_QUOTE | LITERAL | SIGNED_LITERAL)
		////;
		//// <comments>
		//VLSComment:
		//	comment=SINGLE_COMMENT
		//	//need to add a new line at the end of the file for the case where the last line is a comment
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//comment=SINGLE_COMMENT
		public Assignment getCommentAssignment() { return cCommentAssignment; }
		
		//SINGLE_COMMENT
		public RuleCall getCommentSINGLE_COMMENTTerminalRuleCall_0() { return cCommentSINGLE_COMMENTTerminalRuleCall_0; }
	}
	public class VLSConfirmationsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSConfirmations");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cVLSSatisfiableAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cSatisfiableKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cVLSWarningAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cWARNINGKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cCouldKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Keyword cNotKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Keyword cSetKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Keyword cResourceKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		private final Keyword cLimitKeyword_1_6 = (Keyword)cGroup_1.eContents().get(6);
		private final Keyword cVirtualKeyword_1_7 = (Keyword)cGroup_1.eContents().get(7);
		private final Keyword cMemoryKeyword_1_8 = (Keyword)cGroup_1.eContents().get(8);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cVLSTryingAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Keyword cTRYINGKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Assignment cNameAssignment_2_3 = (Assignment)cGroup_2.eContents().get(3);
		private final RuleCall cNameLITERALTerminalRuleCall_2_3_0 = (RuleCall)cNameAssignment_2_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2_4 = (Keyword)cGroup_2.eContents().get(4);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cVLSFiniteModelAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Keyword cFiniteKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		private final Keyword cModelKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		private final Keyword cFoundKeyword_3_3 = (Keyword)cGroup_3.eContents().get(3);
		
		////VLSConstantDeclaration: name = (LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID );
		//VLSConfirmations:
		//	{VLSSatisfiable} 'Satisfiable!' | {VLSWarning} "WARNING!" "Could" "not" "set" "resource" "limit:" "Virtual" "memory."
		//	| {VLSTrying} 'TRYING' '[' name=LITERAL ']' | {VLSFiniteModel} 'Finite' 'Model' 'Found!';
		@Override public ParserRule getRule() { return rule; }
		
		//{VLSSatisfiable} 'Satisfiable!' | {VLSWarning} "WARNING!" "Could" "not" "set" "resource" "limit:" "Virtual" "memory." |
		//{VLSTrying} 'TRYING' '[' name=LITERAL ']' | {VLSFiniteModel} 'Finite' 'Model' 'Found!'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{VLSSatisfiable} 'Satisfiable!'
		public Group getGroup_0() { return cGroup_0; }
		
		//{VLSSatisfiable}
		public Action getVLSSatisfiableAction_0_0() { return cVLSSatisfiableAction_0_0; }
		
		//'Satisfiable!'
		public Keyword getSatisfiableKeyword_0_1() { return cSatisfiableKeyword_0_1; }
		
		//{VLSWarning} "WARNING!" "Could" "not" "set" "resource" "limit:" "Virtual" "memory."
		public Group getGroup_1() { return cGroup_1; }
		
		//{VLSWarning}
		public Action getVLSWarningAction_1_0() { return cVLSWarningAction_1_0; }
		
		//"WARNING!"
		public Keyword getWARNINGKeyword_1_1() { return cWARNINGKeyword_1_1; }
		
		//"Could"
		public Keyword getCouldKeyword_1_2() { return cCouldKeyword_1_2; }
		
		//"not"
		public Keyword getNotKeyword_1_3() { return cNotKeyword_1_3; }
		
		//"set"
		public Keyword getSetKeyword_1_4() { return cSetKeyword_1_4; }
		
		//"resource"
		public Keyword getResourceKeyword_1_5() { return cResourceKeyword_1_5; }
		
		//"limit:"
		public Keyword getLimitKeyword_1_6() { return cLimitKeyword_1_6; }
		
		//"Virtual"
		public Keyword getVirtualKeyword_1_7() { return cVirtualKeyword_1_7; }
		
		//"memory."
		public Keyword getMemoryKeyword_1_8() { return cMemoryKeyword_1_8; }
		
		//{VLSTrying} 'TRYING' '[' name=LITERAL ']'
		public Group getGroup_2() { return cGroup_2; }
		
		//{VLSTrying}
		public Action getVLSTryingAction_2_0() { return cVLSTryingAction_2_0; }
		
		//'TRYING'
		public Keyword getTRYINGKeyword_2_1() { return cTRYINGKeyword_2_1; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_2_2() { return cLeftSquareBracketKeyword_2_2; }
		
		//name=LITERAL
		public Assignment getNameAssignment_2_3() { return cNameAssignment_2_3; }
		
		//LITERAL
		public RuleCall getNameLITERALTerminalRuleCall_2_3_0() { return cNameLITERALTerminalRuleCall_2_3_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_2_4() { return cRightSquareBracketKeyword_2_4; }
		
		//{VLSFiniteModel} 'Finite' 'Model' 'Found!'
		public Group getGroup_3() { return cGroup_3; }
		
		//{VLSFiniteModel}
		public Action getVLSFiniteModelAction_3_0() { return cVLSFiniteModelAction_3_0; }
		
		//'Finite'
		public Keyword getFiniteKeyword_3_1() { return cFiniteKeyword_3_1; }
		
		//'Model'
		public Keyword getModelKeyword_3_2() { return cModelKeyword_3_2; }
		
		//'Found!'
		public Keyword getFoundKeyword_3_3() { return cFoundKeyword_3_3; }
	}
	public class VLSFofFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSFofFormula");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFofKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cNameAlternatives_2_0 = (Alternatives)cNameAssignment_2.eContents().get(0);
		private final RuleCall cNameLOWER_WORD_IDTerminalRuleCall_2_0_0 = (RuleCall)cNameAlternatives_2_0.eContents().get(0);
		private final RuleCall cNameSIGNED_LITERALTerminalRuleCall_2_0_1 = (RuleCall)cNameAlternatives_2_0.eContents().get(1);
		private final RuleCall cNameSINGLE_QUOTETerminalRuleCall_2_0_2 = (RuleCall)cNameAlternatives_2_0.eContents().get(2);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cFofRoleAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cFofRoleVLSRoleParserRuleCall_4_0 = (RuleCall)cFofRoleAssignment_4.eContents().get(0);
		private final Keyword cCommaKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cFofFormulaAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cFofFormulaVLSTermParserRuleCall_6_0 = (RuleCall)cFofFormulaAssignment_6.eContents().get(0);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cCommaKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Assignment cAnnotationsAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cAnnotationsVLSAnnotationParserRuleCall_7_1_0 = (RuleCall)cAnnotationsAssignment_7_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Keyword cFullStopKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		//// <FOF formulas>
		//VLSFofFormula:
		//	'fof' '(' name=(LOWER_WORD_ID | SIGNED_LITERAL | SINGLE_QUOTE) ',' fofRole=VLSRole ',' fofFormula=VLSTerm (','
		//	annotations=VLSAnnotation)? ')' '.';
		@Override public ParserRule getRule() { return rule; }
		
		//'fof' '(' name=(LOWER_WORD_ID | SIGNED_LITERAL | SINGLE_QUOTE) ',' fofRole=VLSRole ',' fofFormula=VLSTerm (','
		//annotations=VLSAnnotation)? ')' '.'
		public Group getGroup() { return cGroup; }
		
		//'fof'
		public Keyword getFofKeyword_0() { return cFofKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//name=(LOWER_WORD_ID | SIGNED_LITERAL | SINGLE_QUOTE)
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//(LOWER_WORD_ID | SIGNED_LITERAL | SINGLE_QUOTE)
		public Alternatives getNameAlternatives_2_0() { return cNameAlternatives_2_0; }
		
		//LOWER_WORD_ID
		public RuleCall getNameLOWER_WORD_IDTerminalRuleCall_2_0_0() { return cNameLOWER_WORD_IDTerminalRuleCall_2_0_0; }
		
		//SIGNED_LITERAL
		public RuleCall getNameSIGNED_LITERALTerminalRuleCall_2_0_1() { return cNameSIGNED_LITERALTerminalRuleCall_2_0_1; }
		
		//SINGLE_QUOTE
		public RuleCall getNameSINGLE_QUOTETerminalRuleCall_2_0_2() { return cNameSINGLE_QUOTETerminalRuleCall_2_0_2; }
		
		//','
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//fofRole=VLSRole
		public Assignment getFofRoleAssignment_4() { return cFofRoleAssignment_4; }
		
		//VLSRole
		public RuleCall getFofRoleVLSRoleParserRuleCall_4_0() { return cFofRoleVLSRoleParserRuleCall_4_0; }
		
		//','
		public Keyword getCommaKeyword_5() { return cCommaKeyword_5; }
		
		//fofFormula=VLSTerm
		public Assignment getFofFormulaAssignment_6() { return cFofFormulaAssignment_6; }
		
		//VLSTerm
		public RuleCall getFofFormulaVLSTermParserRuleCall_6_0() { return cFofFormulaVLSTermParserRuleCall_6_0; }
		
		//(',' annotations=VLSAnnotation)?
		public Group getGroup_7() { return cGroup_7; }
		
		//','
		public Keyword getCommaKeyword_7_0() { return cCommaKeyword_7_0; }
		
		//annotations=VLSAnnotation
		public Assignment getAnnotationsAssignment_7_1() { return cAnnotationsAssignment_7_1; }
		
		//VLSAnnotation
		public RuleCall getAnnotationsVLSAnnotationParserRuleCall_7_1_0() { return cAnnotationsVLSAnnotationParserRuleCall_7_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_8() { return cRightParenthesisKeyword_8; }
		
		//'.'
		public Keyword getFullStopKeyword_9() { return cFullStopKeyword_9; }
	}
	public class VLSTffFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSTffFormula");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTffKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameVLSTffNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cTffRoleAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTffRoleVLSRoleParserRuleCall_4_0 = (RuleCall)cTffRoleAssignment_4.eContents().get(0);
		private final Keyword cCommaKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cFofFormulaAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cFofFormulaVLSTffTermParserRuleCall_6_0 = (RuleCall)cFofFormulaAssignment_6.eContents().get(0);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cCommaKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Assignment cAnnotationsAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cAnnotationsVLSAnnotationParserRuleCall_7_1_0 = (RuleCall)cAnnotationsAssignment_7_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Keyword cFullStopKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		//VLSTffFormula:
		//	'tff' '(' name=VLSTffName ',' tffRole=VLSRole ',' fofFormula=VLSTffTerm (',' annotations=VLSAnnotation)? ')' '.';
		@Override public ParserRule getRule() { return rule; }
		
		//'tff' '(' name=VLSTffName ',' tffRole=VLSRole ',' fofFormula=VLSTffTerm (',' annotations=VLSAnnotation)? ')' '.'
		public Group getGroup() { return cGroup; }
		
		//'tff'
		public Keyword getTffKeyword_0() { return cTffKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//name=VLSTffName
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//VLSTffName
		public RuleCall getNameVLSTffNameParserRuleCall_2_0() { return cNameVLSTffNameParserRuleCall_2_0; }
		
		//','
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//tffRole=VLSRole
		public Assignment getTffRoleAssignment_4() { return cTffRoleAssignment_4; }
		
		//VLSRole
		public RuleCall getTffRoleVLSRoleParserRuleCall_4_0() { return cTffRoleVLSRoleParserRuleCall_4_0; }
		
		//','
		public Keyword getCommaKeyword_5() { return cCommaKeyword_5; }
		
		//fofFormula=VLSTffTerm
		public Assignment getFofFormulaAssignment_6() { return cFofFormulaAssignment_6; }
		
		//VLSTffTerm
		public RuleCall getFofFormulaVLSTffTermParserRuleCall_6_0() { return cFofFormulaVLSTffTermParserRuleCall_6_0; }
		
		//(',' annotations=VLSAnnotation)?
		public Group getGroup_7() { return cGroup_7; }
		
		//','
		public Keyword getCommaKeyword_7_0() { return cCommaKeyword_7_0; }
		
		//annotations=VLSAnnotation
		public Assignment getAnnotationsAssignment_7_1() { return cAnnotationsAssignment_7_1; }
		
		//VLSAnnotation
		public RuleCall getAnnotationsVLSAnnotationParserRuleCall_7_1_0() { return cAnnotationsVLSAnnotationParserRuleCall_7_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_8() { return cRightParenthesisKeyword_8; }
		
		//'.'
		public Keyword getFullStopKeyword_9() { return cFullStopKeyword_9; }
	}
	public class VLSTffNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSTffName");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVLSTffDeclPredParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVLSTffFiniteParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVLSTffDistinctParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//VLSTffName:
		//	VLSTffDeclPred | VLSTffFinite | VLSTffDistinct;
		@Override public ParserRule getRule() { return rule; }
		
		//VLSTffDeclPred | VLSTffFinite | VLSTffDistinct
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//VLSTffDeclPred
		public RuleCall getVLSTffDeclPredParserRuleCall_0() { return cVLSTffDeclPredParserRuleCall_0; }
		
		//VLSTffFinite
		public RuleCall getVLSTffFiniteParserRuleCall_1() { return cVLSTffFiniteParserRuleCall_1; }
		
		//VLSTffDistinct
		public RuleCall getVLSTffDistinctParserRuleCall_2() { return cVLSTffDistinctParserRuleCall_2; }
	}
	public class VLSTffDistinctElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSTffDistinct");
		private final Keyword cDistinct_domainKeyword = (Keyword)rule.eContents().get(1);
		
		//VLSTffDistinct:
		//	'distinct_domain';
		@Override public ParserRule getRule() { return rule; }
		
		//'distinct_domain'
		public Keyword getDistinct_domainKeyword() { return cDistinct_domainKeyword; }
	}
	public class VLSTffFiniteElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSTffFinite");
		private final Keyword cFinite_domainKeyword = (Keyword)rule.eContents().get(1);
		
		//VLSTffFinite:
		//	'finite_domain';
		@Override public ParserRule getRule() { return rule; }
		
		//'finite_domain'
		public Keyword getFinite_domainKeyword() { return cFinite_domainKeyword; }
	}
	public class VLSTffDeclPredElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSTffDeclPred");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cDeclare_Keyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cDOLLAR_IDTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cLOWER_WORD_IDTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//VLSTffDeclPred:
		//	'declare_' DOLLAR_ID | LOWER_WORD_ID;
		@Override public ParserRule getRule() { return rule; }
		
		//'declare_' DOLLAR_ID | LOWER_WORD_ID
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'declare_' DOLLAR_ID
		public Group getGroup_0() { return cGroup_0; }
		
		//'declare_'
		public Keyword getDeclare_Keyword_0_0() { return cDeclare_Keyword_0_0; }
		
		//DOLLAR_ID
		public RuleCall getDOLLAR_IDTerminalRuleCall_0_1() { return cDOLLAR_IDTerminalRuleCall_0_1; }
		
		//LOWER_WORD_ID
		public RuleCall getLOWER_WORD_IDTerminalRuleCall_1() { return cLOWER_WORD_IDTerminalRuleCall_1; }
	}
	public class VLSRoleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSRole");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAxiomKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cConjectureKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cHypothesisKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cDefinitionKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cAssumptionKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cLemmaKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cTheoremKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cCorollaryKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cNegated_conjectureKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cPlainKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cTypeKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cFi_domainKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cFi_functorsKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cFi_predicatesKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cUnknownKeyword_14 = (Keyword)cAlternatives.eContents().get(14);
		
		///*
		////NAME
		//VLSName:
		//	//(atomic_Word = Atomic_Word | integer = Integer | single_quote_word = Single_Quote_Word)
		//	name = (LOWER_WORD_ID | SIGNED_INT_ID | SINGLE_QUOTE)
		//;
		//*/ //<ROLE>
		//VLSRole:
		//	"axiom" | "conjecture" | "hypothesis" | "definition" | "assumption" | "lemma"
		//	| "theorem" | "corollary" | "negated_conjecture" | "plain" | "type" |
		//	"fi_domain" | "fi_functors" | "fi_predicates" | "unknown";
		@Override public ParserRule getRule() { return rule; }
		
		//"axiom" | "conjecture" | "hypothesis" | "definition" | "assumption" | "lemma" | "theorem" | "corollary" |
		//"negated_conjecture" | "plain" | "type" | "fi_domain" | "fi_functors" | "fi_predicates" | "unknown"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//"axiom"
		public Keyword getAxiomKeyword_0() { return cAxiomKeyword_0; }
		
		//"conjecture"
		public Keyword getConjectureKeyword_1() { return cConjectureKeyword_1; }
		
		//"hypothesis"
		public Keyword getHypothesisKeyword_2() { return cHypothesisKeyword_2; }
		
		//"definition"
		public Keyword getDefinitionKeyword_3() { return cDefinitionKeyword_3; }
		
		//"assumption"
		public Keyword getAssumptionKeyword_4() { return cAssumptionKeyword_4; }
		
		//"lemma"
		public Keyword getLemmaKeyword_5() { return cLemmaKeyword_5; }
		
		//"theorem"
		public Keyword getTheoremKeyword_6() { return cTheoremKeyword_6; }
		
		//"corollary"
		public Keyword getCorollaryKeyword_7() { return cCorollaryKeyword_7; }
		
		//"negated_conjecture"
		public Keyword getNegated_conjectureKeyword_8() { return cNegated_conjectureKeyword_8; }
		
		//"plain"
		public Keyword getPlainKeyword_9() { return cPlainKeyword_9; }
		
		//"type"
		public Keyword getTypeKeyword_10() { return cTypeKeyword_10; }
		
		//"fi_domain"
		public Keyword getFi_domainKeyword_11() { return cFi_domainKeyword_11; }
		
		//"fi_functors"
		public Keyword getFi_functorsKeyword_12() { return cFi_functorsKeyword_12; }
		
		//"fi_predicates"
		public Keyword getFi_predicatesKeyword_13() { return cFi_predicatesKeyword_13; }
		
		//"unknown"
		public Keyword getUnknownKeyword_14() { return cUnknownKeyword_14; }
	}
	public class VLSAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSAnnotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cNameAlternatives_1_0 = (Alternatives)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameLOWER_WORD_IDTerminalRuleCall_1_0_0 = (RuleCall)cNameAlternatives_1_0.eContents().get(0);
		private final RuleCall cNameSINGLE_QUOTETerminalRuleCall_1_0_1 = (RuleCall)cNameAlternatives_1_0.eContents().get(1);
		private final RuleCall cNameVLSRoleParserRuleCall_1_0_2 = (RuleCall)cNameAlternatives_1_0.eContents().get(2);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cFollowupAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cFollowupVLSAnnotationTermsParserRuleCall_2_1_0 = (RuleCall)cFollowupAssignment_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		///*
		////VLSRole:
		////	VLSAxiom | VLSConjecture | VLSHypothesis | VLSDefinition |
		////	VLSAssumption | VLSLemma | VLSTheorem | VLSCorollary | VLSNegated_Conjecture |
		////	VLSPlain | VLSType |VLSFi_Domain | VLSFi_Functors | VLSFi_Predicates | VLSUnknown
		////;
		////
		////VLSAxiom:
		////	"axiom"
		////;
		////
		////VLSConjecture:
		////	"conjecture"
		////;
		////
		////VLSHypothesis:
		////	"hypothesis"
		////;
		////	
		////VLSDefinition:
		////	"definition"
		////;
		////
		////VLSAssumption:
		////	"assumption"
		////;
		////		
		////VLSLemma:
		////	"lemma"
		////;
		////			
		////VLSTheorem:
		////	"theorem"
		////;
		////				
		////VLSCorollary:
		////	"corollary"
		////;
		////			
		////VLSNegated_Conjecture:
		////	"negated_conjecture"	
		////;
		////
		////VLSPlain:
		////	"plain"
		////;
		////
		////VLSType:
		////	"type"
		////;
		////
		////VLSFi_Domain:
		////	"fi_domain"
		////;
		////
		////VLSFi_Functors:
		////	"fi_functors"
		////;
		////
		////VLSFi_Predicates:
		////	"fi_predicates"
		////;
		////
		////VLSUnknown:
		////	"unknown"
		////;
		//*/ // <ANNOTATION>
		//// Not at all based on the website. based on what we think the output will be like 
		//VLSAnnotation:
		//	'['? name=(LOWER_WORD_ID | SINGLE_QUOTE | VLSRole)? ('(' followup=VLSAnnotationTerms ')')? ']'?;
		@Override public ParserRule getRule() { return rule; }
		
		//'['? name=(LOWER_WORD_ID | SINGLE_QUOTE | VLSRole)? ('(' followup=VLSAnnotationTerms ')')? ']'?
		public Group getGroup() { return cGroup; }
		
		//'['?
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//name=(LOWER_WORD_ID | SINGLE_QUOTE | VLSRole)?
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//(LOWER_WORD_ID | SINGLE_QUOTE | VLSRole)
		public Alternatives getNameAlternatives_1_0() { return cNameAlternatives_1_0; }
		
		//LOWER_WORD_ID
		public RuleCall getNameLOWER_WORD_IDTerminalRuleCall_1_0_0() { return cNameLOWER_WORD_IDTerminalRuleCall_1_0_0; }
		
		//SINGLE_QUOTE
		public RuleCall getNameSINGLE_QUOTETerminalRuleCall_1_0_1() { return cNameSINGLE_QUOTETerminalRuleCall_1_0_1; }
		
		//VLSRole
		public RuleCall getNameVLSRoleParserRuleCall_1_0_2() { return cNameVLSRoleParserRuleCall_1_0_2; }
		
		//('(' followup=VLSAnnotationTerms ')')?
		public Group getGroup_2() { return cGroup_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }
		
		//followup=VLSAnnotationTerms
		public Assignment getFollowupAssignment_2_1() { return cFollowupAssignment_2_1; }
		
		//VLSAnnotationTerms
		public RuleCall getFollowupVLSAnnotationTermsParserRuleCall_2_1_0() { return cFollowupVLSAnnotationTermsParserRuleCall_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
		
		//']'?
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}
	public class VLSAnnotationTermsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSAnnotationTerms");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTermsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTermsVLSAnnotationParserRuleCall_0_0 = (RuleCall)cTermsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTermsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTermsVLSAnnotationParserRuleCall_1_1_0 = (RuleCall)cTermsAssignment_1_1.eContents().get(0);
		
		//VLSAnnotationTerms VLSAnnotation:
		//	terms+=VLSAnnotation (',' terms+=VLSAnnotation)*;
		@Override public ParserRule getRule() { return rule; }
		
		//terms+=VLSAnnotation (',' terms+=VLSAnnotation)*
		public Group getGroup() { return cGroup; }
		
		//terms+=VLSAnnotation
		public Assignment getTermsAssignment_0() { return cTermsAssignment_0; }
		
		//VLSAnnotation
		public RuleCall getTermsVLSAnnotationParserRuleCall_0_0() { return cTermsVLSAnnotationParserRuleCall_0_0; }
		
		//(',' terms+=VLSAnnotation)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//terms+=VLSAnnotation
		public Assignment getTermsAssignment_1_1() { return cTermsAssignment_1_1; }
		
		//VLSAnnotation
		public RuleCall getTermsVLSAnnotationParserRuleCall_1_1_0() { return cTermsVLSAnnotationParserRuleCall_1_1_0; }
	}
	public class VLSTffTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSTffTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVLSTermParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVLSDeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVLSCommentTermParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		////////////////////////////////////
		//// VLS Terms
		////////////////////////////////////
		//VLSTffTerm:
		//	VLSTerm | VLSDeclaration | VLSCommentTerm;
		@Override public ParserRule getRule() { return rule; }
		
		//VLSTerm | VLSDeclaration | VLSCommentTerm
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//VLSTerm
		public RuleCall getVLSTermParserRuleCall_0() { return cVLSTermParserRuleCall_0; }
		
		//VLSDeclaration
		public RuleCall getVLSDeclarationParserRuleCall_1() { return cVLSDeclarationParserRuleCall_1; }
		
		//VLSCommentTerm
		public RuleCall getVLSCommentTermParserRuleCall_2() { return cVLSCommentTermParserRuleCall_2; }
	}
	public class VLSCommentTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSCommentTerm");
		private final Assignment cCommentAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cCommentSINGLE_COMMENTTerminalRuleCall_0 = (RuleCall)cCommentAssignment.eContents().get(0);
		
		//VLSCommentTerm VLSTerm:
		//	comment=SINGLE_COMMENT;
		@Override public ParserRule getRule() { return rule; }
		
		//comment=SINGLE_COMMENT
		public Assignment getCommentAssignment() { return cCommentAssignment; }
		
		//SINGLE_COMMENT
		public RuleCall getCommentSINGLE_COMMENTTerminalRuleCall_0() { return cCommentSINGLE_COMMENTTerminalRuleCall_0; }
	}
	public class VLSDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSDeclaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVLSVariableDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVLSOtherDeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		///////////////////
		////TFF Specific
		// VLSDeclaration:
		//	VLSVariableDeclaration | VLSOtherDeclaration;
		@Override public ParserRule getRule() { return rule; }
		
		//VLSVariableDeclaration | VLSOtherDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//VLSVariableDeclaration
		public RuleCall getVLSVariableDeclarationParserRuleCall_0() { return cVLSVariableDeclarationParserRuleCall_0; }
		
		//VLSOtherDeclaration
		public RuleCall getVLSOtherDeclarationParserRuleCall_1() { return cVLSOtherDeclarationParserRuleCall_1; }
	}
	public class VLSOtherDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSOtherDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameVLSAtomicConstantParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeVLSTypeDefParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//VLSOtherDeclaration:
		//	name=VLSAtomicConstant ':' type=VLSTypeDef;
		@Override public ParserRule getRule() { return rule; }
		
		//name=VLSAtomicConstant ':' type=VLSTypeDef
		public Group getGroup() { return cGroup; }
		
		//name=VLSAtomicConstant
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//VLSAtomicConstant
		public RuleCall getNameVLSAtomicConstantParserRuleCall_0_0() { return cNameVLSAtomicConstantParserRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type=VLSTypeDef
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//VLSTypeDef
		public RuleCall getTypeVLSTypeDefParserRuleCall_2_0() { return cTypeVLSTypeDefParserRuleCall_2_0; }
	}
	public class VLSVariableDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSVariableDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameVLSVariableParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeVLSTypeDefParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//VLSVariableDeclaration:
		//	name=VLSVariable ':' type=VLSTypeDef;
		@Override public ParserRule getRule() { return rule; }
		
		//name=VLSVariable ':' type=VLSTypeDef
		public Group getGroup() { return cGroup; }
		
		//name=VLSVariable
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//VLSVariable
		public RuleCall getNameVLSVariableParserRuleCall_0_0() { return cNameVLSVariableParserRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type=VLSTypeDef
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//VLSTypeDef
		public RuleCall getTypeVLSTypeDefParserRuleCall_2_0() { return cTypeVLSTypeDefParserRuleCall_2_0; }
	}
	public class VLSTypeDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSTypeDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeSigAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeSigVLSUnitaryTermParserRuleCall_0_0 = (RuleCall)cTypeSigAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cMapsToAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cMapsToVLSAtomicConstantParserRuleCall_1_1_0 = (RuleCall)cMapsToAssignment_1_1.eContents().get(0);
		
		//VLSTypeDef:
		//	typeSig=VLSUnitaryTerm ('>' mapsTo=VLSAtomicConstant)? //might need to make VLSAtomic to include VLSVariable
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//typeSig=VLSUnitaryTerm ('>' mapsTo=VLSAtomicConstant)?
		public Group getGroup() { return cGroup; }
		
		//typeSig=VLSUnitaryTerm
		public Assignment getTypeSigAssignment_0() { return cTypeSigAssignment_0; }
		
		//VLSUnitaryTerm
		public RuleCall getTypeSigVLSUnitaryTermParserRuleCall_0_0() { return cTypeSigVLSUnitaryTermParserRuleCall_0_0; }
		
		//('>' mapsTo=VLSAtomicConstant)?
		public Group getGroup_1() { return cGroup_1; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_1_0() { return cGreaterThanSignKeyword_1_0; }
		
		//mapsTo=VLSAtomicConstant
		public Assignment getMapsToAssignment_1_1() { return cMapsToAssignment_1_1; }
		
		//VLSAtomicConstant
		public RuleCall getMapsToVLSAtomicConstantParserRuleCall_1_1_0() { return cMapsToVLSAtomicConstantParserRuleCall_1_1_0; }
	}
	public class VLSUnitaryTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSUnitaryTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInitTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cInitTypeVLSAtomicParserRuleCall_0_0 = (RuleCall)cInitTypeAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cAsteriskKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cNextTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNextTypeVLSAtomicConstantParserRuleCall_1_1_0 = (RuleCall)cNextTypeAssignment_1_1.eContents().get(0);
		
		//VLSUnitaryTerm VLSTypeDef:
		//	initType=VLSAtomic ('*' nextType=VLSAtomicConstant)* //might need to make VLSAtomic to include VLSVariable
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//initType=VLSAtomic ('*' nextType=VLSAtomicConstant)*
		public Group getGroup() { return cGroup; }
		
		//initType=VLSAtomic
		public Assignment getInitTypeAssignment_0() { return cInitTypeAssignment_0; }
		
		//VLSAtomic
		public RuleCall getInitTypeVLSAtomicParserRuleCall_0_0() { return cInitTypeVLSAtomicParserRuleCall_0_0; }
		
		//('*' nextType=VLSAtomicConstant)*
		public Group getGroup_1() { return cGroup_1; }
		
		//'*'
		public Keyword getAsteriskKeyword_1_0() { return cAsteriskKeyword_1_0; }
		
		//nextType=VLSAtomicConstant
		public Assignment getNextTypeAssignment_1_1() { return cNextTypeAssignment_1_1; }
		
		//VLSAtomicConstant
		public RuleCall getNextTypeVLSAtomicConstantParserRuleCall_1_1_0() { return cNextTypeVLSAtomicConstantParserRuleCall_1_1_0; }
	}
	public class VLSTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSTerm");
		private final RuleCall cVLSBinaryParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		////TFF Specific
		///////////////////
		//VLSTerm:
		//	VLSBinary;
		@Override public ParserRule getRule() { return rule; }
		
		////( VLSLogic | VLSSequent)
		//VLSBinary
		public RuleCall getVLSBinaryParserRuleCall() { return cVLSBinaryParserRuleCall; }
	}
	public class VLSBinaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSBinary");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cVLSUnitaryFormulaParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Alternatives cAlternatives_1_0_0 = (Alternatives)cGroup_1_0.eContents().get(0);
		private final Group cGroup_1_0_0_0 = (Group)cAlternatives_1_0_0.eContents().get(0);
		private final Action cVLSEquivalentLeftAction_1_0_0_0_0 = (Action)cGroup_1_0_0_0.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignGreaterThanSignKeyword_1_0_0_0_1 = (Keyword)cGroup_1_0_0_0.eContents().get(1);
		private final Group cGroup_1_0_0_1 = (Group)cAlternatives_1_0_0.eContents().get(1);
		private final Action cVLSImpliesLeftAction_1_0_0_1_0 = (Action)cGroup_1_0_0_1.eContents().get(0);
		private final Keyword cEqualsSignGreaterThanSignKeyword_1_0_0_1_1 = (Keyword)cGroup_1_0_0_1.eContents().get(1);
		private final Group cGroup_1_0_0_2 = (Group)cAlternatives_1_0_0.eContents().get(2);
		private final Action cVLSRevImpliesLeftAction_1_0_0_2_0 = (Action)cGroup_1_0_0_2.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignKeyword_1_0_0_2_1 = (Keyword)cGroup_1_0_0_2.eContents().get(1);
		private final Group cGroup_1_0_0_3 = (Group)cAlternatives_1_0_0.eContents().get(3);
		private final Action cVLSXnorLeftAction_1_0_0_3_0 = (Action)cGroup_1_0_0_3.eContents().get(0);
		private final Keyword cLessThanSignTildeGreaterThanSignKeyword_1_0_0_3_1 = (Keyword)cGroup_1_0_0_3.eContents().get(1);
		private final Group cGroup_1_0_0_4 = (Group)cAlternatives_1_0_0.eContents().get(4);
		private final Action cVLSNorLeftAction_1_0_0_4_0 = (Action)cGroup_1_0_0_4.eContents().get(0);
		private final Keyword cTildeVerticalLineKeyword_1_0_0_4_1 = (Keyword)cGroup_1_0_0_4.eContents().get(1);
		private final Group cGroup_1_0_0_5 = (Group)cAlternatives_1_0_0.eContents().get(5);
		private final Action cVLSNandLeftAction_1_0_0_5_0 = (Action)cGroup_1_0_0_5.eContents().get(0);
		private final Keyword cTildeAmpersandKeyword_1_0_0_5_1 = (Keyword)cGroup_1_0_0_5.eContents().get(1);
		private final Assignment cRightAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cRightVLSUnitaryFormulaParserRuleCall_1_0_1_0 = (RuleCall)cRightAssignment_1_0_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Action cVLSAndLeftAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Keyword cAmpersandKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cRightVLSUnitaryFormulaParserRuleCall_1_1_2_0 = (RuleCall)cRightAssignment_1_1_2.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cAlternatives_1.eContents().get(2);
		private final Action cVLSOrLeftAction_1_2_0 = (Action)cGroup_1_2.eContents().get(0);
		private final Keyword cVerticalLineKeyword_1_2_1 = (Keyword)cGroup_1_2.eContents().get(1);
		private final Assignment cRightAssignment_1_2_2 = (Assignment)cGroup_1_2.eContents().get(2);
		private final RuleCall cRightVLSUnitaryFormulaParserRuleCall_1_2_2_0 = (RuleCall)cRightAssignment_1_2_2.eContents().get(0);
		
		////*
		////VLSBinaryFormula
		//VLSBinary VLSTerm:
		//	VLSUnitaryFormula (({VLSEquivalent.left=current} "<=>" | {VLSImplies.left=current} "=>" |
		//	{VLSRevImplies.left=current} "<=" | {VLSXnor.left=current} "<~>" | {VLSNor.left=current} "~|" |
		//	{VLSNand.left=current} "~&") right=VLSUnitaryFormula | ({VLSAnd.left=current} '&' right=VLSUnitaryFormula)+
		//	| ({VLSOr.left=current} '|' right=VLSUnitaryFormula)+)?;
		@Override public ParserRule getRule() { return rule; }
		
		//VLSUnitaryFormula (({VLSEquivalent.left=current} "<=>" | {VLSImplies.left=current} "=>" | {VLSRevImplies.left=current}
		//"<=" | {VLSXnor.left=current} "<~>" | {VLSNor.left=current} "~|" | {VLSNand.left=current} "~&")
		//right=VLSUnitaryFormula | ({VLSAnd.left=current} '&' right=VLSUnitaryFormula)+ | ({VLSOr.left=current} '|'
		//right=VLSUnitaryFormula)+)?
		public Group getGroup() { return cGroup; }
		
		//VLSUnitaryFormula
		public RuleCall getVLSUnitaryFormulaParserRuleCall_0() { return cVLSUnitaryFormulaParserRuleCall_0; }
		
		//(({VLSEquivalent.left=current} "<=>" | {VLSImplies.left=current} "=>" | {VLSRevImplies.left=current} "<=" |
		//{VLSXnor.left=current} "<~>" | {VLSNor.left=current} "~|" | {VLSNand.left=current} "~&") right=VLSUnitaryFormula |
		//({VLSAnd.left=current} '&' right=VLSUnitaryFormula)+ | ({VLSOr.left=current} '|' right=VLSUnitaryFormula)+)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//({VLSEquivalent.left=current} "<=>" | {VLSImplies.left=current} "=>" | {VLSRevImplies.left=current} "<=" |
		//{VLSXnor.left=current} "<~>" | {VLSNor.left=current} "~|" | {VLSNand.left=current} "~&") right=VLSUnitaryFormula
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{VLSEquivalent.left=current} "<=>" | {VLSImplies.left=current} "=>" | {VLSRevImplies.left=current} "<=" |
		//{VLSXnor.left=current} "<~>" | {VLSNor.left=current} "~|" | {VLSNand.left=current} "~&"
		public Alternatives getAlternatives_1_0_0() { return cAlternatives_1_0_0; }
		
		//{VLSEquivalent.left=current} "<=>"
		public Group getGroup_1_0_0_0() { return cGroup_1_0_0_0; }
		
		//{VLSEquivalent.left=current}
		public Action getVLSEquivalentLeftAction_1_0_0_0_0() { return cVLSEquivalentLeftAction_1_0_0_0_0; }
		
		//"<=>"
		public Keyword getLessThanSignEqualsSignGreaterThanSignKeyword_1_0_0_0_1() { return cLessThanSignEqualsSignGreaterThanSignKeyword_1_0_0_0_1; }
		
		//{VLSImplies.left=current} "=>"
		public Group getGroup_1_0_0_1() { return cGroup_1_0_0_1; }
		
		//{VLSImplies.left=current}
		public Action getVLSImpliesLeftAction_1_0_0_1_0() { return cVLSImpliesLeftAction_1_0_0_1_0; }
		
		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_1_0_0_1_1() { return cEqualsSignGreaterThanSignKeyword_1_0_0_1_1; }
		
		//{VLSRevImplies.left=current} "<="
		public Group getGroup_1_0_0_2() { return cGroup_1_0_0_2; }
		
		//{VLSRevImplies.left=current}
		public Action getVLSRevImpliesLeftAction_1_0_0_2_0() { return cVLSRevImpliesLeftAction_1_0_0_2_0; }
		
		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1_0_0_2_1() { return cLessThanSignEqualsSignKeyword_1_0_0_2_1; }
		
		//{VLSXnor.left=current} "<~>"
		public Group getGroup_1_0_0_3() { return cGroup_1_0_0_3; }
		
		//{VLSXnor.left=current}
		public Action getVLSXnorLeftAction_1_0_0_3_0() { return cVLSXnorLeftAction_1_0_0_3_0; }
		
		//"<~>"
		public Keyword getLessThanSignTildeGreaterThanSignKeyword_1_0_0_3_1() { return cLessThanSignTildeGreaterThanSignKeyword_1_0_0_3_1; }
		
		//{VLSNor.left=current} "~|"
		public Group getGroup_1_0_0_4() { return cGroup_1_0_0_4; }
		
		//{VLSNor.left=current}
		public Action getVLSNorLeftAction_1_0_0_4_0() { return cVLSNorLeftAction_1_0_0_4_0; }
		
		//"~|"
		public Keyword getTildeVerticalLineKeyword_1_0_0_4_1() { return cTildeVerticalLineKeyword_1_0_0_4_1; }
		
		//{VLSNand.left=current} "~&"
		public Group getGroup_1_0_0_5() { return cGroup_1_0_0_5; }
		
		//{VLSNand.left=current}
		public Action getVLSNandLeftAction_1_0_0_5_0() { return cVLSNandLeftAction_1_0_0_5_0; }
		
		//"~&"
		public Keyword getTildeAmpersandKeyword_1_0_0_5_1() { return cTildeAmpersandKeyword_1_0_0_5_1; }
		
		//right=VLSUnitaryFormula
		public Assignment getRightAssignment_1_0_1() { return cRightAssignment_1_0_1; }
		
		//VLSUnitaryFormula
		public RuleCall getRightVLSUnitaryFormulaParserRuleCall_1_0_1_0() { return cRightVLSUnitaryFormulaParserRuleCall_1_0_1_0; }
		
		//({VLSAnd.left=current} '&' right=VLSUnitaryFormula)+
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//{VLSAnd.left=current}
		public Action getVLSAndLeftAction_1_1_0() { return cVLSAndLeftAction_1_1_0; }
		
		//'&'
		public Keyword getAmpersandKeyword_1_1_1() { return cAmpersandKeyword_1_1_1; }
		
		//right=VLSUnitaryFormula
		public Assignment getRightAssignment_1_1_2() { return cRightAssignment_1_1_2; }
		
		//VLSUnitaryFormula
		public RuleCall getRightVLSUnitaryFormulaParserRuleCall_1_1_2_0() { return cRightVLSUnitaryFormulaParserRuleCall_1_1_2_0; }
		
		//({VLSOr.left=current} '|' right=VLSUnitaryFormula)+
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//{VLSOr.left=current}
		public Action getVLSOrLeftAction_1_2_0() { return cVLSOrLeftAction_1_2_0; }
		
		//'|'
		public Keyword getVerticalLineKeyword_1_2_1() { return cVerticalLineKeyword_1_2_1; }
		
		//right=VLSUnitaryFormula
		public Assignment getRightAssignment_1_2_2() { return cRightAssignment_1_2_2; }
		
		//VLSUnitaryFormula
		public RuleCall getRightVLSUnitaryFormulaParserRuleCall_1_2_2_0() { return cRightVLSUnitaryFormulaParserRuleCall_1_2_2_0; }
	}
	public class VLSUnitaryFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSUnitaryFormula");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVLSUniversalQuantifierParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVLSExistentialQuantifierParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVLSUnaryNegationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cVLSUnaryInfixParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Keyword cLeftParenthesisKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final RuleCall cVLSTermParserRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_4_2 = (Keyword)cGroup_4.eContents().get(2);
		
		////VLSUnitaryFormula
		//VLSUnitaryFormula VLSTerm:
		//	VLSUniversalQuantifier | VLSExistentialQuantifier | VLSUnaryNegation | VLSUnaryInfix
		//	//| VLSEquality 
		//	| '(' VLSTerm ')';
		@Override public ParserRule getRule() { return rule; }
		
		//VLSUniversalQuantifier | VLSExistentialQuantifier | VLSUnaryNegation | VLSUnaryInfix //| VLSEquality 
		//| '(' VLSTerm ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//VLSUniversalQuantifier
		public RuleCall getVLSUniversalQuantifierParserRuleCall_0() { return cVLSUniversalQuantifierParserRuleCall_0; }
		
		//VLSExistentialQuantifier
		public RuleCall getVLSExistentialQuantifierParserRuleCall_1() { return cVLSExistentialQuantifierParserRuleCall_1; }
		
		//VLSUnaryNegation
		public RuleCall getVLSUnaryNegationParserRuleCall_2() { return cVLSUnaryNegationParserRuleCall_2; }
		
		//VLSUnaryInfix
		public RuleCall getVLSUnaryInfixParserRuleCall_3() { return cVLSUnaryInfixParserRuleCall_3; }
		
		//'(' VLSTerm ')'
		public Group getGroup_4() { return cGroup_4; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_4_0() { return cLeftParenthesisKeyword_4_0; }
		
		//VLSTerm
		public RuleCall getVLSTermParserRuleCall_4_1() { return cVLSTermParserRuleCall_4_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4_2() { return cRightParenthesisKeyword_4_2; }
	}
	public class VLSUniversalQuantifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSUniversalQuantifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVLSUniversalQuantifierAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cVariablesAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cVariablesAlternatives_1_2_0 = (Alternatives)cVariablesAssignment_1_2.eContents().get(0);
		private final RuleCall cVariablesVLSVariableParserRuleCall_1_2_0_0 = (RuleCall)cVariablesAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cVariablesVLSVariableDeclarationParserRuleCall_1_2_0_1 = (RuleCall)cVariablesAlternatives_1_2_0.eContents().get(1);
		private final Group cGroup_1_3 = (Group)cGroup_1.eContents().get(3);
		private final Keyword cCommaKeyword_1_3_0 = (Keyword)cGroup_1_3.eContents().get(0);
		private final Assignment cVariablesAssignment_1_3_1 = (Assignment)cGroup_1_3.eContents().get(1);
		private final Alternatives cVariablesAlternatives_1_3_1_0 = (Alternatives)cVariablesAssignment_1_3_1.eContents().get(0);
		private final RuleCall cVariablesVLSVariableParserRuleCall_1_3_1_0_0 = (RuleCall)cVariablesAlternatives_1_3_1_0.eContents().get(0);
		private final RuleCall cVariablesVLSVariableDeclarationParserRuleCall_1_3_1_0_1 = (RuleCall)cVariablesAlternatives_1_3_1_0.eContents().get(1);
		private final Keyword cRightSquareBracketKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Keyword cColonKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandVLSUnitaryFormulaParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		//VLSUniversalQuantifier VLSTerm:
		//	{VLSUniversalQuantifier} ("!" '[' variables+=(VLSVariable | VLSVariableDeclaration) (',' variables+=(VLSVariable |
		//	VLSVariableDeclaration))* ']' ':') operand=VLSUnitaryFormula;
		@Override public ParserRule getRule() { return rule; }
		
		//{VLSUniversalQuantifier} ("!" '[' variables+=(VLSVariable | VLSVariableDeclaration) (',' variables+=(VLSVariable |
		//VLSVariableDeclaration))* ']' ':') operand=VLSUnitaryFormula
		public Group getGroup() { return cGroup; }
		
		//{VLSUniversalQuantifier}
		public Action getVLSUniversalQuantifierAction_0() { return cVLSUniversalQuantifierAction_0; }
		
		//"!" '[' variables+=(VLSVariable | VLSVariableDeclaration) (',' variables+=(VLSVariable | VLSVariableDeclaration))* ']'
		//':'
		public Group getGroup_1() { return cGroup_1; }
		
		//"!"
		public Keyword getExclamationMarkKeyword_1_0() { return cExclamationMarkKeyword_1_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_1() { return cLeftSquareBracketKeyword_1_1; }
		
		//variables+=(VLSVariable | VLSVariableDeclaration)
		public Assignment getVariablesAssignment_1_2() { return cVariablesAssignment_1_2; }
		
		//(VLSVariable | VLSVariableDeclaration)
		public Alternatives getVariablesAlternatives_1_2_0() { return cVariablesAlternatives_1_2_0; }
		
		//VLSVariable
		public RuleCall getVariablesVLSVariableParserRuleCall_1_2_0_0() { return cVariablesVLSVariableParserRuleCall_1_2_0_0; }
		
		//VLSVariableDeclaration
		public RuleCall getVariablesVLSVariableDeclarationParserRuleCall_1_2_0_1() { return cVariablesVLSVariableDeclarationParserRuleCall_1_2_0_1; }
		
		//(',' variables+=(VLSVariable | VLSVariableDeclaration))*
		public Group getGroup_1_3() { return cGroup_1_3; }
		
		//','
		public Keyword getCommaKeyword_1_3_0() { return cCommaKeyword_1_3_0; }
		
		//variables+=(VLSVariable | VLSVariableDeclaration)
		public Assignment getVariablesAssignment_1_3_1() { return cVariablesAssignment_1_3_1; }
		
		//(VLSVariable | VLSVariableDeclaration)
		public Alternatives getVariablesAlternatives_1_3_1_0() { return cVariablesAlternatives_1_3_1_0; }
		
		//VLSVariable
		public RuleCall getVariablesVLSVariableParserRuleCall_1_3_1_0_0() { return cVariablesVLSVariableParserRuleCall_1_3_1_0_0; }
		
		//VLSVariableDeclaration
		public RuleCall getVariablesVLSVariableDeclarationParserRuleCall_1_3_1_0_1() { return cVariablesVLSVariableDeclarationParserRuleCall_1_3_1_0_1; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_4() { return cRightSquareBracketKeyword_1_4; }
		
		//':'
		public Keyword getColonKeyword_1_5() { return cColonKeyword_1_5; }
		
		//operand=VLSUnitaryFormula
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//VLSUnitaryFormula
		public RuleCall getOperandVLSUnitaryFormulaParserRuleCall_2_0() { return cOperandVLSUnitaryFormulaParserRuleCall_2_0; }
	}
	public class VLSExistentialQuantifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSExistentialQuantifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVLSExistentialQuantifierAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cQuestionMarkKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cVariablesAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cVariablesAlternatives_1_2_0 = (Alternatives)cVariablesAssignment_1_2.eContents().get(0);
		private final RuleCall cVariablesVLSVariableParserRuleCall_1_2_0_0 = (RuleCall)cVariablesAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cVariablesVLSVariableDeclarationParserRuleCall_1_2_0_1 = (RuleCall)cVariablesAlternatives_1_2_0.eContents().get(1);
		private final Group cGroup_1_3 = (Group)cGroup_1.eContents().get(3);
		private final Keyword cCommaKeyword_1_3_0 = (Keyword)cGroup_1_3.eContents().get(0);
		private final Assignment cVariablesAssignment_1_3_1 = (Assignment)cGroup_1_3.eContents().get(1);
		private final Alternatives cVariablesAlternatives_1_3_1_0 = (Alternatives)cVariablesAssignment_1_3_1.eContents().get(0);
		private final RuleCall cVariablesVLSVariableParserRuleCall_1_3_1_0_0 = (RuleCall)cVariablesAlternatives_1_3_1_0.eContents().get(0);
		private final RuleCall cVariablesVLSVariableDeclarationParserRuleCall_1_3_1_0_1 = (RuleCall)cVariablesAlternatives_1_3_1_0.eContents().get(1);
		private final Keyword cRightSquareBracketKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Keyword cColonKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandVLSUnitaryFormulaParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		//VLSExistentialQuantifier VLSTerm:
		//	{VLSExistentialQuantifier} ("?" '[' variables+=(VLSVariable | VLSVariableDeclaration) (',' variables+=(VLSVariable |
		//	VLSVariableDeclaration))* ']' ':') operand=VLSUnitaryFormula;
		@Override public ParserRule getRule() { return rule; }
		
		//{VLSExistentialQuantifier} ("?" '[' variables+=(VLSVariable | VLSVariableDeclaration) (',' variables+=(VLSVariable |
		//VLSVariableDeclaration))* ']' ':') operand=VLSUnitaryFormula
		public Group getGroup() { return cGroup; }
		
		//{VLSExistentialQuantifier}
		public Action getVLSExistentialQuantifierAction_0() { return cVLSExistentialQuantifierAction_0; }
		
		//"?" '[' variables+=(VLSVariable | VLSVariableDeclaration) (',' variables+=(VLSVariable | VLSVariableDeclaration))* ']'
		//':'
		public Group getGroup_1() { return cGroup_1; }
		
		//"?"
		public Keyword getQuestionMarkKeyword_1_0() { return cQuestionMarkKeyword_1_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_1() { return cLeftSquareBracketKeyword_1_1; }
		
		//variables+=(VLSVariable | VLSVariableDeclaration)
		public Assignment getVariablesAssignment_1_2() { return cVariablesAssignment_1_2; }
		
		//(VLSVariable | VLSVariableDeclaration)
		public Alternatives getVariablesAlternatives_1_2_0() { return cVariablesAlternatives_1_2_0; }
		
		//VLSVariable
		public RuleCall getVariablesVLSVariableParserRuleCall_1_2_0_0() { return cVariablesVLSVariableParserRuleCall_1_2_0_0; }
		
		//VLSVariableDeclaration
		public RuleCall getVariablesVLSVariableDeclarationParserRuleCall_1_2_0_1() { return cVariablesVLSVariableDeclarationParserRuleCall_1_2_0_1; }
		
		//(',' variables+=(VLSVariable | VLSVariableDeclaration))*
		public Group getGroup_1_3() { return cGroup_1_3; }
		
		//','
		public Keyword getCommaKeyword_1_3_0() { return cCommaKeyword_1_3_0; }
		
		//variables+=(VLSVariable | VLSVariableDeclaration)
		public Assignment getVariablesAssignment_1_3_1() { return cVariablesAssignment_1_3_1; }
		
		//(VLSVariable | VLSVariableDeclaration)
		public Alternatives getVariablesAlternatives_1_3_1_0() { return cVariablesAlternatives_1_3_1_0; }
		
		//VLSVariable
		public RuleCall getVariablesVLSVariableParserRuleCall_1_3_1_0_0() { return cVariablesVLSVariableParserRuleCall_1_3_1_0_0; }
		
		//VLSVariableDeclaration
		public RuleCall getVariablesVLSVariableDeclarationParserRuleCall_1_3_1_0_1() { return cVariablesVLSVariableDeclarationParserRuleCall_1_3_1_0_1; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_4() { return cRightSquareBracketKeyword_1_4; }
		
		//':'
		public Keyword getColonKeyword_1_5() { return cColonKeyword_1_5; }
		
		//operand=VLSUnitaryFormula
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//VLSUnitaryFormula
		public RuleCall getOperandVLSUnitaryFormulaParserRuleCall_2_0() { return cOperandVLSUnitaryFormulaParserRuleCall_2_0; }
	}
	public class VLSUnaryNegationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSUnaryNegation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVLSUnaryNegationAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTildeKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandVLSUnitaryFormulaParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		//VLSUnaryNegation VLSTerm:
		//	{VLSUnaryNegation} '~' operand=VLSUnitaryFormula;
		@Override public ParserRule getRule() { return rule; }
		
		//{VLSUnaryNegation} '~' operand=VLSUnitaryFormula
		public Group getGroup() { return cGroup; }
		
		//{VLSUnaryNegation}
		public Action getVLSUnaryNegationAction_0() { return cVLSUnaryNegationAction_0; }
		
		//'~'
		public Keyword getTildeKeyword_1() { return cTildeKeyword_1; }
		
		//operand=VLSUnitaryFormula
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//VLSUnitaryFormula
		public RuleCall getOperandVLSUnitaryFormulaParserRuleCall_2_0() { return cOperandVLSUnitaryFormulaParserRuleCall_2_0; }
	}
	public class VLSUnaryInfixElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSUnaryInfix");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cVLSAtomicParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cVLSInequalityLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cExclamationMarkEqualsSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cVLSEqualityLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Group cGroup_1_0_2 = (Group)cAlternatives_1_0.eContents().get(2);
		private final Action cVLSAssignmentLeftAction_1_0_2_0 = (Action)cGroup_1_0_2.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_1_0_2_1 = (Keyword)cGroup_1_0_2.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightVLSAtomicParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//VLSUnaryInfix VLSTerm:
		//	VLSAtomic (({VLSInequality.left=current} "!=" | {VLSEquality.left=current} "=" | {VLSAssignment.left=current} ":=")
		//	right=VLSAtomic)?;
		@Override public ParserRule getRule() { return rule; }
		
		//VLSAtomic (({VLSInequality.left=current} "!=" | {VLSEquality.left=current} "=" | {VLSAssignment.left=current} ":=")
		//right=VLSAtomic)?
		public Group getGroup() { return cGroup; }
		
		//VLSAtomic
		public RuleCall getVLSAtomicParserRuleCall_0() { return cVLSAtomicParserRuleCall_0; }
		
		//(({VLSInequality.left=current} "!=" | {VLSEquality.left=current} "=" | {VLSAssignment.left=current} ":=")
		//right=VLSAtomic)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{VLSInequality.left=current} "!=" | {VLSEquality.left=current} "=" | {VLSAssignment.left=current} ":="
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//{VLSInequality.left=current} "!="
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{VLSInequality.left=current}
		public Action getVLSInequalityLeftAction_1_0_0_0() { return cVLSInequalityLeftAction_1_0_0_0; }
		
		//"!="
		public Keyword getExclamationMarkEqualsSignKeyword_1_0_0_1() { return cExclamationMarkEqualsSignKeyword_1_0_0_1; }
		
		//{VLSEquality.left=current} "="
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }
		
		//{VLSEquality.left=current}
		public Action getVLSEqualityLeftAction_1_0_1_0() { return cVLSEqualityLeftAction_1_0_1_0; }
		
		//"="
		public Keyword getEqualsSignKeyword_1_0_1_1() { return cEqualsSignKeyword_1_0_1_1; }
		
		//{VLSAssignment.left=current} ":="
		public Group getGroup_1_0_2() { return cGroup_1_0_2; }
		
		//{VLSAssignment.left=current}
		public Action getVLSAssignmentLeftAction_1_0_2_0() { return cVLSAssignmentLeftAction_1_0_2_0; }
		
		//":="
		public Keyword getColonEqualsSignKeyword_1_0_2_1() { return cColonEqualsSignKeyword_1_0_2_1; }
		
		//right=VLSAtomic
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//VLSAtomic
		public RuleCall getRightVLSAtomicParserRuleCall_1_1_0() { return cRightVLSAtomicParserRuleCall_1_1_0; }
	}
	public class VLSAtomicElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSAtomic");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVLSAtomicConstantParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVLSAtomicFunctionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVLSVariableParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cVLSDefinedTermParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		////NOT SUREEEE
		////VLSEquality returns VLSTerm:
		////	VLSFofTerm ({VLSEquality.left = current} "=" right = VLSFofTerm)?
		////	
		////;
		///*
		//enum VLSDefinedFunctor:
		//		UMINUS='$uminus' | SUM='$sum' | DIFFERENCE='$difference' | PRODUCT='$product' | QUOTIENT='$quotient' | 
		//		QUOTIENT_E='$quotient_e' | QUOTIENT_T='$quotient_t' | QUOTIENT_F='$quotient_f' | REMAINDER_E='$remainder_e' |
		//		 REMAINDER_T='$remainder_t' | REMAINDER_F='$remainder_f' | FLOOR='$floor' | CEILING='$ceiling' |
		//		 TRUNCATE='$truncate' | ROUND='$round' | TO_INT='$to_int' | TO_RAT='$to_rat' | TO_REAL='$to_real'
		//    ;
		//*/ VLSAtomic VLSTerm:
		//	VLSAtomicConstant | VLSAtomicFunction | VLSVariable
		//	| VLSDefinedTerm //temporary solution. this is only valid for equality, not for != or :=
		//	//| VLSEquality
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//VLSAtomicConstant | VLSAtomicFunction | VLSVariable | VLSDefinedTerm
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//VLSAtomicConstant
		public RuleCall getVLSAtomicConstantParserRuleCall_0() { return cVLSAtomicConstantParserRuleCall_0; }
		
		//VLSAtomicFunction
		public RuleCall getVLSAtomicFunctionParserRuleCall_1() { return cVLSAtomicFunctionParserRuleCall_1; }
		
		//VLSVariable
		public RuleCall getVLSVariableParserRuleCall_2() { return cVLSVariableParserRuleCall_2; }
		
		//VLSDefinedTerm
		public RuleCall getVLSDefinedTermParserRuleCall_3() { return cVLSDefinedTermParserRuleCall_3; }
	}
	public class VLSAtomicConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSAtomicConstant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cVLSConstantAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cNameAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final Alternatives cNameAlternatives_0_1_0 = (Alternatives)cNameAssignment_0_1.eContents().get(0);
		private final RuleCall cNameLOWER_WORD_IDTerminalRuleCall_0_1_0_0 = (RuleCall)cNameAlternatives_0_1_0.eContents().get(0);
		private final RuleCall cNameSINGLE_QUOTETerminalRuleCall_0_1_0_1 = (RuleCall)cNameAlternatives_0_1_0.eContents().get(1);
		private final RuleCall cNameDOLLAR_IDTerminalRuleCall_0_1_0_2 = (RuleCall)cNameAlternatives_0_1_0.eContents().get(2);
		private final RuleCall cNameDOUBLE_DOLLAR_IDTerminalRuleCall_0_1_0_3 = (RuleCall)cNameAlternatives_0_1_0.eContents().get(3);
		private final RuleCall cNameVLSRoleParserRuleCall_0_1_0_4 = (RuleCall)cNameAlternatives_0_1_0.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cVLSTrueAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cTrueKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cVLSFalseAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Keyword cFalseKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		
		//VLSAtomicConstant VLSTerm:
		//	{VLSConstant} name=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID | VLSRole) | {VLSTrue} '$true' |
		//	{VLSFalse} '$false';
		@Override public ParserRule getRule() { return rule; }
		
		//{VLSConstant} name=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID | VLSRole) | {VLSTrue} '$true' |
		//{VLSFalse} '$false'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{VLSConstant} name=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID | VLSRole)
		public Group getGroup_0() { return cGroup_0; }
		
		//{VLSConstant}
		public Action getVLSConstantAction_0_0() { return cVLSConstantAction_0_0; }
		
		//name=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID | VLSRole)
		public Assignment getNameAssignment_0_1() { return cNameAssignment_0_1; }
		
		//(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID | VLSRole)
		public Alternatives getNameAlternatives_0_1_0() { return cNameAlternatives_0_1_0; }
		
		//LOWER_WORD_ID
		public RuleCall getNameLOWER_WORD_IDTerminalRuleCall_0_1_0_0() { return cNameLOWER_WORD_IDTerminalRuleCall_0_1_0_0; }
		
		//SINGLE_QUOTE
		public RuleCall getNameSINGLE_QUOTETerminalRuleCall_0_1_0_1() { return cNameSINGLE_QUOTETerminalRuleCall_0_1_0_1; }
		
		//DOLLAR_ID
		public RuleCall getNameDOLLAR_IDTerminalRuleCall_0_1_0_2() { return cNameDOLLAR_IDTerminalRuleCall_0_1_0_2; }
		
		//DOUBLE_DOLLAR_ID
		public RuleCall getNameDOUBLE_DOLLAR_IDTerminalRuleCall_0_1_0_3() { return cNameDOUBLE_DOLLAR_IDTerminalRuleCall_0_1_0_3; }
		
		//VLSRole
		public RuleCall getNameVLSRoleParserRuleCall_0_1_0_4() { return cNameVLSRoleParserRuleCall_0_1_0_4; }
		
		//{VLSTrue} '$true'
		public Group getGroup_1() { return cGroup_1; }
		
		//{VLSTrue}
		public Action getVLSTrueAction_1_0() { return cVLSTrueAction_1_0; }
		
		//'$true'
		public Keyword getTrueKeyword_1_1() { return cTrueKeyword_1_1; }
		
		//{VLSFalse} '$false'
		public Group getGroup_2() { return cGroup_2; }
		
		//{VLSFalse}
		public Action getVLSFalseAction_2_0() { return cVLSFalseAction_2_0; }
		
		//'$false'
		public Keyword getFalseKeyword_2_1() { return cFalseKeyword_2_1; }
	}
	public class VLSAtomicFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSAtomicFunction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cVLSFunctionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cConstantAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final Alternatives cConstantAlternatives_0_1_0 = (Alternatives)cConstantAssignment_0_1.eContents().get(0);
		private final RuleCall cConstantLOWER_WORD_IDTerminalRuleCall_0_1_0_0 = (RuleCall)cConstantAlternatives_0_1_0.eContents().get(0);
		private final RuleCall cConstantSINGLE_QUOTETerminalRuleCall_0_1_0_1 = (RuleCall)cConstantAlternatives_0_1_0.eContents().get(1);
		private final RuleCall cConstantDOLLAR_IDTerminalRuleCall_0_1_0_2 = (RuleCall)cConstantAlternatives_0_1_0.eContents().get(2);
		private final RuleCall cConstantDOUBLE_DOLLAR_IDTerminalRuleCall_0_1_0_3 = (RuleCall)cConstantAlternatives_0_1_0.eContents().get(3);
		private final RuleCall cConstantVLSRoleParserRuleCall_0_1_0_4 = (RuleCall)cConstantAlternatives_0_1_0.eContents().get(4);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final Assignment cTermsAssignment_0_2_1 = (Assignment)cGroup_0_2.eContents().get(1);
		private final RuleCall cTermsVLSFofTermParserRuleCall_0_2_1_0 = (RuleCall)cTermsAssignment_0_2_1.eContents().get(0);
		private final Group cGroup_0_2_2 = (Group)cGroup_0_2.eContents().get(2);
		private final Keyword cCommaKeyword_0_2_2_0 = (Keyword)cGroup_0_2_2.eContents().get(0);
		private final Assignment cTermsAssignment_0_2_2_1 = (Assignment)cGroup_0_2_2.eContents().get(1);
		private final RuleCall cTermsVLSFofTermParserRuleCall_0_2_2_1_0 = (RuleCall)cTermsAssignment_0_2_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_2_3 = (Keyword)cGroup_0_2.eContents().get(3);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cVLSLessAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cNameLessKeyword_1_1_0 = (Keyword)cNameAssignment_1_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cTermsAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cTermsVLSFofTermParserRuleCall_1_3_0 = (RuleCall)cTermsAssignment_1_3.eContents().get(0);
		private final Keyword cCommaKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Assignment cTermsAssignment_1_5 = (Assignment)cGroup_1.eContents().get(5);
		private final RuleCall cTermsVLSFofTermParserRuleCall_1_5_0 = (RuleCall)cTermsAssignment_1_5.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_6 = (Keyword)cGroup_1.eContents().get(6);
		
		//VLSAtomicFunction VLSTerm:
		//	{VLSFunction} constant=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID | VLSRole) ('(' terms+=VLSFofTerm
		//	(',' terms+=VLSFofTerm)* ')') | {VLSLess} name='$less' '(' terms+=VLSFofTerm ',' terms+=VLSFofTerm ')';
		@Override public ParserRule getRule() { return rule; }
		
		//{VLSFunction} constant=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID | VLSRole) ('(' terms+=VLSFofTerm
		//(',' terms+=VLSFofTerm)* ')') | {VLSLess} name='$less' '(' terms+=VLSFofTerm ',' terms+=VLSFofTerm ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{VLSFunction} constant=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID | VLSRole) ('(' terms+=VLSFofTerm
		//(',' terms+=VLSFofTerm)* ')')
		public Group getGroup_0() { return cGroup_0; }
		
		//{VLSFunction}
		public Action getVLSFunctionAction_0_0() { return cVLSFunctionAction_0_0; }
		
		//constant=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID | VLSRole)
		public Assignment getConstantAssignment_0_1() { return cConstantAssignment_0_1; }
		
		//(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID | VLSRole)
		public Alternatives getConstantAlternatives_0_1_0() { return cConstantAlternatives_0_1_0; }
		
		//LOWER_WORD_ID
		public RuleCall getConstantLOWER_WORD_IDTerminalRuleCall_0_1_0_0() { return cConstantLOWER_WORD_IDTerminalRuleCall_0_1_0_0; }
		
		//SINGLE_QUOTE
		public RuleCall getConstantSINGLE_QUOTETerminalRuleCall_0_1_0_1() { return cConstantSINGLE_QUOTETerminalRuleCall_0_1_0_1; }
		
		//DOLLAR_ID
		public RuleCall getConstantDOLLAR_IDTerminalRuleCall_0_1_0_2() { return cConstantDOLLAR_IDTerminalRuleCall_0_1_0_2; }
		
		//DOUBLE_DOLLAR_ID
		public RuleCall getConstantDOUBLE_DOLLAR_IDTerminalRuleCall_0_1_0_3() { return cConstantDOUBLE_DOLLAR_IDTerminalRuleCall_0_1_0_3; }
		
		//VLSRole
		public RuleCall getConstantVLSRoleParserRuleCall_0_1_0_4() { return cConstantVLSRoleParserRuleCall_0_1_0_4; }
		
		//'(' terms+=VLSFofTerm (',' terms+=VLSFofTerm)* ')'
		public Group getGroup_0_2() { return cGroup_0_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_2_0() { return cLeftParenthesisKeyword_0_2_0; }
		
		//terms+=VLSFofTerm
		public Assignment getTermsAssignment_0_2_1() { return cTermsAssignment_0_2_1; }
		
		//VLSFofTerm
		public RuleCall getTermsVLSFofTermParserRuleCall_0_2_1_0() { return cTermsVLSFofTermParserRuleCall_0_2_1_0; }
		
		//(',' terms+=VLSFofTerm)*
		public Group getGroup_0_2_2() { return cGroup_0_2_2; }
		
		//','
		public Keyword getCommaKeyword_0_2_2_0() { return cCommaKeyword_0_2_2_0; }
		
		//terms+=VLSFofTerm
		public Assignment getTermsAssignment_0_2_2_1() { return cTermsAssignment_0_2_2_1; }
		
		//VLSFofTerm
		public RuleCall getTermsVLSFofTermParserRuleCall_0_2_2_1_0() { return cTermsVLSFofTermParserRuleCall_0_2_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2_3() { return cRightParenthesisKeyword_0_2_3; }
		
		//{VLSLess} name='$less' '(' terms+=VLSFofTerm ',' terms+=VLSFofTerm ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//{VLSLess}
		public Action getVLSLessAction_1_0() { return cVLSLessAction_1_0; }
		
		//name='$less'
		public Assignment getNameAssignment_1_1() { return cNameAssignment_1_1; }
		
		//'$less'
		public Keyword getNameLessKeyword_1_1_0() { return cNameLessKeyword_1_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_2() { return cLeftParenthesisKeyword_1_2; }
		
		//terms+=VLSFofTerm
		public Assignment getTermsAssignment_1_3() { return cTermsAssignment_1_3; }
		
		//VLSFofTerm
		public RuleCall getTermsVLSFofTermParserRuleCall_1_3_0() { return cTermsVLSFofTermParserRuleCall_1_3_0; }
		
		//','
		public Keyword getCommaKeyword_1_4() { return cCommaKeyword_1_4; }
		
		//terms+=VLSFofTerm
		public Assignment getTermsAssignment_1_5() { return cTermsAssignment_1_5; }
		
		//VLSFofTerm
		public RuleCall getTermsVLSFofTermParserRuleCall_1_5_0() { return cTermsVLSFofTermParserRuleCall_1_5_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_6() { return cRightParenthesisKeyword_1_6; }
	}
	public class VLSVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSVariable");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameUPPER_WORD_IDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//VLSVariable:
		//	name=UPPER_WORD_ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=UPPER_WORD_ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//UPPER_WORD_ID
		public RuleCall getNameUPPER_WORD_IDTerminalRuleCall_0() { return cNameUPPER_WORD_IDTerminalRuleCall_0; }
	}
	public class VLSFofTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSFofTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVLSVariableParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVLSFunctionAsTermParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVLSDefinedTermParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//VLSFofTerm VLSTerm:
		//	VLSVariable | VLSFunctionAsTerm | VLSDefinedTerm;
		@Override public ParserRule getRule() { return rule; }
		
		////(VLSVariable | VLSFunction | VLSTffConditional | VLSTffLet | VLSTffTuple)
		//VLSVariable | VLSFunctionAsTerm | VLSDefinedTerm
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//VLSVariable
		public RuleCall getVLSVariableParserRuleCall_0() { return cVLSVariableParserRuleCall_0; }
		
		//VLSFunctionAsTerm
		public RuleCall getVLSFunctionAsTermParserRuleCall_1() { return cVLSFunctionAsTermParserRuleCall_1; }
		
		//VLSDefinedTerm
		public RuleCall getVLSDefinedTermParserRuleCall_2() { return cVLSDefinedTermParserRuleCall_2; }
	}
	public class VLSFunctionAsTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSFunctionAsTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFunctorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cFunctorAlternatives_0_0 = (Alternatives)cFunctorAssignment_0.eContents().get(0);
		private final RuleCall cFunctorLOWER_WORD_IDTerminalRuleCall_0_0_0 = (RuleCall)cFunctorAlternatives_0_0.eContents().get(0);
		private final RuleCall cFunctorSINGLE_QUOTETerminalRuleCall_0_0_1 = (RuleCall)cFunctorAlternatives_0_0.eContents().get(1);
		private final RuleCall cFunctorDOLLAR_IDTerminalRuleCall_0_0_2 = (RuleCall)cFunctorAlternatives_0_0.eContents().get(2);
		private final RuleCall cFunctorDOUBLE_DOLLAR_IDTerminalRuleCall_0_0_3 = (RuleCall)cFunctorAlternatives_0_0.eContents().get(3);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTermsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTermsVLSFofTermParserRuleCall_1_1_0 = (RuleCall)cTermsAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cCommaKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cTermsAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cTermsVLSFofTermParserRuleCall_1_2_1_0 = (RuleCall)cTermsAssignment_1_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//VLSFunctionAsTerm:
		//	functor=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID) ('(' terms+=VLSFofTerm (',' terms+=VLSFofTerm)*
		//	')')?;
		@Override public ParserRule getRule() { return rule; }
		
		////? on next line causes warning
		////TODO might need replace DOLLAR_ID with enum rule 
		//functor=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID) ('(' terms+=VLSFofTerm (',' terms+=VLSFofTerm)*
		//')')?
		public Group getGroup() { return cGroup; }
		
		////? on next line causes warning
		////TODO might need replace DOLLAR_ID with enum rule 
		//functor=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID)
		public Assignment getFunctorAssignment_0() { return cFunctorAssignment_0; }
		
		//(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID)
		public Alternatives getFunctorAlternatives_0_0() { return cFunctorAlternatives_0_0; }
		
		//LOWER_WORD_ID
		public RuleCall getFunctorLOWER_WORD_IDTerminalRuleCall_0_0_0() { return cFunctorLOWER_WORD_IDTerminalRuleCall_0_0_0; }
		
		//SINGLE_QUOTE
		public RuleCall getFunctorSINGLE_QUOTETerminalRuleCall_0_0_1() { return cFunctorSINGLE_QUOTETerminalRuleCall_0_0_1; }
		
		//DOLLAR_ID
		public RuleCall getFunctorDOLLAR_IDTerminalRuleCall_0_0_2() { return cFunctorDOLLAR_IDTerminalRuleCall_0_0_2; }
		
		//DOUBLE_DOLLAR_ID
		public RuleCall getFunctorDOUBLE_DOLLAR_IDTerminalRuleCall_0_0_3() { return cFunctorDOUBLE_DOLLAR_IDTerminalRuleCall_0_0_3; }
		
		//('(' terms+=VLSFofTerm (',' terms+=VLSFofTerm)* ')')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//terms+=VLSFofTerm
		public Assignment getTermsAssignment_1_1() { return cTermsAssignment_1_1; }
		
		//VLSFofTerm
		public RuleCall getTermsVLSFofTermParserRuleCall_1_1_0() { return cTermsVLSFofTermParserRuleCall_1_1_0; }
		
		//(',' terms+=VLSFofTerm)*
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//','
		public Keyword getCommaKeyword_1_2_0() { return cCommaKeyword_1_2_0; }
		
		//terms+=VLSFofTerm
		public Assignment getTermsAssignment_1_2_1() { return cTermsAssignment_1_2_1; }
		
		//VLSFofTerm
		public RuleCall getTermsVLSFofTermParserRuleCall_1_2_1_0() { return cTermsVLSFofTermParserRuleCall_1_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}
	public class VLSDefinedTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSDefinedTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cVLSIntAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cValueAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cValueSIGNED_LITERALTerminalRuleCall_0_1_0 = (RuleCall)cValueAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cVLSDoubleQuoteAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueDOUBLE_QUOTETerminalRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		
		//VLSDefinedTerm:
		//	{VLSInt} value=SIGNED_LITERAL | {VLSDoubleQuote} value=DOUBLE_QUOTE;
		@Override public ParserRule getRule() { return rule; }
		
		//{VLSInt} value=SIGNED_LITERAL | {VLSDoubleQuote} value=DOUBLE_QUOTE
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{VLSInt} value=SIGNED_LITERAL
		public Group getGroup_0() { return cGroup_0; }
		
		//{VLSInt}
		public Action getVLSIntAction_0_0() { return cVLSIntAction_0_0; }
		
		//value=SIGNED_LITERAL
		public Assignment getValueAssignment_0_1() { return cValueAssignment_0_1; }
		
		//SIGNED_LITERAL
		public RuleCall getValueSIGNED_LITERALTerminalRuleCall_0_1_0() { return cValueSIGNED_LITERALTerminalRuleCall_0_1_0; }
		
		//{VLSDoubleQuote} value=DOUBLE_QUOTE
		public Group getGroup_1() { return cGroup_1; }
		
		//{VLSDoubleQuote}
		public Action getVLSDoubleQuoteAction_1_0() { return cVLSDoubleQuoteAction_1_0; }
		
		//value=DOUBLE_QUOTE
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }
		
		//DOUBLE_QUOTE
		public RuleCall getValueDOUBLE_QUOTETerminalRuleCall_1_1_0() { return cValueDOUBLE_QUOTETerminalRuleCall_1_1_0; }
	}
	
	
	private final VampireModelElements pVampireModel;
	private final TerminalRule tALPHA_NUMERIC;
	private final TerminalRule tUPPER_WORD_ID;
	private final TerminalRule tLOWER_WORD_ID;
	private final TerminalRule tDOUBLE_QUOTE;
	private final TerminalRule tSINGLE_QUOTE;
	private final TerminalRule tSIGN;
	private final TerminalRule tDOLLAR_ID;
	private final TerminalRule tDOUBLE_DOLLAR_ID;
	private final TerminalRule tLITERAL;
	private final TerminalRule tSIGNED_LITERAL;
	private final TerminalRule tSINGLE_COMMENT;
	private final VLSCommentElements pVLSComment;
	private final VLSConfirmationsElements pVLSConfirmations;
	private final VLSFofFormulaElements pVLSFofFormula;
	private final VLSTffFormulaElements pVLSTffFormula;
	private final VLSTffNameElements pVLSTffName;
	private final VLSTffDistinctElements pVLSTffDistinct;
	private final VLSTffFiniteElements pVLSTffFinite;
	private final VLSTffDeclPredElements pVLSTffDeclPred;
	private final VLSRoleElements pVLSRole;
	private final VLSAnnotationElements pVLSAnnotation;
	private final VLSAnnotationTermsElements pVLSAnnotationTerms;
	private final VLSTffTermElements pVLSTffTerm;
	private final VLSCommentTermElements pVLSCommentTerm;
	private final VLSDeclarationElements pVLSDeclaration;
	private final VLSOtherDeclarationElements pVLSOtherDeclaration;
	private final VLSVariableDeclarationElements pVLSVariableDeclaration;
	private final VLSTypeDefElements pVLSTypeDef;
	private final VLSUnitaryTermElements pVLSUnitaryTerm;
	private final VLSTermElements pVLSTerm;
	private final VLSBinaryElements pVLSBinary;
	private final VLSUnitaryFormulaElements pVLSUnitaryFormula;
	private final VLSUniversalQuantifierElements pVLSUniversalQuantifier;
	private final VLSExistentialQuantifierElements pVLSExistentialQuantifier;
	private final VLSUnaryNegationElements pVLSUnaryNegation;
	private final VLSUnaryInfixElements pVLSUnaryInfix;
	private final VLSAtomicElements pVLSAtomic;
	private final VLSAtomicConstantElements pVLSAtomicConstant;
	private final VLSAtomicFunctionElements pVLSAtomicFunction;
	private final VLSVariableElements pVLSVariable;
	private final VLSFofTermElements pVLSFofTerm;
	private final VLSFunctionAsTermElements pVLSFunctionAsTerm;
	private final VLSDefinedTermElements pVLSDefinedTerm;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public VampireLanguageGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pVampireModel = new VampireModelElements();
		this.tALPHA_NUMERIC = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.ALPHA_NUMERIC");
		this.tUPPER_WORD_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.UPPER_WORD_ID");
		this.tLOWER_WORD_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.LOWER_WORD_ID");
		this.tDOUBLE_QUOTE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.DOUBLE_QUOTE");
		this.tSINGLE_QUOTE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.SINGLE_QUOTE");
		this.tSIGN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.SIGN");
		this.tDOLLAR_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.DOLLAR_ID");
		this.tDOUBLE_DOLLAR_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.DOUBLE_DOLLAR_ID");
		this.tLITERAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.LITERAL");
		this.tSIGNED_LITERAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.SIGNED_LITERAL");
		this.tSINGLE_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.SINGLE_COMMENT");
		this.pVLSComment = new VLSCommentElements();
		this.pVLSConfirmations = new VLSConfirmationsElements();
		this.pVLSFofFormula = new VLSFofFormulaElements();
		this.pVLSTffFormula = new VLSTffFormulaElements();
		this.pVLSTffName = new VLSTffNameElements();
		this.pVLSTffDistinct = new VLSTffDistinctElements();
		this.pVLSTffFinite = new VLSTffFiniteElements();
		this.pVLSTffDeclPred = new VLSTffDeclPredElements();
		this.pVLSRole = new VLSRoleElements();
		this.pVLSAnnotation = new VLSAnnotationElements();
		this.pVLSAnnotationTerms = new VLSAnnotationTermsElements();
		this.pVLSTffTerm = new VLSTffTermElements();
		this.pVLSCommentTerm = new VLSCommentTermElements();
		this.pVLSDeclaration = new VLSDeclarationElements();
		this.pVLSOtherDeclaration = new VLSOtherDeclarationElements();
		this.pVLSVariableDeclaration = new VLSVariableDeclarationElements();
		this.pVLSTypeDef = new VLSTypeDefElements();
		this.pVLSUnitaryTerm = new VLSUnitaryTermElements();
		this.pVLSTerm = new VLSTermElements();
		this.pVLSBinary = new VLSBinaryElements();
		this.pVLSUnitaryFormula = new VLSUnitaryFormulaElements();
		this.pVLSUniversalQuantifier = new VLSUniversalQuantifierElements();
		this.pVLSExistentialQuantifier = new VLSExistentialQuantifierElements();
		this.pVLSUnaryNegation = new VLSUnaryNegationElements();
		this.pVLSUnaryInfix = new VLSUnaryInfixElements();
		this.pVLSAtomic = new VLSAtomicElements();
		this.pVLSAtomicConstant = new VLSAtomicConstantElements();
		this.pVLSAtomicFunction = new VLSAtomicFunctionElements();
		this.pVLSVariable = new VLSVariableElements();
		this.pVLSFofTerm = new VLSFofTermElements();
		this.pVLSFunctionAsTerm = new VLSFunctionAsTermElements();
		this.pVLSDefinedTerm = new VLSDefinedTermElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("ca.mcgill.ecse.dslreasoner.VampireLanguage".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	////@@@@@@@@@@@
	////2 things TODO:
	////1. fix anotations (ln77)
	////2. can only use declared variables in formula (ln 158)
	////@@@@@@@@@@@
	//VampireModel:
	//	(comments+=VLSComment | confirmations+=VLSConfirmations | formulas+=VLSFofFormula | tfformulas+=VLSTffFormula)*;
	public VampireModelElements getVampireModelAccess() {
		return pVampireModel;
	}
	
	public ParserRule getVampireModelRule() {
		return getVampireModelAccess().getRule();
	}
	
	//terminal ALPHA_NUMERIC:
	//	'a'..'z' | 'A'..'Z' | '0'..'9' | '_';
	public TerminalRule getALPHA_NUMERICRule() {
		return tALPHA_NUMERIC;
	}
	
	//terminal UPPER_WORD_ID:
	//	'A'..'Z' ALPHA_NUMERIC*;
	public TerminalRule getUPPER_WORD_IDRule() {
		return tUPPER_WORD_ID;
	}
	
	//terminal LOWER_WORD_ID:
	//	'a'..'z' ALPHA_NUMERIC*;
	public TerminalRule getLOWER_WORD_IDRule() {
		return tLOWER_WORD_ID;
	}
	
	//terminal DOUBLE_QUOTE:
	//	'"' ('\\' ('"' | '\\') | !('\\' | '"'))* '"';
	public TerminalRule getDOUBLE_QUOTERule() {
		return tDOUBLE_QUOTE;
	}
	
	//terminal SINGLE_QUOTE:
	//	"'" ('\\' ("'" | '\\') | !('\\' | "'"))+ "'";
	public TerminalRule getSINGLE_QUOTERule() {
		return tSINGLE_QUOTE;
	}
	
	//terminal SIGN:
	//	'+' | '-';
	public TerminalRule getSIGNRule() {
		return tSIGN;
	}
	
	//terminal DOLLAR_ID:
	//	'$' LOWER_WORD_ID;
	public TerminalRule getDOLLAR_IDRule() {
		return tDOLLAR_ID;
	}
	
	//terminal DOUBLE_DOLLAR_ID:
	//	'$$' LOWER_WORD_ID;
	public TerminalRule getDOUBLE_DOLLAR_IDRule() {
		return tDOUBLE_DOLLAR_ID;
	}
	
	//terminal LITERAL:
	//	'0' | '1'..'9' INT?;
	public TerminalRule getLITERALRule() {
		return tLITERAL;
	}
	
	//terminal SIGNED_LITERAL:
	//	SIGN* LITERAL;
	public TerminalRule getSIGNED_LITERALRule() {
		return tSIGNED_LITERAL;
	}
	
	//terminal SINGLE_COMMENT:
	//	'%' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSINGLE_COMMENTRule() {
		return tSINGLE_COMMENT;
	}
	
	////terminal ID:  ( !('('|')'|'\r'|'\n') )+ ;
	////////////////////////////////////
	//// VLS types
	////////////////////////////////////
	//// <includes>
	////VLSInclude:
	////	'include(' fileName = SINGLE_QUOTE ( ',[' names += VLSName (','  names += VLSName)* ']' )?
	////;
	////VLSName:
	////	name = (LOWER_WORD_ID | SINGLE_QUOTE | LITERAL | SIGNED_LITERAL)
	////;
	//// <comments>
	//VLSComment:
	//	comment=SINGLE_COMMENT
	//	//need to add a new line at the end of the file for the case where the last line is a comment
	//;
	public VLSCommentElements getVLSCommentAccess() {
		return pVLSComment;
	}
	
	public ParserRule getVLSCommentRule() {
		return getVLSCommentAccess().getRule();
	}
	
	////VLSConstantDeclaration: name = (LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID );
	//VLSConfirmations:
	//	{VLSSatisfiable} 'Satisfiable!' | {VLSWarning} "WARNING!" "Could" "not" "set" "resource" "limit:" "Virtual" "memory."
	//	| {VLSTrying} 'TRYING' '[' name=LITERAL ']' | {VLSFiniteModel} 'Finite' 'Model' 'Found!';
	public VLSConfirmationsElements getVLSConfirmationsAccess() {
		return pVLSConfirmations;
	}
	
	public ParserRule getVLSConfirmationsRule() {
		return getVLSConfirmationsAccess().getRule();
	}
	
	//// <FOF formulas>
	//VLSFofFormula:
	//	'fof' '(' name=(LOWER_WORD_ID | SIGNED_LITERAL | SINGLE_QUOTE) ',' fofRole=VLSRole ',' fofFormula=VLSTerm (','
	//	annotations=VLSAnnotation)? ')' '.';
	public VLSFofFormulaElements getVLSFofFormulaAccess() {
		return pVLSFofFormula;
	}
	
	public ParserRule getVLSFofFormulaRule() {
		return getVLSFofFormulaAccess().getRule();
	}
	
	//VLSTffFormula:
	//	'tff' '(' name=VLSTffName ',' tffRole=VLSRole ',' fofFormula=VLSTffTerm (',' annotations=VLSAnnotation)? ')' '.';
	public VLSTffFormulaElements getVLSTffFormulaAccess() {
		return pVLSTffFormula;
	}
	
	public ParserRule getVLSTffFormulaRule() {
		return getVLSTffFormulaAccess().getRule();
	}
	
	//VLSTffName:
	//	VLSTffDeclPred | VLSTffFinite | VLSTffDistinct;
	public VLSTffNameElements getVLSTffNameAccess() {
		return pVLSTffName;
	}
	
	public ParserRule getVLSTffNameRule() {
		return getVLSTffNameAccess().getRule();
	}
	
	//VLSTffDistinct:
	//	'distinct_domain';
	public VLSTffDistinctElements getVLSTffDistinctAccess() {
		return pVLSTffDistinct;
	}
	
	public ParserRule getVLSTffDistinctRule() {
		return getVLSTffDistinctAccess().getRule();
	}
	
	//VLSTffFinite:
	//	'finite_domain';
	public VLSTffFiniteElements getVLSTffFiniteAccess() {
		return pVLSTffFinite;
	}
	
	public ParserRule getVLSTffFiniteRule() {
		return getVLSTffFiniteAccess().getRule();
	}
	
	//VLSTffDeclPred:
	//	'declare_' DOLLAR_ID | LOWER_WORD_ID;
	public VLSTffDeclPredElements getVLSTffDeclPredAccess() {
		return pVLSTffDeclPred;
	}
	
	public ParserRule getVLSTffDeclPredRule() {
		return getVLSTffDeclPredAccess().getRule();
	}
	
	///*
	////NAME
	//VLSName:
	//	//(atomic_Word = Atomic_Word | integer = Integer | single_quote_word = Single_Quote_Word)
	//	name = (LOWER_WORD_ID | SIGNED_INT_ID | SINGLE_QUOTE)
	//;
	//*/ //<ROLE>
	//VLSRole:
	//	"axiom" | "conjecture" | "hypothesis" | "definition" | "assumption" | "lemma"
	//	| "theorem" | "corollary" | "negated_conjecture" | "plain" | "type" |
	//	"fi_domain" | "fi_functors" | "fi_predicates" | "unknown";
	public VLSRoleElements getVLSRoleAccess() {
		return pVLSRole;
	}
	
	public ParserRule getVLSRoleRule() {
		return getVLSRoleAccess().getRule();
	}
	
	///*
	////VLSRole:
	////	VLSAxiom | VLSConjecture | VLSHypothesis | VLSDefinition |
	////	VLSAssumption | VLSLemma | VLSTheorem | VLSCorollary | VLSNegated_Conjecture |
	////	VLSPlain | VLSType |VLSFi_Domain | VLSFi_Functors | VLSFi_Predicates | VLSUnknown
	////;
	////
	////VLSAxiom:
	////	"axiom"
	////;
	////
	////VLSConjecture:
	////	"conjecture"
	////;
	////
	////VLSHypothesis:
	////	"hypothesis"
	////;
	////	
	////VLSDefinition:
	////	"definition"
	////;
	////
	////VLSAssumption:
	////	"assumption"
	////;
	////		
	////VLSLemma:
	////	"lemma"
	////;
	////			
	////VLSTheorem:
	////	"theorem"
	////;
	////				
	////VLSCorollary:
	////	"corollary"
	////;
	////			
	////VLSNegated_Conjecture:
	////	"negated_conjecture"	
	////;
	////
	////VLSPlain:
	////	"plain"
	////;
	////
	////VLSType:
	////	"type"
	////;
	////
	////VLSFi_Domain:
	////	"fi_domain"
	////;
	////
	////VLSFi_Functors:
	////	"fi_functors"
	////;
	////
	////VLSFi_Predicates:
	////	"fi_predicates"
	////;
	////
	////VLSUnknown:
	////	"unknown"
	////;
	//*/ // <ANNOTATION>
	//// Not at all based on the website. based on what we think the output will be like 
	//VLSAnnotation:
	//	'['? name=(LOWER_WORD_ID | SINGLE_QUOTE | VLSRole)? ('(' followup=VLSAnnotationTerms ')')? ']'?;
	public VLSAnnotationElements getVLSAnnotationAccess() {
		return pVLSAnnotation;
	}
	
	public ParserRule getVLSAnnotationRule() {
		return getVLSAnnotationAccess().getRule();
	}
	
	//VLSAnnotationTerms VLSAnnotation:
	//	terms+=VLSAnnotation (',' terms+=VLSAnnotation)*;
	public VLSAnnotationTermsElements getVLSAnnotationTermsAccess() {
		return pVLSAnnotationTerms;
	}
	
	public ParserRule getVLSAnnotationTermsRule() {
		return getVLSAnnotationTermsAccess().getRule();
	}
	
	////////////////////////////////////
	//// VLS Terms
	////////////////////////////////////
	//VLSTffTerm:
	//	VLSTerm | VLSDeclaration | VLSCommentTerm;
	public VLSTffTermElements getVLSTffTermAccess() {
		return pVLSTffTerm;
	}
	
	public ParserRule getVLSTffTermRule() {
		return getVLSTffTermAccess().getRule();
	}
	
	//VLSCommentTerm VLSTerm:
	//	comment=SINGLE_COMMENT;
	public VLSCommentTermElements getVLSCommentTermAccess() {
		return pVLSCommentTerm;
	}
	
	public ParserRule getVLSCommentTermRule() {
		return getVLSCommentTermAccess().getRule();
	}
	
	///////////////////
	////TFF Specific
	// VLSDeclaration:
	//	VLSVariableDeclaration | VLSOtherDeclaration;
	public VLSDeclarationElements getVLSDeclarationAccess() {
		return pVLSDeclaration;
	}
	
	public ParserRule getVLSDeclarationRule() {
		return getVLSDeclarationAccess().getRule();
	}
	
	//VLSOtherDeclaration:
	//	name=VLSAtomicConstant ':' type=VLSTypeDef;
	public VLSOtherDeclarationElements getVLSOtherDeclarationAccess() {
		return pVLSOtherDeclaration;
	}
	
	public ParserRule getVLSOtherDeclarationRule() {
		return getVLSOtherDeclarationAccess().getRule();
	}
	
	//VLSVariableDeclaration:
	//	name=VLSVariable ':' type=VLSTypeDef;
	public VLSVariableDeclarationElements getVLSVariableDeclarationAccess() {
		return pVLSVariableDeclaration;
	}
	
	public ParserRule getVLSVariableDeclarationRule() {
		return getVLSVariableDeclarationAccess().getRule();
	}
	
	//VLSTypeDef:
	//	typeSig=VLSUnitaryTerm ('>' mapsTo=VLSAtomicConstant)? //might need to make VLSAtomic to include VLSVariable
	//;
	public VLSTypeDefElements getVLSTypeDefAccess() {
		return pVLSTypeDef;
	}
	
	public ParserRule getVLSTypeDefRule() {
		return getVLSTypeDefAccess().getRule();
	}
	
	//VLSUnitaryTerm VLSTypeDef:
	//	initType=VLSAtomic ('*' nextType=VLSAtomicConstant)* //might need to make VLSAtomic to include VLSVariable
	//;
	public VLSUnitaryTermElements getVLSUnitaryTermAccess() {
		return pVLSUnitaryTerm;
	}
	
	public ParserRule getVLSUnitaryTermRule() {
		return getVLSUnitaryTermAccess().getRule();
	}
	
	////TFF Specific
	///////////////////
	//VLSTerm:
	//	VLSBinary;
	public VLSTermElements getVLSTermAccess() {
		return pVLSTerm;
	}
	
	public ParserRule getVLSTermRule() {
		return getVLSTermAccess().getRule();
	}
	
	////*
	////VLSBinaryFormula
	//VLSBinary VLSTerm:
	//	VLSUnitaryFormula (({VLSEquivalent.left=current} "<=>" | {VLSImplies.left=current} "=>" |
	//	{VLSRevImplies.left=current} "<=" | {VLSXnor.left=current} "<~>" | {VLSNor.left=current} "~|" |
	//	{VLSNand.left=current} "~&") right=VLSUnitaryFormula | ({VLSAnd.left=current} '&' right=VLSUnitaryFormula)+
	//	| ({VLSOr.left=current} '|' right=VLSUnitaryFormula)+)?;
	public VLSBinaryElements getVLSBinaryAccess() {
		return pVLSBinary;
	}
	
	public ParserRule getVLSBinaryRule() {
		return getVLSBinaryAccess().getRule();
	}
	
	////VLSUnitaryFormula
	//VLSUnitaryFormula VLSTerm:
	//	VLSUniversalQuantifier | VLSExistentialQuantifier | VLSUnaryNegation | VLSUnaryInfix
	//	//| VLSEquality 
	//	| '(' VLSTerm ')';
	public VLSUnitaryFormulaElements getVLSUnitaryFormulaAccess() {
		return pVLSUnitaryFormula;
	}
	
	public ParserRule getVLSUnitaryFormulaRule() {
		return getVLSUnitaryFormulaAccess().getRule();
	}
	
	//VLSUniversalQuantifier VLSTerm:
	//	{VLSUniversalQuantifier} ("!" '[' variables+=(VLSVariable | VLSVariableDeclaration) (',' variables+=(VLSVariable |
	//	VLSVariableDeclaration))* ']' ':') operand=VLSUnitaryFormula;
	public VLSUniversalQuantifierElements getVLSUniversalQuantifierAccess() {
		return pVLSUniversalQuantifier;
	}
	
	public ParserRule getVLSUniversalQuantifierRule() {
		return getVLSUniversalQuantifierAccess().getRule();
	}
	
	//VLSExistentialQuantifier VLSTerm:
	//	{VLSExistentialQuantifier} ("?" '[' variables+=(VLSVariable | VLSVariableDeclaration) (',' variables+=(VLSVariable |
	//	VLSVariableDeclaration))* ']' ':') operand=VLSUnitaryFormula;
	public VLSExistentialQuantifierElements getVLSExistentialQuantifierAccess() {
		return pVLSExistentialQuantifier;
	}
	
	public ParserRule getVLSExistentialQuantifierRule() {
		return getVLSExistentialQuantifierAccess().getRule();
	}
	
	//VLSUnaryNegation VLSTerm:
	//	{VLSUnaryNegation} '~' operand=VLSUnitaryFormula;
	public VLSUnaryNegationElements getVLSUnaryNegationAccess() {
		return pVLSUnaryNegation;
	}
	
	public ParserRule getVLSUnaryNegationRule() {
		return getVLSUnaryNegationAccess().getRule();
	}
	
	//VLSUnaryInfix VLSTerm:
	//	VLSAtomic (({VLSInequality.left=current} "!=" | {VLSEquality.left=current} "=" | {VLSAssignment.left=current} ":=")
	//	right=VLSAtomic)?;
	public VLSUnaryInfixElements getVLSUnaryInfixAccess() {
		return pVLSUnaryInfix;
	}
	
	public ParserRule getVLSUnaryInfixRule() {
		return getVLSUnaryInfixAccess().getRule();
	}
	
	////NOT SUREEEE
	////VLSEquality returns VLSTerm:
	////	VLSFofTerm ({VLSEquality.left = current} "=" right = VLSFofTerm)?
	////	
	////;
	///*
	//enum VLSDefinedFunctor:
	//		UMINUS='$uminus' | SUM='$sum' | DIFFERENCE='$difference' | PRODUCT='$product' | QUOTIENT='$quotient' | 
	//		QUOTIENT_E='$quotient_e' | QUOTIENT_T='$quotient_t' | QUOTIENT_F='$quotient_f' | REMAINDER_E='$remainder_e' |
	//		 REMAINDER_T='$remainder_t' | REMAINDER_F='$remainder_f' | FLOOR='$floor' | CEILING='$ceiling' |
	//		 TRUNCATE='$truncate' | ROUND='$round' | TO_INT='$to_int' | TO_RAT='$to_rat' | TO_REAL='$to_real'
	//    ;
	//*/ VLSAtomic VLSTerm:
	//	VLSAtomicConstant | VLSAtomicFunction | VLSVariable
	//	| VLSDefinedTerm //temporary solution. this is only valid for equality, not for != or :=
	//	//| VLSEquality
	//;
	public VLSAtomicElements getVLSAtomicAccess() {
		return pVLSAtomic;
	}
	
	public ParserRule getVLSAtomicRule() {
		return getVLSAtomicAccess().getRule();
	}
	
	//VLSAtomicConstant VLSTerm:
	//	{VLSConstant} name=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID | VLSRole) | {VLSTrue} '$true' |
	//	{VLSFalse} '$false';
	public VLSAtomicConstantElements getVLSAtomicConstantAccess() {
		return pVLSAtomicConstant;
	}
	
	public ParserRule getVLSAtomicConstantRule() {
		return getVLSAtomicConstantAccess().getRule();
	}
	
	//VLSAtomicFunction VLSTerm:
	//	{VLSFunction} constant=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID | VLSRole) ('(' terms+=VLSFofTerm
	//	(',' terms+=VLSFofTerm)* ')') | {VLSLess} name='$less' '(' terms+=VLSFofTerm ',' terms+=VLSFofTerm ')';
	public VLSAtomicFunctionElements getVLSAtomicFunctionAccess() {
		return pVLSAtomicFunction;
	}
	
	public ParserRule getVLSAtomicFunctionRule() {
		return getVLSAtomicFunctionAccess().getRule();
	}
	
	//VLSVariable:
	//	name=UPPER_WORD_ID;
	public VLSVariableElements getVLSVariableAccess() {
		return pVLSVariable;
	}
	
	public ParserRule getVLSVariableRule() {
		return getVLSVariableAccess().getRule();
	}
	
	//VLSFofTerm VLSTerm:
	//	VLSVariable | VLSFunctionAsTerm | VLSDefinedTerm;
	public VLSFofTermElements getVLSFofTermAccess() {
		return pVLSFofTerm;
	}
	
	public ParserRule getVLSFofTermRule() {
		return getVLSFofTermAccess().getRule();
	}
	
	//VLSFunctionAsTerm:
	//	functor=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID) ('(' terms+=VLSFofTerm (',' terms+=VLSFofTerm)*
	//	')')?;
	public VLSFunctionAsTermElements getVLSFunctionAsTermAccess() {
		return pVLSFunctionAsTerm;
	}
	
	public ParserRule getVLSFunctionAsTermRule() {
		return getVLSFunctionAsTermAccess().getRule();
	}
	
	//VLSDefinedTerm:
	//	{VLSInt} value=SIGNED_LITERAL | {VLSDoubleQuote} value=DOUBLE_QUOTE;
	public VLSDefinedTermElements getVLSDefinedTermAccess() {
		return pVLSDefinedTerm;
	}
	
	public ParserRule getVLSDefinedTermRule() {
		return getVLSDefinedTermAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
