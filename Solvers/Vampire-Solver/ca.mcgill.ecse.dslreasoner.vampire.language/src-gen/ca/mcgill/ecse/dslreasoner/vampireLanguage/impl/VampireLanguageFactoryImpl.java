/**
 * generated by Xtext 2.14.0
 */
package ca.mcgill.ecse.dslreasoner.vampireLanguage.impl;

import ca.mcgill.ecse.dslreasoner.vampireLanguage.*;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;

import org.eclipse.emf.ecore.impl.EFactoryImpl;

import org.eclipse.emf.ecore.plugin.EcorePlugin;

/**
 * <!-- begin-user-doc -->
 * An implementation of the model <b>Factory</b>.
 * <!-- end-user-doc -->
 * @generated
 */
public class VampireLanguageFactoryImpl extends EFactoryImpl implements VampireLanguageFactory
{
  /**
   * Creates the default factory implementation.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public static VampireLanguageFactory init()
  {
    try
    {
      VampireLanguageFactory theVampireLanguageFactory = (VampireLanguageFactory)EPackage.Registry.INSTANCE.getEFactory(VampireLanguagePackage.eNS_URI);
      if (theVampireLanguageFactory != null)
      {
        return theVampireLanguageFactory;
      }
    }
    catch (Exception exception)
    {
      EcorePlugin.INSTANCE.log(exception);
    }
    return new VampireLanguageFactoryImpl();
  }

  /**
   * Creates an instance of the factory.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VampireLanguageFactoryImpl()
  {
    super();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EObject create(EClass eClass)
  {
    switch (eClass.getClassifierID())
    {
      case VampireLanguagePackage.VAMPIRE_MODEL: return createVampireModel();
      case VampireLanguagePackage.VLS_COMMENT: return createVLSComment();
      case VampireLanguagePackage.VLS_CONFIRMATIONS: return createVLSConfirmations();
      case VampireLanguagePackage.VLS_FOF_FORMULA: return createVLSFofFormula();
      case VampireLanguagePackage.VLS_TFF_FORMULA: return createVLSTffFormula();
      case VampireLanguagePackage.VLS_ANNOTATION: return createVLSAnnotation();
      case VampireLanguagePackage.VLS_TFF_TERM: return createVLSTffTerm();
      case VampireLanguagePackage.VLS_TERM: return createVLSTerm();
      case VampireLanguagePackage.VLS_DECLARATION: return createVLSDeclaration();
      case VampireLanguagePackage.VLS_OTHER_DECLARATION: return createVLSOtherDeclaration();
      case VampireLanguagePackage.VLS_VARIABLE_DECLARATION: return createVLSVariableDeclaration();
      case VampireLanguagePackage.VLS_TYPE_DEF: return createVLSTypeDef();
      case VampireLanguagePackage.VLS_VARIABLE: return createVLSVariable();
      case VampireLanguagePackage.VLS_FUNCTION_AS_TERM: return createVLSFunctionAsTerm();
      case VampireLanguagePackage.VLS_DEFINED_TERM: return createVLSDefinedTerm();
      case VampireLanguagePackage.VLS_SATISFIABLE: return createVLSSatisfiable();
      case VampireLanguagePackage.VLS_WARNING: return createVLSWarning();
      case VampireLanguagePackage.VLS_TRYING: return createVLSTrying();
      case VampireLanguagePackage.VLS_FINITE_MODEL: return createVLSFiniteModel();
      case VampireLanguagePackage.VLS_EQUIVALENT: return createVLSEquivalent();
      case VampireLanguagePackage.VLS_IMPLIES: return createVLSImplies();
      case VampireLanguagePackage.VLS_REV_IMPLIES: return createVLSRevImplies();
      case VampireLanguagePackage.VLS_XNOR: return createVLSXnor();
      case VampireLanguagePackage.VLS_NOR: return createVLSNor();
      case VampireLanguagePackage.VLS_NAND: return createVLSNand();
      case VampireLanguagePackage.VLS_AND: return createVLSAnd();
      case VampireLanguagePackage.VLS_OR: return createVLSOr();
      case VampireLanguagePackage.VLS_UNIVERSAL_QUANTIFIER: return createVLSUniversalQuantifier();
      case VampireLanguagePackage.VLS_EXISTENTIAL_QUANTIFIER: return createVLSExistentialQuantifier();
      case VampireLanguagePackage.VLS_UNARY_NEGATION: return createVLSUnaryNegation();
      case VampireLanguagePackage.VLS_INEQUALITY: return createVLSInequality();
      case VampireLanguagePackage.VLS_EQUALITY: return createVLSEquality();
      case VampireLanguagePackage.VLS_ASSIGNMENT: return createVLSAssignment();
      case VampireLanguagePackage.VLS_CONSTANT: return createVLSConstant();
      case VampireLanguagePackage.VLS_TRUE: return createVLSTrue();
      case VampireLanguagePackage.VLS_FALSE: return createVLSFalse();
      case VampireLanguagePackage.VLS_FUNCTION: return createVLSFunction();
      case VampireLanguagePackage.VLS_LESS: return createVLSLess();
      case VampireLanguagePackage.VLS_INT: return createVLSInt();
      case VampireLanguagePackage.VLS_DOUBLE_QUOTE: return createVLSDoubleQuote();
      default:
        throw new IllegalArgumentException("The class '" + eClass.getName() + "' is not a valid classifier");
    }
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VampireModel createVampireModel()
  {
    VampireModelImpl vampireModel = new VampireModelImpl();
    return vampireModel;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSComment createVLSComment()
  {
    VLSCommentImpl vlsComment = new VLSCommentImpl();
    return vlsComment;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSConfirmations createVLSConfirmations()
  {
    VLSConfirmationsImpl vlsConfirmations = new VLSConfirmationsImpl();
    return vlsConfirmations;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSFofFormula createVLSFofFormula()
  {
    VLSFofFormulaImpl vlsFofFormula = new VLSFofFormulaImpl();
    return vlsFofFormula;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSTffFormula createVLSTffFormula()
  {
    VLSTffFormulaImpl vlsTffFormula = new VLSTffFormulaImpl();
    return vlsTffFormula;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSAnnotation createVLSAnnotation()
  {
    VLSAnnotationImpl vlsAnnotation = new VLSAnnotationImpl();
    return vlsAnnotation;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSTffTerm createVLSTffTerm()
  {
    VLSTffTermImpl vlsTffTerm = new VLSTffTermImpl();
    return vlsTffTerm;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSTerm createVLSTerm()
  {
    VLSTermImpl vlsTerm = new VLSTermImpl();
    return vlsTerm;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSDeclaration createVLSDeclaration()
  {
    VLSDeclarationImpl vlsDeclaration = new VLSDeclarationImpl();
    return vlsDeclaration;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSOtherDeclaration createVLSOtherDeclaration()
  {
    VLSOtherDeclarationImpl vlsOtherDeclaration = new VLSOtherDeclarationImpl();
    return vlsOtherDeclaration;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSVariableDeclaration createVLSVariableDeclaration()
  {
    VLSVariableDeclarationImpl vlsVariableDeclaration = new VLSVariableDeclarationImpl();
    return vlsVariableDeclaration;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSTypeDef createVLSTypeDef()
  {
    VLSTypeDefImpl vlsTypeDef = new VLSTypeDefImpl();
    return vlsTypeDef;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSVariable createVLSVariable()
  {
    VLSVariableImpl vlsVariable = new VLSVariableImpl();
    return vlsVariable;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSFunctionAsTerm createVLSFunctionAsTerm()
  {
    VLSFunctionAsTermImpl vlsFunctionAsTerm = new VLSFunctionAsTermImpl();
    return vlsFunctionAsTerm;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSDefinedTerm createVLSDefinedTerm()
  {
    VLSDefinedTermImpl vlsDefinedTerm = new VLSDefinedTermImpl();
    return vlsDefinedTerm;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSSatisfiable createVLSSatisfiable()
  {
    VLSSatisfiableImpl vlsSatisfiable = new VLSSatisfiableImpl();
    return vlsSatisfiable;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSWarning createVLSWarning()
  {
    VLSWarningImpl vlsWarning = new VLSWarningImpl();
    return vlsWarning;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSTrying createVLSTrying()
  {
    VLSTryingImpl vlsTrying = new VLSTryingImpl();
    return vlsTrying;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSFiniteModel createVLSFiniteModel()
  {
    VLSFiniteModelImpl vlsFiniteModel = new VLSFiniteModelImpl();
    return vlsFiniteModel;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSEquivalent createVLSEquivalent()
  {
    VLSEquivalentImpl vlsEquivalent = new VLSEquivalentImpl();
    return vlsEquivalent;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSImplies createVLSImplies()
  {
    VLSImpliesImpl vlsImplies = new VLSImpliesImpl();
    return vlsImplies;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSRevImplies createVLSRevImplies()
  {
    VLSRevImpliesImpl vlsRevImplies = new VLSRevImpliesImpl();
    return vlsRevImplies;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSXnor createVLSXnor()
  {
    VLSXnorImpl vlsXnor = new VLSXnorImpl();
    return vlsXnor;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSNor createVLSNor()
  {
    VLSNorImpl vlsNor = new VLSNorImpl();
    return vlsNor;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSNand createVLSNand()
  {
    VLSNandImpl vlsNand = new VLSNandImpl();
    return vlsNand;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSAnd createVLSAnd()
  {
    VLSAndImpl vlsAnd = new VLSAndImpl();
    return vlsAnd;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSOr createVLSOr()
  {
    VLSOrImpl vlsOr = new VLSOrImpl();
    return vlsOr;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSUniversalQuantifier createVLSUniversalQuantifier()
  {
    VLSUniversalQuantifierImpl vlsUniversalQuantifier = new VLSUniversalQuantifierImpl();
    return vlsUniversalQuantifier;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSExistentialQuantifier createVLSExistentialQuantifier()
  {
    VLSExistentialQuantifierImpl vlsExistentialQuantifier = new VLSExistentialQuantifierImpl();
    return vlsExistentialQuantifier;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSUnaryNegation createVLSUnaryNegation()
  {
    VLSUnaryNegationImpl vlsUnaryNegation = new VLSUnaryNegationImpl();
    return vlsUnaryNegation;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSInequality createVLSInequality()
  {
    VLSInequalityImpl vlsInequality = new VLSInequalityImpl();
    return vlsInequality;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSEquality createVLSEquality()
  {
    VLSEqualityImpl vlsEquality = new VLSEqualityImpl();
    return vlsEquality;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSAssignment createVLSAssignment()
  {
    VLSAssignmentImpl vlsAssignment = new VLSAssignmentImpl();
    return vlsAssignment;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSConstant createVLSConstant()
  {
    VLSConstantImpl vlsConstant = new VLSConstantImpl();
    return vlsConstant;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSTrue createVLSTrue()
  {
    VLSTrueImpl vlsTrue = new VLSTrueImpl();
    return vlsTrue;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSFalse createVLSFalse()
  {
    VLSFalseImpl vlsFalse = new VLSFalseImpl();
    return vlsFalse;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSFunction createVLSFunction()
  {
    VLSFunctionImpl vlsFunction = new VLSFunctionImpl();
    return vlsFunction;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSLess createVLSLess()
  {
    VLSLessImpl vlsLess = new VLSLessImpl();
    return vlsLess;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSInt createVLSInt()
  {
    VLSIntImpl vlsInt = new VLSIntImpl();
    return vlsInt;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSDoubleQuote createVLSDoubleQuote()
  {
    VLSDoubleQuoteImpl vlsDoubleQuote = new VLSDoubleQuoteImpl();
    return vlsDoubleQuote;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VampireLanguagePackage getVampireLanguagePackage()
  {
    return (VampireLanguagePackage)getEPackage();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @deprecated
   * @generated
   */
  @Deprecated
  public static VampireLanguagePackage getPackage()
  {
    return VampireLanguagePackage.eINSTANCE;
  }

} //VampireLanguageFactoryImpl
