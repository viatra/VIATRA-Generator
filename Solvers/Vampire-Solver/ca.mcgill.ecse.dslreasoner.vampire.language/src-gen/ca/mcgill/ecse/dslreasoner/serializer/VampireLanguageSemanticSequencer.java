/*
 * generated by Xtext 2.14.0
 */
package ca.mcgill.ecse.dslreasoner.serializer;

import ca.mcgill.ecse.dslreasoner.services.VampireLanguageGrammarAccess;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSAnd;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSAnnotation;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSAssignment;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSComment;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSConstant;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSDoubleQuote;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSEquality;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSEquivalent;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSExistentialQuantifier;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSFalse;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSFiniteModel;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSFofFormula;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSFunction;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSFunctionAsTerm;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSImplies;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSInequality;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSInt;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSLess;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSNand;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSNor;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSOr;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSOtherDeclaration;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSRevImplies;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSSatisfiable;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSTerm;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSTffFormula;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSTrue;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSTrying;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSTypeDef;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSUnaryNegation;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSUniversalQuantifier;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSVariable;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSVariableDeclaration;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSWarning;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VLSXnor;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VampireLanguagePackage;
import ca.mcgill.ecse.dslreasoner.vampireLanguage.VampireModel;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class VampireLanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private VampireLanguageGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == VampireLanguagePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case VampireLanguagePackage.VLS_AND:
				sequence_VLSBinary(context, (VLSAnd) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_ANNOTATION:
				if (rule == grammarAccess.getVLSAnnotationTermsRule()) {
					sequence_VLSAnnotationTerms(context, (VLSAnnotation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVLSAnnotationRule()) {
					sequence_VLSAnnotation(context, (VLSAnnotation) semanticObject); 
					return; 
				}
				else break;
			case VampireLanguagePackage.VLS_ASSIGNMENT:
				sequence_VLSUnaryInfix(context, (VLSAssignment) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_COMMENT:
				sequence_VLSComment(context, (VLSComment) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_CONSTANT:
				sequence_VLSAtomicConstant(context, (VLSConstant) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_DOUBLE_QUOTE:
				sequence_VLSDefinedTerm(context, (VLSDoubleQuote) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_EQUALITY:
				sequence_VLSUnaryInfix(context, (VLSEquality) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_EQUIVALENT:
				sequence_VLSBinary(context, (VLSEquivalent) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_EXISTENTIAL_QUANTIFIER:
				sequence_VLSExistentialQuantifier(context, (VLSExistentialQuantifier) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_FALSE:
				sequence_VLSAtomicConstant(context, (VLSFalse) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_FINITE_MODEL:
				sequence_VLSConfirmations(context, (VLSFiniteModel) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_FOF_FORMULA:
				sequence_VLSFofFormula(context, (VLSFofFormula) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_FUNCTION:
				sequence_VLSAtomicFunction(context, (VLSFunction) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_FUNCTION_AS_TERM:
				sequence_VLSFunctionAsTerm(context, (VLSFunctionAsTerm) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_IMPLIES:
				sequence_VLSBinary(context, (VLSImplies) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_INEQUALITY:
				sequence_VLSUnaryInfix(context, (VLSInequality) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_INT:
				sequence_VLSDefinedTerm(context, (VLSInt) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_LESS:
				sequence_VLSAtomicFunction(context, (VLSLess) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_NAND:
				sequence_VLSBinary(context, (VLSNand) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_NOR:
				sequence_VLSBinary(context, (VLSNor) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_OR:
				sequence_VLSBinary(context, (VLSOr) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_OTHER_DECLARATION:
				sequence_VLSOtherDeclaration(context, (VLSOtherDeclaration) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_REV_IMPLIES:
				sequence_VLSBinary(context, (VLSRevImplies) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_SATISFIABLE:
				sequence_VLSConfirmations(context, (VLSSatisfiable) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_TERM:
				sequence_VLSCommentTerm(context, (VLSTerm) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_TFF_FORMULA:
				sequence_VLSTffFormula(context, (VLSTffFormula) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_TRUE:
				sequence_VLSAtomicConstant(context, (VLSTrue) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_TRYING:
				sequence_VLSConfirmations(context, (VLSTrying) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_TYPE_DEF:
				if (rule == grammarAccess.getVLSTypeDefRule()) {
					sequence_VLSTypeDef(context, (VLSTypeDef) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVLSUnitaryTermRule()) {
					sequence_VLSUnitaryTerm(context, (VLSTypeDef) semanticObject); 
					return; 
				}
				else break;
			case VampireLanguagePackage.VLS_UNARY_NEGATION:
				sequence_VLSUnaryNegation(context, (VLSUnaryNegation) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_UNIVERSAL_QUANTIFIER:
				sequence_VLSUniversalQuantifier(context, (VLSUniversalQuantifier) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_VARIABLE:
				sequence_VLSVariable(context, (VLSVariable) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_VARIABLE_DECLARATION:
				sequence_VLSVariableDeclaration(context, (VLSVariableDeclaration) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_WARNING:
				sequence_VLSConfirmations(context, (VLSWarning) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_XNOR:
				sequence_VLSBinary(context, (VLSXnor) semanticObject); 
				return; 
			case VampireLanguagePackage.VAMPIRE_MODEL:
				sequence_VampireModel(context, (VampireModel) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     VLSAnnotationTerms returns VLSAnnotation
	 *
	 * Constraint:
	 *     (terms+=VLSAnnotation terms+=VLSAnnotation*)
	 */
	protected void sequence_VLSAnnotationTerms(ISerializationContext context, VLSAnnotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSAnnotation returns VLSAnnotation
	 *
	 * Constraint:
	 *     (((name=LOWER_WORD_ID | name=SINGLE_QUOTE | name=VLSRole) followup=VLSAnnotationTerms) | followup=VLSAnnotationTerms)?
	 */
	protected void sequence_VLSAnnotation(ISerializationContext context, VLSAnnotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSConstant
	 *     VLSTerm returns VLSConstant
	 *     VLSBinary returns VLSConstant
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSConstant
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSConstant
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSConstant
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSConstant
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSConstant
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSConstant
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSConstant
	 *     VLSBinary.VLSOr_1_2_0 returns VLSConstant
	 *     VLSUnitaryFormula returns VLSConstant
	 *     VLSUnaryInfix returns VLSConstant
	 *     VLSUnaryInfix.VLSInequality_1_0_0_0 returns VLSConstant
	 *     VLSUnaryInfix.VLSEquality_1_0_1_0 returns VLSConstant
	 *     VLSUnaryInfix.VLSAssignment_1_0_2_0 returns VLSConstant
	 *     VLSAtomic returns VLSConstant
	 *     VLSAtomicConstant returns VLSConstant
	 *
	 * Constraint:
	 *     (name=LOWER_WORD_ID | name=SINGLE_QUOTE | name=DOLLAR_ID | name=DOUBLE_DOLLAR_ID | name=VLSRole)
	 */
	protected void sequence_VLSAtomicConstant(ISerializationContext context, VLSConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSFalse
	 *     VLSTerm returns VLSFalse
	 *     VLSBinary returns VLSFalse
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSFalse
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSFalse
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSFalse
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSFalse
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSFalse
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSFalse
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSFalse
	 *     VLSBinary.VLSOr_1_2_0 returns VLSFalse
	 *     VLSUnitaryFormula returns VLSFalse
	 *     VLSUnaryInfix returns VLSFalse
	 *     VLSUnaryInfix.VLSInequality_1_0_0_0 returns VLSFalse
	 *     VLSUnaryInfix.VLSEquality_1_0_1_0 returns VLSFalse
	 *     VLSUnaryInfix.VLSAssignment_1_0_2_0 returns VLSFalse
	 *     VLSAtomic returns VLSFalse
	 *     VLSAtomicConstant returns VLSFalse
	 *
	 * Constraint:
	 *     {VLSFalse}
	 */
	protected void sequence_VLSAtomicConstant(ISerializationContext context, VLSFalse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSTrue
	 *     VLSTerm returns VLSTrue
	 *     VLSBinary returns VLSTrue
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSTrue
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSTrue
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSTrue
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSTrue
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSTrue
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSTrue
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSTrue
	 *     VLSBinary.VLSOr_1_2_0 returns VLSTrue
	 *     VLSUnitaryFormula returns VLSTrue
	 *     VLSUnaryInfix returns VLSTrue
	 *     VLSUnaryInfix.VLSInequality_1_0_0_0 returns VLSTrue
	 *     VLSUnaryInfix.VLSEquality_1_0_1_0 returns VLSTrue
	 *     VLSUnaryInfix.VLSAssignment_1_0_2_0 returns VLSTrue
	 *     VLSAtomic returns VLSTrue
	 *     VLSAtomicConstant returns VLSTrue
	 *
	 * Constraint:
	 *     {VLSTrue}
	 */
	protected void sequence_VLSAtomicConstant(ISerializationContext context, VLSTrue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSFunction
	 *     VLSTerm returns VLSFunction
	 *     VLSBinary returns VLSFunction
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSFunction
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSFunction
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSFunction
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSFunction
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSFunction
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSFunction
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSFunction
	 *     VLSBinary.VLSOr_1_2_0 returns VLSFunction
	 *     VLSUnitaryFormula returns VLSFunction
	 *     VLSUnaryInfix returns VLSFunction
	 *     VLSUnaryInfix.VLSInequality_1_0_0_0 returns VLSFunction
	 *     VLSUnaryInfix.VLSEquality_1_0_1_0 returns VLSFunction
	 *     VLSUnaryInfix.VLSAssignment_1_0_2_0 returns VLSFunction
	 *     VLSAtomic returns VLSFunction
	 *     VLSAtomicFunction returns VLSFunction
	 *
	 * Constraint:
	 *     (
	 *         (constant=LOWER_WORD_ID | constant=SINGLE_QUOTE | constant=DOLLAR_ID | constant=DOUBLE_DOLLAR_ID | constant=VLSRole) 
	 *         terms+=VLSFofTerm 
	 *         terms+=VLSFofTerm*
	 *     )
	 */
	protected void sequence_VLSAtomicFunction(ISerializationContext context, VLSFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSLess
	 *     VLSTerm returns VLSLess
	 *     VLSBinary returns VLSLess
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSLess
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSLess
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSLess
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSLess
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSLess
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSLess
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSLess
	 *     VLSBinary.VLSOr_1_2_0 returns VLSLess
	 *     VLSUnitaryFormula returns VLSLess
	 *     VLSUnaryInfix returns VLSLess
	 *     VLSUnaryInfix.VLSInequality_1_0_0_0 returns VLSLess
	 *     VLSUnaryInfix.VLSEquality_1_0_1_0 returns VLSLess
	 *     VLSUnaryInfix.VLSAssignment_1_0_2_0 returns VLSLess
	 *     VLSAtomic returns VLSLess
	 *     VLSAtomicFunction returns VLSLess
	 *
	 * Constraint:
	 *     (name='$less' terms+=VLSFofTerm terms+=VLSFofTerm)
	 */
	protected void sequence_VLSAtomicFunction(ISerializationContext context, VLSLess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSAnd
	 *     VLSTerm returns VLSAnd
	 *     VLSBinary returns VLSAnd
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSAnd
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSAnd
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSAnd
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSAnd
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSAnd
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSAnd
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSAnd
	 *     VLSBinary.VLSOr_1_2_0 returns VLSAnd
	 *     VLSUnitaryFormula returns VLSAnd
	 *
	 * Constraint:
	 *     (left=VLSBinary_VLSAnd_1_1_0 right=VLSUnitaryFormula)
	 */
	protected void sequence_VLSBinary(ISerializationContext context, VLSAnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSBinaryAccess().getVLSAndLeftAction_1_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSBinaryAccess().getRightVLSUnitaryFormulaParserRuleCall_1_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSEquivalent
	 *     VLSTerm returns VLSEquivalent
	 *     VLSBinary returns VLSEquivalent
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSEquivalent
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSEquivalent
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSEquivalent
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSEquivalent
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSEquivalent
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSEquivalent
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSEquivalent
	 *     VLSBinary.VLSOr_1_2_0 returns VLSEquivalent
	 *     VLSUnitaryFormula returns VLSEquivalent
	 *
	 * Constraint:
	 *     (left=VLSBinary_VLSEquivalent_1_0_0_0_0 right=VLSUnitaryFormula)
	 */
	protected void sequence_VLSBinary(ISerializationContext context, VLSEquivalent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_EQUIVALENT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_EQUIVALENT__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_EQUIVALENT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_EQUIVALENT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSBinaryAccess().getVLSEquivalentLeftAction_1_0_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSBinaryAccess().getRightVLSUnitaryFormulaParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSImplies
	 *     VLSTerm returns VLSImplies
	 *     VLSBinary returns VLSImplies
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSImplies
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSImplies
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSImplies
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSImplies
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSImplies
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSImplies
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSImplies
	 *     VLSBinary.VLSOr_1_2_0 returns VLSImplies
	 *     VLSUnitaryFormula returns VLSImplies
	 *
	 * Constraint:
	 *     (left=VLSBinary_VLSImplies_1_0_0_1_0 right=VLSUnitaryFormula)
	 */
	protected void sequence_VLSBinary(ISerializationContext context, VLSImplies semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_IMPLIES__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_IMPLIES__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_IMPLIES__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_IMPLIES__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSBinaryAccess().getVLSImpliesLeftAction_1_0_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSBinaryAccess().getRightVLSUnitaryFormulaParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSNand
	 *     VLSTerm returns VLSNand
	 *     VLSBinary returns VLSNand
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSNand
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSNand
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSNand
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSNand
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSNand
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSNand
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSNand
	 *     VLSBinary.VLSOr_1_2_0 returns VLSNand
	 *     VLSUnitaryFormula returns VLSNand
	 *
	 * Constraint:
	 *     (left=VLSBinary_VLSNand_1_0_0_5_0 right=VLSUnitaryFormula)
	 */
	protected void sequence_VLSBinary(ISerializationContext context, VLSNand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_NAND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_NAND__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_NAND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_NAND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSBinaryAccess().getVLSNandLeftAction_1_0_0_5_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSBinaryAccess().getRightVLSUnitaryFormulaParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSNor
	 *     VLSTerm returns VLSNor
	 *     VLSBinary returns VLSNor
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSNor
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSNor
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSNor
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSNor
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSNor
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSNor
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSNor
	 *     VLSBinary.VLSOr_1_2_0 returns VLSNor
	 *     VLSUnitaryFormula returns VLSNor
	 *
	 * Constraint:
	 *     (left=VLSBinary_VLSNor_1_0_0_4_0 right=VLSUnitaryFormula)
	 */
	protected void sequence_VLSBinary(ISerializationContext context, VLSNor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_NOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_NOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_NOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_NOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSBinaryAccess().getVLSNorLeftAction_1_0_0_4_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSBinaryAccess().getRightVLSUnitaryFormulaParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSOr
	 *     VLSTerm returns VLSOr
	 *     VLSBinary returns VLSOr
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSOr
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSOr
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSOr
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSOr
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSOr
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSOr
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSOr
	 *     VLSBinary.VLSOr_1_2_0 returns VLSOr
	 *     VLSUnitaryFormula returns VLSOr
	 *
	 * Constraint:
	 *     (left=VLSBinary_VLSOr_1_2_0 right=VLSUnitaryFormula)
	 */
	protected void sequence_VLSBinary(ISerializationContext context, VLSOr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSBinaryAccess().getVLSOrLeftAction_1_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSBinaryAccess().getRightVLSUnitaryFormulaParserRuleCall_1_2_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSRevImplies
	 *     VLSTerm returns VLSRevImplies
	 *     VLSBinary returns VLSRevImplies
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSRevImplies
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSRevImplies
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSRevImplies
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSRevImplies
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSRevImplies
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSRevImplies
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSRevImplies
	 *     VLSBinary.VLSOr_1_2_0 returns VLSRevImplies
	 *     VLSUnitaryFormula returns VLSRevImplies
	 *
	 * Constraint:
	 *     (left=VLSBinary_VLSRevImplies_1_0_0_2_0 right=VLSUnitaryFormula)
	 */
	protected void sequence_VLSBinary(ISerializationContext context, VLSRevImplies semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_REV_IMPLIES__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_REV_IMPLIES__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_REV_IMPLIES__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_REV_IMPLIES__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSBinaryAccess().getVLSRevImpliesLeftAction_1_0_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSBinaryAccess().getRightVLSUnitaryFormulaParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSXnor
	 *     VLSTerm returns VLSXnor
	 *     VLSBinary returns VLSXnor
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSXnor
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSXnor
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSXnor
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSXnor
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSXnor
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSXnor
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSXnor
	 *     VLSBinary.VLSOr_1_2_0 returns VLSXnor
	 *     VLSUnitaryFormula returns VLSXnor
	 *
	 * Constraint:
	 *     (left=VLSBinary_VLSXnor_1_0_0_3_0 right=VLSUnitaryFormula)
	 */
	protected void sequence_VLSBinary(ISerializationContext context, VLSXnor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_XNOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_XNOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_XNOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_XNOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSBinaryAccess().getVLSXnorLeftAction_1_0_0_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSBinaryAccess().getRightVLSUnitaryFormulaParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSTerm
	 *     VLSCommentTerm returns VLSTerm
	 *
	 * Constraint:
	 *     comment=SINGLE_COMMENT
	 */
	protected void sequence_VLSCommentTerm(ISerializationContext context, VLSTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_TERM__COMMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_TERM__COMMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSCommentTermAccess().getCommentSINGLE_COMMENTTerminalRuleCall_0(), semanticObject.getComment());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSComment returns VLSComment
	 *
	 * Constraint:
	 *     comment=SINGLE_COMMENT
	 */
	protected void sequence_VLSComment(ISerializationContext context, VLSComment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_COMMENT__COMMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_COMMENT__COMMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSCommentAccess().getCommentSINGLE_COMMENTTerminalRuleCall_0(), semanticObject.getComment());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSConfirmations returns VLSFiniteModel
	 *
	 * Constraint:
	 *     {VLSFiniteModel}
	 */
	protected void sequence_VLSConfirmations(ISerializationContext context, VLSFiniteModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSConfirmations returns VLSSatisfiable
	 *
	 * Constraint:
	 *     {VLSSatisfiable}
	 */
	protected void sequence_VLSConfirmations(ISerializationContext context, VLSSatisfiable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSConfirmations returns VLSTrying
	 *
	 * Constraint:
	 *     name=LITERAL
	 */
	protected void sequence_VLSConfirmations(ISerializationContext context, VLSTrying semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_TRYING__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_TRYING__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSConfirmationsAccess().getNameLITERALTerminalRuleCall_2_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSConfirmations returns VLSWarning
	 *
	 * Constraint:
	 *     {VLSWarning}
	 */
	protected void sequence_VLSConfirmations(ISerializationContext context, VLSWarning semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSDoubleQuote
	 *     VLSTerm returns VLSDoubleQuote
	 *     VLSBinary returns VLSDoubleQuote
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSDoubleQuote
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSDoubleQuote
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSDoubleQuote
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSDoubleQuote
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSDoubleQuote
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSDoubleQuote
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSDoubleQuote
	 *     VLSBinary.VLSOr_1_2_0 returns VLSDoubleQuote
	 *     VLSUnitaryFormula returns VLSDoubleQuote
	 *     VLSUnaryInfix returns VLSDoubleQuote
	 *     VLSUnaryInfix.VLSInequality_1_0_0_0 returns VLSDoubleQuote
	 *     VLSUnaryInfix.VLSEquality_1_0_1_0 returns VLSDoubleQuote
	 *     VLSUnaryInfix.VLSAssignment_1_0_2_0 returns VLSDoubleQuote
	 *     VLSAtomic returns VLSDoubleQuote
	 *     VLSFofTerm returns VLSDoubleQuote
	 *     VLSDefinedTerm returns VLSDoubleQuote
	 *
	 * Constraint:
	 *     value=DOUBLE_QUOTE
	 */
	protected void sequence_VLSDefinedTerm(ISerializationContext context, VLSDoubleQuote semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_DEFINED_TERM__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_DEFINED_TERM__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSDefinedTermAccess().getValueDOUBLE_QUOTETerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSInt
	 *     VLSTerm returns VLSInt
	 *     VLSBinary returns VLSInt
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSInt
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSInt
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSInt
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSInt
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSInt
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSInt
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSInt
	 *     VLSBinary.VLSOr_1_2_0 returns VLSInt
	 *     VLSUnitaryFormula returns VLSInt
	 *     VLSUnaryInfix returns VLSInt
	 *     VLSUnaryInfix.VLSInequality_1_0_0_0 returns VLSInt
	 *     VLSUnaryInfix.VLSEquality_1_0_1_0 returns VLSInt
	 *     VLSUnaryInfix.VLSAssignment_1_0_2_0 returns VLSInt
	 *     VLSAtomic returns VLSInt
	 *     VLSFofTerm returns VLSInt
	 *     VLSDefinedTerm returns VLSInt
	 *
	 * Constraint:
	 *     value=SIGNED_LITERAL
	 */
	protected void sequence_VLSDefinedTerm(ISerializationContext context, VLSInt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_DEFINED_TERM__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_DEFINED_TERM__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSDefinedTermAccess().getValueSIGNED_LITERALTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSExistentialQuantifier
	 *     VLSTerm returns VLSExistentialQuantifier
	 *     VLSBinary returns VLSExistentialQuantifier
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSExistentialQuantifier
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSExistentialQuantifier
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSExistentialQuantifier
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSExistentialQuantifier
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSExistentialQuantifier
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSExistentialQuantifier
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSExistentialQuantifier
	 *     VLSBinary.VLSOr_1_2_0 returns VLSExistentialQuantifier
	 *     VLSUnitaryFormula returns VLSExistentialQuantifier
	 *     VLSExistentialQuantifier returns VLSExistentialQuantifier
	 *
	 * Constraint:
	 *     (
	 *         (variables+=VLSVariable | variables+=VLSVariableDeclaration) 
	 *         variables+=VLSVariable? 
	 *         (variables+=VLSVariableDeclaration? variables+=VLSVariable?)* 
	 *         operand=VLSUnitaryFormula
	 *     )
	 */
	protected void sequence_VLSExistentialQuantifier(ISerializationContext context, VLSExistentialQuantifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSFofFormula returns VLSFofFormula
	 *
	 * Constraint:
	 *     ((name=LOWER_WORD_ID | name=SIGNED_LITERAL | name=SINGLE_QUOTE) fofRole=VLSRole fofFormula=VLSTerm annotations=VLSAnnotation?)
	 */
	protected void sequence_VLSFofFormula(ISerializationContext context, VLSFofFormula semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSFofTerm returns VLSFunctionAsTerm
	 *     VLSFunctionAsTerm returns VLSFunctionAsTerm
	 *
	 * Constraint:
	 *     ((functor=LOWER_WORD_ID | functor=SINGLE_QUOTE | functor=DOLLAR_ID | functor=DOUBLE_DOLLAR_ID) (terms+=VLSFofTerm terms+=VLSFofTerm*)?)
	 */
	protected void sequence_VLSFunctionAsTerm(ISerializationContext context, VLSFunctionAsTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSOtherDeclaration
	 *     VLSDeclaration returns VLSOtherDeclaration
	 *     VLSOtherDeclaration returns VLSOtherDeclaration
	 *
	 * Constraint:
	 *     (name=VLSAtomicConstant type=VLSTypeDef)
	 */
	protected void sequence_VLSOtherDeclaration(ISerializationContext context, VLSOtherDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_OTHER_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_OTHER_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_DECLARATION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSOtherDeclarationAccess().getNameVLSAtomicConstantParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVLSOtherDeclarationAccess().getTypeVLSTypeDefParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffFormula returns VLSTffFormula
	 *
	 * Constraint:
	 *     (name=VLSTffName tffRole=VLSRole fofFormula=VLSTffTerm annotations=VLSAnnotation?)
	 */
	protected void sequence_VLSTffFormula(ISerializationContext context, VLSTffFormula semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSTypeDef returns VLSTypeDef
	 *
	 * Constraint:
	 *     (typeSig=VLSUnitaryTerm mapsTo=VLSAtomicConstant?)
	 */
	protected void sequence_VLSTypeDef(ISerializationContext context, VLSTypeDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSAssignment
	 *     VLSTerm returns VLSAssignment
	 *     VLSBinary returns VLSAssignment
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSAssignment
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSAssignment
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSAssignment
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSAssignment
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSAssignment
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSAssignment
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSAssignment
	 *     VLSBinary.VLSOr_1_2_0 returns VLSAssignment
	 *     VLSUnitaryFormula returns VLSAssignment
	 *     VLSUnaryInfix returns VLSAssignment
	 *
	 * Constraint:
	 *     (left=VLSUnaryInfix_VLSAssignment_1_0_2_0 right=VLSAtomic)
	 */
	protected void sequence_VLSUnaryInfix(ISerializationContext context, VLSAssignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_ASSIGNMENT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_ASSIGNMENT__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_ASSIGNMENT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_ASSIGNMENT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSUnaryInfixAccess().getVLSAssignmentLeftAction_1_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSUnaryInfixAccess().getRightVLSAtomicParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSEquality
	 *     VLSTerm returns VLSEquality
	 *     VLSBinary returns VLSEquality
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSEquality
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSEquality
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSEquality
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSEquality
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSEquality
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSEquality
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSEquality
	 *     VLSBinary.VLSOr_1_2_0 returns VLSEquality
	 *     VLSUnitaryFormula returns VLSEquality
	 *     VLSUnaryInfix returns VLSEquality
	 *
	 * Constraint:
	 *     (left=VLSUnaryInfix_VLSEquality_1_0_1_0 right=VLSAtomic)
	 */
	protected void sequence_VLSUnaryInfix(ISerializationContext context, VLSEquality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_EQUALITY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_EQUALITY__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_EQUALITY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_EQUALITY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSUnaryInfixAccess().getVLSEqualityLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSUnaryInfixAccess().getRightVLSAtomicParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSInequality
	 *     VLSTerm returns VLSInequality
	 *     VLSBinary returns VLSInequality
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSInequality
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSInequality
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSInequality
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSInequality
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSInequality
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSInequality
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSInequality
	 *     VLSBinary.VLSOr_1_2_0 returns VLSInequality
	 *     VLSUnitaryFormula returns VLSInequality
	 *     VLSUnaryInfix returns VLSInequality
	 *
	 * Constraint:
	 *     (left=VLSUnaryInfix_VLSInequality_1_0_0_0 right=VLSAtomic)
	 */
	protected void sequence_VLSUnaryInfix(ISerializationContext context, VLSInequality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_INEQUALITY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_INEQUALITY__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_INEQUALITY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_INEQUALITY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSUnaryInfixAccess().getVLSInequalityLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSUnaryInfixAccess().getRightVLSAtomicParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSUnaryNegation
	 *     VLSTerm returns VLSUnaryNegation
	 *     VLSBinary returns VLSUnaryNegation
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSUnaryNegation
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSUnaryNegation
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSUnaryNegation
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSUnaryNegation
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSUnaryNegation
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSUnaryNegation
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSUnaryNegation
	 *     VLSBinary.VLSOr_1_2_0 returns VLSUnaryNegation
	 *     VLSUnitaryFormula returns VLSUnaryNegation
	 *     VLSUnaryNegation returns VLSUnaryNegation
	 *
	 * Constraint:
	 *     operand=VLSUnitaryFormula
	 */
	protected void sequence_VLSUnaryNegation(ISerializationContext context, VLSUnaryNegation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_UNARY_NEGATION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_UNARY_NEGATION__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSUnaryNegationAccess().getOperandVLSUnitaryFormulaParserRuleCall_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSUnitaryTerm returns VLSTypeDef
	 *
	 * Constraint:
	 *     (initType=VLSAtomic nextType=VLSAtomicConstant*)
	 */
	protected void sequence_VLSUnitaryTerm(ISerializationContext context, VLSTypeDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSUniversalQuantifier
	 *     VLSTerm returns VLSUniversalQuantifier
	 *     VLSBinary returns VLSUniversalQuantifier
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSUniversalQuantifier
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSUniversalQuantifier
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSUniversalQuantifier
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSUniversalQuantifier
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSUniversalQuantifier
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSUniversalQuantifier
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSUniversalQuantifier
	 *     VLSBinary.VLSOr_1_2_0 returns VLSUniversalQuantifier
	 *     VLSUnitaryFormula returns VLSUniversalQuantifier
	 *     VLSUniversalQuantifier returns VLSUniversalQuantifier
	 *
	 * Constraint:
	 *     (
	 *         (variables+=VLSVariable | variables+=VLSVariableDeclaration) 
	 *         variables+=VLSVariableDeclaration? 
	 *         (variables+=VLSVariable? variables+=VLSVariableDeclaration?)* 
	 *         operand=VLSUnitaryFormula
	 *     )
	 */
	protected void sequence_VLSUniversalQuantifier(ISerializationContext context, VLSUniversalQuantifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSVariableDeclaration
	 *     VLSDeclaration returns VLSVariableDeclaration
	 *     VLSVariableDeclaration returns VLSVariableDeclaration
	 *
	 * Constraint:
	 *     (name=VLSVariable type=VLSTypeDef)
	 */
	protected void sequence_VLSVariableDeclaration(ISerializationContext context, VLSVariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_VARIABLE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_VARIABLE_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_DECLARATION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSVariableDeclarationAccess().getNameVLSVariableParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVLSVariableDeclarationAccess().getTypeVLSTypeDefParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTffTerm returns VLSVariable
	 *     VLSTerm returns VLSVariable
	 *     VLSBinary returns VLSVariable
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSVariable
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSVariable
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSVariable
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSVariable
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSVariable
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSVariable
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSVariable
	 *     VLSBinary.VLSOr_1_2_0 returns VLSVariable
	 *     VLSUnitaryFormula returns VLSVariable
	 *     VLSUnaryInfix returns VLSVariable
	 *     VLSUnaryInfix.VLSInequality_1_0_0_0 returns VLSVariable
	 *     VLSUnaryInfix.VLSEquality_1_0_1_0 returns VLSVariable
	 *     VLSUnaryInfix.VLSAssignment_1_0_2_0 returns VLSVariable
	 *     VLSAtomic returns VLSVariable
	 *     VLSVariable returns VLSVariable
	 *     VLSFofTerm returns VLSVariable
	 *
	 * Constraint:
	 *     name=UPPER_WORD_ID
	 */
	protected void sequence_VLSVariable(ISerializationContext context, VLSVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSVariableAccess().getNameUPPER_WORD_IDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VampireModel returns VampireModel
	 *
	 * Constraint:
	 *     (comments+=VLSComment | confirmations+=VLSConfirmations | formulas+=VLSFofFormula | tfformulas+=VLSTffFormula)+
	 */
	protected void sequence_VampireModel(ISerializationContext context, VampireModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
