/*
 * generated by Xtext 2.21.0
 */
package org.eclipse.viatra.solver.language.parser.antlr;

import static org.eclipse.viatra.solver.language.parser.antlr.internal.InternalSolverLanguageParser.RULE_FULL_STOP;
import static org.eclipse.viatra.solver.language.parser.antlr.internal.InternalSolverLanguageParser.RULE_ID;
import static org.eclipse.viatra.solver.language.parser.antlr.internal.InternalSolverLanguageParser.RULE_INT;
import static org.eclipse.viatra.solver.language.parser.antlr.internal.InternalSolverLanguageParser.RULE_ML_COMMENT;
import static org.eclipse.viatra.solver.language.parser.antlr.internal.InternalSolverLanguageParser.RULE_QUOTED_ID;
import static org.eclipse.viatra.solver.language.parser.antlr.internal.InternalSolverLanguageParser.RULE_REFLEXIVE_TRANSITIVE_CLOSURE;
import static org.eclipse.viatra.solver.language.parser.antlr.internal.InternalSolverLanguageParser.RULE_SL_COMMENT;
import static org.eclipse.viatra.solver.language.parser.antlr.internal.InternalSolverLanguageParser.RULE_TRANSITIVE_CLOSURE;
import static org.eclipse.viatra.solver.language.parser.antlr.internal.InternalSolverLanguageParser.RULE_WS;

import java.util.Map;

import org.antlr.runtime.Token;
import org.antlr.runtime.TokenSource;
import org.eclipse.xtext.parser.antlr.ITokenDefProvider;
import org.eclipse.xtext.parser.antlr.TokenAcceptor;

public class SolverLanguageTokenSource implements TokenSource {
	private TokenSource delegate;

	private final TokenAcceptor acceptor = new TokenAcceptor();

	private int lastTokenId = -1;
	private int plusTokenId = -1;
	private int starTokenId = -1;
	private int dotTokenId = -1;
	private int openParenTokenId = -1;

	public SolverLanguageTokenSource(TokenSource delegate) {
		this.delegate = delegate;
	}

	@Override
	public String getSourceName() {
		return "[SolverLanguageSyntheticTokenTokenSource] " + delegate.getSourceName();
	}

	@Override
	public Token nextToken() {
		Token token = internalNextToken();
		lastTokenId = token.getType();
		return token;
	}

	protected Token internalNextToken() {
		if (acceptor.hasNext()) {
			return acceptor.next();
		}
		Token token = delegate.nextToken();
		int type = token.getType();
		if (type == plusTokenId) {
			if ((lastTokenId == RULE_ID || lastTokenId == RULE_QUOTED_ID)
					&& peekUntilVisible().getType() == openParenTokenId) {
				token.setType(RULE_TRANSITIVE_CLOSURE);
			}
		} else if (type == starTokenId) {
			if ((lastTokenId == RULE_ID || lastTokenId == RULE_QUOTED_ID)
					&& peekUntilVisible().getType() == openParenTokenId) {
				token.setType(RULE_REFLEXIVE_TRANSITIVE_CLOSURE);
			}
		} else if (type == dotTokenId) {
			if ((lastTokenId != RULE_ID && lastTokenId != RULE_INT) || peekToken().getType() != lastTokenId) {
				token.setType(RULE_FULL_STOP);
			}
		}
		return token;
	}

	protected Token peekUntilVisible() {
		Token followingToken = null;
		do {
			followingToken = peekToken();
		} while (isHidden(followingToken.getType()));
		return followingToken;
	}

	protected Token peekToken() {
		Token followingToken = delegate.nextToken();
		acceptor.accept(followingToken);
		return followingToken;
	}

	protected boolean isHidden(int tokenType) {
		return tokenType == RULE_WS || tokenType == RULE_SL_COMMENT || tokenType == RULE_ML_COMMENT;
	}

	public void initializeTokenDefsFrom(ITokenDefProvider provider) {
		for (Map.Entry<Integer, String> entry : provider.getTokenDefMap().entrySet()) {
			switch (entry.getValue()) {
			case "'+'":
				plusTokenId = entry.getKey();
				break;
			case "'*'":
				starTokenId = entry.getKey();
				break;
			case "'.'":
				dotTokenId = entry.getKey();
				break;
			case "'('":
				openParenTokenId = entry.getKey();
				break;
			}
		}
		if (plusTokenId == -1) {
			throw new IllegalStateException("Token '+' was not found");
		}
		if (starTokenId == -1) {
			throw new IllegalStateException("Token '*' was not found");
		}
		if (dotTokenId == -1) {
			throw new IllegalStateException("Token '.' was not found");
		}
		if (openParenTokenId == -1) {
			throw new IllegalStateException("Token '(' was not found");
		}
	}
}
