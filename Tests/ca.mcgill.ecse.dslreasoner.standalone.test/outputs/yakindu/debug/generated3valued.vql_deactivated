import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Pseudostate class".
 */
private pattern mustInstanceOfPseudostate_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pseudostate class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPseudostate_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pseudostate class");
}

/**
 * An element may be an instance of type "Pseudostate class".
 */
private pattern mayInstanceOfPseudostate_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPseudostate_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPseudostate_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPseudostate_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Vertex class".
 */
private pattern mustInstanceOfVertex_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Vertex class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVertex_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Vertex class");
}

/**
 * An element may be an instance of type "Vertex class".
 */
private pattern mayInstanceOfVertex_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewVertex_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewVertex_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVertex_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Region class".
 */
private pattern mustInstanceOfRegion_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Region class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegion_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Region class");
}

/**
 * An element may be an instance of type "Region class".
 */
private pattern mayInstanceOfRegion_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegion_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegion_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegion_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Transition class".
 */
private pattern mustInstanceOfTransition_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Transition class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewTransition_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Transition class");
}

/**
 * An element may be an instance of type "Transition class".
 */
private pattern mayInstanceOfTransition_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewTransition_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewTransition_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfTransition_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statechart class".
 */
private pattern mustInstanceOfStatechart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statechart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatechart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statechart class");
}

/**
 * An element may be an instance of type "Statechart class".
 */
private pattern mayInstanceOfStatechart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatechart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Entry class".
 */
private pattern mustInstanceOfEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Entry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Entry class");
}

/**
 * An element may be an instance of type "Entry class".
 */
private pattern mayInstanceOfEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Synchronization class".
 */
private pattern mustInstanceOfSynchronization_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Synchronization class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSynchronization_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Synchronization class");
}

/**
 * An element may be an instance of type "Synchronization class".
 */
private pattern mayInstanceOfSynchronization_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewSynchronization_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewSynchronization_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSynchronization_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "State class".
 */
private pattern mustInstanceOfState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"State class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewState_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"State class");
}

/**
 * An element may be an instance of type "State class".
 */
private pattern mayInstanceOfState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find scopeDisallowsNewState_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find scopeDisallowsNewState_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularState class".
 */
private pattern mustInstanceOfRegularState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularState class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularState_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularState class");
}

/**
 * An element may be an instance of type "RegularState class".
 */
private pattern mayInstanceOfRegularState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularState_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularState_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeElement class".
 */
private pattern mustInstanceOfCompositeElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeElement class");
}

/**
 * An element may be an instance of type "CompositeElement class".
 */
private pattern mayInstanceOfCompositeElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCompositeElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Choice class".
 */
private pattern mustInstanceOfChoice_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Choice class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewChoice_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Choice class");
}

/**
 * An element may be an instance of type "Choice class".
 */
private pattern mayInstanceOfChoice_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewChoice_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewChoice_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfChoice_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Exit class".
 */
private pattern mustInstanceOfExit_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Exit class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExit_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Exit class");
}

/**
 * An element may be an instance of type "Exit class".
 */
private pattern mayInstanceOfExit_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewExit_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewExit_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExit_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FinalState class".
 */
private pattern mustInstanceOfFinalState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FinalState class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFinalState_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FinalState class");
}

/**
 * An element may be an instance of type "FinalState class".
 */
private pattern mayInstanceOfFinalState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFinalState_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFinalState_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFinalState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statechart class DefinedPart".
 */
private pattern mustInstanceOfStatechart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statechart class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatechart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statechart class DefinedPart");
}

/**
 * An element may be an instance of type "Statechart class DefinedPart".
 */
private pattern mayInstanceOfStatechart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfStatechart_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statechart class UndefinedPart".
 */
private pattern mustInstanceOfStatechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statechart class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statechart class UndefinedPart");
}

/**
 * An element may be an instance of type "Statechart class UndefinedPart".
 */
private pattern mayInstanceOfStatechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatechart_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeElement class DefinedPart".
 */
private pattern mustInstanceOfCompositeElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeElement class DefinedPart");
}

/**
 * An element may be an instance of type "CompositeElement class DefinedPart".
 */
private pattern mayInstanceOfCompositeElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfCompositeElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeElement class UndefinedPart".
 */
private pattern mustInstanceOfCompositeElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeElement class UndefinedPart");
}

/**
 * An element may be an instance of type "CompositeElement class UndefinedPart".
 */
private pattern mayInstanceOfCompositeElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []incomingTransitions reference Vertex(source,target)
 */
private pattern mustInRelationincomingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incomingTransitions reference Vertex");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>incomingTransitions reference Vertex(source,target)
 */
private pattern mayInRelationincomingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVertex_class(problem,interpretation,source);
	find mayInstanceOfTransition_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationtarget_reference_Transition(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationincomingTransitions_reference_Vertex(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingTransitions reference Vertex(source,target)
 */
private pattern mustInRelationoutgoingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingTransitions reference Vertex");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingTransitions reference Vertex(source,target)
 */
private pattern mayInRelationoutgoingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVertex_class(problem,interpretation,source);
	find mayInstanceOfTransition_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationsource_reference_Transition(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []vertices reference Region(source,target)
 */
private pattern mustInRelationvertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"vertices reference Region");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>vertices reference Region(source,target)
 */
private pattern mayInRelationvertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRegion_class(problem,interpretation,source);
	find mayInstanceOfVertex_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvertices_reference_Region(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []target reference Transition(source,target)
 */
private pattern mustInRelationtarget_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"target reference Transition");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>target reference Transition(source,target)
 */
private pattern mayInRelationtarget_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTransition_class(problem,interpretation,source);
	find mayInstanceOfVertex_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtarget_reference_Transition(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtarget_reference_Transition(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []source reference Transition(source,target)
 */
private pattern mustInRelationsource_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"source reference Transition");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>source reference Transition(source,target)
 */
private pattern mayInRelationsource_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTransition_class(problem,interpretation,source);
	find mayInstanceOfVertex_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationsource_reference_Transition(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsource_reference_Transition(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []regions reference CompositeElement(source,target)
 */
private pattern mustInRelationregions_reference_CompositeElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"regions reference CompositeElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>regions reference CompositeElement(source,target)
 */
private pattern mayInRelationregions_reference_CompositeElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfCompositeElement_class(problem,interpretation,source);
	find mayInstanceOfRegion_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,source,target); }or
	
	{ find mustInRelationvertices_reference_Region(problem,interpretation,source,target); }or
	
	{ find mustInRelationregions_reference_CompositeElement(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_target_reference_Transition(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"target reference Transition");
	find mustInstanceOfTransition_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtarget_reference_Transition(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPseudostate_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVertex_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatechart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExit_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFinalState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatechart_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatechart_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Exit_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Exit class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfExit_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Exit_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Exit class");
	find mayInstanceOfExit_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FinalState_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FinalState class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfFinalState_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FinalState_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FinalState class");
	find mayInstanceOfFinalState_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Transition_class_by_outgoingTransitions_reference_Vertex_with_source_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Transition class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingTransitions reference Vertex");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"source reference Transition");
	find mustInstanceOfVertex_class(problem,interpretation,container);
	find mayInstanceOfTransition_class(problem,interpretation,newObject);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Transition_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Transition class");
	find mayInstanceOfTransition_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Region_class_by_regions_reference_CompositeElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Region class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"regions reference CompositeElement");
	find mustInstanceOfCompositeElement_class(problem,interpretation,container);
	find mayInstanceOfRegion_class(problem,interpretation,newObject);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Region_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Region class");
	find mayInstanceOfRegion_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Choice_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Choice class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfChoice_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Choice_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Choice class");
	find mayInstanceOfChoice_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Synchronization_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Synchronization class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfSynchronization_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Synchronization_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Synchronization class");
	find mayInstanceOfSynchronization_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statechart_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statechart class UndefinedPart");
	find mayInstanceOfStatechart_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Entry_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Entry class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfEntry_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Entry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Entry class");
	find mayInstanceOfEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_State_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"State class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfState_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_State_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"State class");
	find mayInstanceOfState_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Exit_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_FinalState_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
}
pattern refineTypeTo_Transition_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
}
pattern refineTypeTo_Region_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
}
pattern refineTypeTo_Choice_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_Synchronization_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_Statechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStatechart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
}
pattern refineTypeTo_Entry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_State_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfState_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfState_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_incomingTransitions_reference_Vertex_and_target_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incomingTransitions reference Vertex");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"target reference Transition");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVertex_class(problem,interpretation,from);
	find mustInstanceOfTransition_class(problem,interpretation,to);
	find mayInRelationincomingTransitions_reference_Vertex(problem,interpretation,from,to);
	neg find mustInRelationincomingTransitions_reference_Vertex(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FileSystem class".
 */
private pattern mustInstanceOfFileSystem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FileSystem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFileSystem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FileSystem class");
}

/**
 * An element may be an instance of type "FileSystem class".
 */
private pattern mayInstanceOfFileSystem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFileSystem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFileSystem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFileSystem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FSObject class".
 */
private pattern mustInstanceOfFSObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FSObject class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFSObject_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FSObject class");
}

/**
 * An element may be an instance of type "FSObject class".
 */
private pattern mayInstanceOfFSObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewFSObject_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewFSObject_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFSObject_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Dir class".
 */
private pattern mustInstanceOfDir_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Dir class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewDir_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Dir class");
}

/**
 * An element may be an instance of type "Dir class".
 */
private pattern mayInstanceOfDir_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewDir_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewDir_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfDir_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "File class".
 */
private pattern mustInstanceOfFile_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"File class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFile_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"File class");
}

/**
 * An element may be an instance of type "File class".
 */
private pattern mayInstanceOfFile_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewFile_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewFile_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFile_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Model class".
 */
private pattern mustInstanceOfModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Model class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Model class");
}

/**
 * An element may be an instance of type "Model class".
 */
private pattern mayInstanceOfModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Model class DefinedPart".
 */
private pattern mustInstanceOfModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Model class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Model class DefinedPart");
}

/**
 * An element may be an instance of type "Model class DefinedPart".
 */
private pattern mayInstanceOfModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Model class UndefinedPart".
 */
private pattern mustInstanceOfModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Model class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Model class UndefinedPart");
}

/**
 * An element may be an instance of type "Model class UndefinedPart".
 */
private pattern mayInstanceOfModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []root reference FileSystem(source,target)
 */
private pattern mustInRelationroot_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"root reference FileSystem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>root reference FileSystem(source,target)
 */
private pattern mayInRelationroot_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFileSystem_class(problem,interpretation,source);
	find mayInstanceOfDir_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationroot_reference_FileSystem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationroot_reference_FileSystem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []live reference FileSystem(source,target)
 */
private pattern mustInRelationlive_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"live reference FileSystem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>live reference FileSystem(source,target)
 */
private pattern mayInRelationlive_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFileSystem_class(problem,interpretation,source);
	find mayInstanceOfFSObject_class(problem,interpretation,target);
} or {
	find mustInRelationlive_reference_FileSystem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FSObject(source,target)
 */
private pattern mustInRelationparent_reference_FSObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FSObject");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FSObject(source,target)
 */
private pattern mayInRelationparent_reference_FSObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFSObject_class(problem,interpretation,source);
	find mayInstanceOfDir_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FSObject(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FSObject(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []contents reference Dir(source,target)
 */
private pattern mustInRelationcontents_reference_Dir(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"contents reference Dir");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>contents reference Dir(source,target)
 */
private pattern mayInRelationcontents_reference_Dir(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfDir_class(problem,interpretation,source);
	find mayInstanceOfFSObject_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FSObject(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationcontents_reference_Dir(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []filesystems reference Model(source,target)
 */
private pattern mustInRelationfilesystems_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"filesystems reference Model");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>filesystems reference Model(source,target)
 */
private pattern mayInRelationfilesystems_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfModel_class(problem,interpretation,source);
	find mayInstanceOfFileSystem_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfilesystems_reference_Model(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfilesystems_reference_Model(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []otherFSObjects reference Model(source,target)
 */
private pattern mustInRelationotherFSObjects_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"otherFSObjects reference Model");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>otherFSObjects reference Model(source,target)
 */
private pattern mayInRelationotherFSObjects_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfModel_class(problem,interpretation,source);
	find mayInstanceOfFSObject_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationotherFSObjects_reference_Model(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationroot_reference_FileSystem(problem,interpretation,source,target); }or
	
	{ find mustInRelationcontents_reference_Dir(problem,interpretation,source,target); }or
	
	{ find mustInRelationfilesystems_reference_Model(problem,interpretation,source,target); }or
	
	{ find mustInRelationotherFSObjects_reference_Model(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_root_reference_FileSystem(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"root reference FileSystem");
	find mustInstanceOfFileSystem_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationroot_reference_FileSystem(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_filesystems_reference_Model(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"filesystems reference Model");
	find mustInstanceOfModel_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationfilesystems_reference_Model(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFile_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfDir_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFileSystem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFSObject_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Model_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Model class UndefinedPart");
	find mayInstanceOfModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dir_class_by_root_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dir class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"root reference FileSystem");
	find mustInstanceOfFileSystem_class(problem,interpretation,container);
	find mayInstanceOfDir_class(problem,interpretation,newObject);
	find mayInRelationroot_reference_FileSystem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dir_class_by_contents_reference_Dir_with_parent_reference_FSObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dir class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"contents reference Dir");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FSObject");
	find mustInstanceOfDir_class(problem,interpretation,container);
	find mayInstanceOfDir_class(problem,interpretation,newObject);
	find mayInRelationcontents_reference_Dir(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dir_class_by_otherFSObjects_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dir class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"otherFSObjects reference Model");
	find mustInstanceOfModel_class(problem,interpretation,container);
	find mayInstanceOfDir_class(problem,interpretation,newObject);
	find mayInRelationotherFSObjects_reference_Model(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dir_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dir class");
	find mayInstanceOfDir_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_File_class_by_contents_reference_Dir_with_parent_reference_FSObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"File class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"contents reference Dir");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FSObject");
	find mustInstanceOfDir_class(problem,interpretation,container);
	find mayInstanceOfFile_class(problem,interpretation,newObject);
	find mayInRelationcontents_reference_Dir(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_File_class_by_otherFSObjects_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"File class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"otherFSObjects reference Model");
	find mustInstanceOfModel_class(problem,interpretation,container);
	find mayInstanceOfFile_class(problem,interpretation,newObject);
	find mayInRelationotherFSObjects_reference_Model(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_File_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"File class");
	find mayInstanceOfFile_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FileSystem_class_by_filesystems_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FileSystem class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"filesystems reference Model");
	find mustInstanceOfModel_class(problem,interpretation,container);
	find mayInstanceOfFileSystem_class(problem,interpretation,newObject);
	find mayInRelationfilesystems_reference_Model(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FileSystem_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FileSystem class");
	find mayInstanceOfFileSystem_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Model_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
}
pattern refineTypeTo_Dir_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
}
pattern refineTypeTo_File_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
}
pattern refineTypeTo_FileSystem_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_live_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"live reference FileSystem");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFileSystem_class(problem,interpretation,from);
	find mustInstanceOfFSObject_class(problem,interpretation,to);
	find mayInRelationlive_reference_FileSystem(problem,interpretation,from,to);
	neg find mustInRelationlive_reference_FileSystem(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FileSystem class".
 */
private pattern mustInstanceOfFileSystem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FileSystem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFileSystem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FileSystem class");
}

/**
 * An element may be an instance of type "FileSystem class".
 */
private pattern mayInstanceOfFileSystem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewFileSystem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewFileSystem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFileSystem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FSObject class".
 */
private pattern mustInstanceOfFSObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FSObject class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFSObject_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FSObject class");
}

/**
 * An element may be an instance of type "FSObject class".
 */
private pattern mayInstanceOfFSObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewFSObject_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewFSObject_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFSObject_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Dir class".
 */
private pattern mustInstanceOfDir_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Dir class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewDir_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Dir class");
}

/**
 * An element may be an instance of type "Dir class".
 */
private pattern mayInstanceOfDir_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewDir_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewDir_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfDir_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "File class".
 */
private pattern mustInstanceOfFile_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"File class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFile_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"File class");
}

/**
 * An element may be an instance of type "File class".
 */
private pattern mayInstanceOfFile_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewFile_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewFile_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFile_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Model class".
 */
private pattern mustInstanceOfModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Model class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Model class");
}

/**
 * An element may be an instance of type "Model class".
 */
private pattern mayInstanceOfModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Model class DefinedPart".
 */
private pattern mustInstanceOfModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Model class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Model class DefinedPart");
}

/**
 * An element may be an instance of type "Model class DefinedPart".
 */
private pattern mayInstanceOfModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Model class UndefinedPart".
 */
private pattern mustInstanceOfModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Model class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Model class UndefinedPart");
}

/**
 * An element may be an instance of type "Model class UndefinedPart".
 */
private pattern mayInstanceOfModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []root reference FileSystem(source,target)
 */
private pattern mustInRelationroot_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"root reference FileSystem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>root reference FileSystem(source,target)
 */
private pattern mayInRelationroot_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFileSystem_class(problem,interpretation,source);
	find mayInstanceOfDir_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationroot_reference_FileSystem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationroot_reference_FileSystem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []live reference FileSystem(source,target)
 */
private pattern mustInRelationlive_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"live reference FileSystem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>live reference FileSystem(source,target)
 */
private pattern mayInRelationlive_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFileSystem_class(problem,interpretation,source);
	find mayInstanceOfFSObject_class(problem,interpretation,target);
} or {
	find mustInRelationlive_reference_FileSystem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FSObject(source,target)
 */
private pattern mustInRelationparent_reference_FSObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FSObject");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FSObject(source,target)
 */
private pattern mayInRelationparent_reference_FSObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFSObject_class(problem,interpretation,source);
	find mayInstanceOfDir_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FSObject(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FSObject(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []contents reference Dir(source,target)
 */
private pattern mustInRelationcontents_reference_Dir(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"contents reference Dir");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>contents reference Dir(source,target)
 */
private pattern mayInRelationcontents_reference_Dir(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfDir_class(problem,interpretation,source);
	find mayInstanceOfFSObject_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FSObject(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationcontents_reference_Dir(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []filesystems reference Model(source,target)
 */
private pattern mustInRelationfilesystems_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"filesystems reference Model");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>filesystems reference Model(source,target)
 */
private pattern mayInRelationfilesystems_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfModel_class(problem,interpretation,source);
	find mayInstanceOfFileSystem_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfilesystems_reference_Model(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfilesystems_reference_Model(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []otherFSObjects reference Model(source,target)
 */
private pattern mustInRelationotherFSObjects_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"otherFSObjects reference Model");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>otherFSObjects reference Model(source,target)
 */
private pattern mayInRelationotherFSObjects_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfModel_class(problem,interpretation,source);
	find mayInstanceOfFSObject_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationotherFSObjects_reference_Model(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationroot_reference_FileSystem(problem,interpretation,source,target); }or
	
	{ find mustInRelationcontents_reference_Dir(problem,interpretation,source,target); }or
	
	{ find mustInRelationfilesystems_reference_Model(problem,interpretation,source,target); }or
	
	{ find mustInRelationotherFSObjects_reference_Model(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_root_reference_FileSystem(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"root reference FileSystem");
	find mustInstanceOfFileSystem_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationroot_reference_FileSystem(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_filesystems_reference_Model(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"filesystems reference Model");
	find mustInstanceOfModel_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationfilesystems_reference_Model(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFile_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfDir_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFileSystem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFSObject_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Model_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Model class UndefinedPart");
	find mayInstanceOfModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_File_class_by_contents_reference_Dir_with_parent_reference_FSObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"File class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"contents reference Dir");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FSObject");
	find mustInstanceOfDir_class(problem,interpretation,container);
	find mayInstanceOfFile_class(problem,interpretation,newObject);
	find mayInRelationcontents_reference_Dir(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_File_class_by_otherFSObjects_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"File class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"otherFSObjects reference Model");
	find mustInstanceOfModel_class(problem,interpretation,container);
	find mayInstanceOfFile_class(problem,interpretation,newObject);
	find mayInRelationotherFSObjects_reference_Model(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_File_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"File class");
	find mayInstanceOfFile_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dir_class_by_root_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dir class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"root reference FileSystem");
	find mustInstanceOfFileSystem_class(problem,interpretation,container);
	find mayInstanceOfDir_class(problem,interpretation,newObject);
	find mayInRelationroot_reference_FileSystem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dir_class_by_contents_reference_Dir_with_parent_reference_FSObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dir class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"contents reference Dir");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FSObject");
	find mustInstanceOfDir_class(problem,interpretation,container);
	find mayInstanceOfDir_class(problem,interpretation,newObject);
	find mayInRelationcontents_reference_Dir(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dir_class_by_otherFSObjects_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dir class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"otherFSObjects reference Model");
	find mustInstanceOfModel_class(problem,interpretation,container);
	find mayInstanceOfDir_class(problem,interpretation,newObject);
	find mayInRelationotherFSObjects_reference_Model(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dir_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dir class");
	find mayInstanceOfDir_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FileSystem_class_by_filesystems_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FileSystem class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"filesystems reference Model");
	find mustInstanceOfModel_class(problem,interpretation,container);
	find mayInstanceOfFileSystem_class(problem,interpretation,newObject);
	find mayInRelationfilesystems_reference_Model(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FileSystem_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FileSystem class");
	find mayInstanceOfFileSystem_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Model_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
}
pattern refineTypeTo_File_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
}
pattern refineTypeTo_Dir_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
}
pattern refineTypeTo_FileSystem_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_live_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"live reference FileSystem");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFileSystem_class(problem,interpretation,from);
	find mustInstanceOfFSObject_class(problem,interpretation,to);
	find mayInRelationlive_reference_FileSystem(problem,interpretation,from,to);
	neg find mustInRelationlive_reference_FileSystem(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Pseudostate class".
 */
private pattern mustInstanceOfPseudostate_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pseudostate class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPseudostate_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pseudostate class");
}

/**
 * An element may be an instance of type "Pseudostate class".
 */
private pattern mayInstanceOfPseudostate_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find scopeDisallowsNewPseudostate_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find scopeDisallowsNewPseudostate_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPseudostate_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Vertex class".
 */
private pattern mustInstanceOfVertex_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Vertex class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVertex_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Vertex class");
}

/**
 * An element may be an instance of type "Vertex class".
 */
private pattern mayInstanceOfVertex_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find scopeDisallowsNewVertex_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find scopeDisallowsNewVertex_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVertex_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Region class".
 */
private pattern mustInstanceOfRegion_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Region class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegion_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Region class");
}

/**
 * An element may be an instance of type "Region class".
 */
private pattern mayInstanceOfRegion_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegion_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegion_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegion_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Transition class".
 */
private pattern mustInstanceOfTransition_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Transition class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewTransition_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Transition class");
}

/**
 * An element may be an instance of type "Transition class".
 */
private pattern mayInstanceOfTransition_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewTransition_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewTransition_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfTransition_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statechart class".
 */
private pattern mustInstanceOfStatechart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statechart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatechart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statechart class");
}

/**
 * An element may be an instance of type "Statechart class".
 */
private pattern mayInstanceOfStatechart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatechart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Entry class".
 */
private pattern mustInstanceOfEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Entry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Entry class");
}

/**
 * An element may be an instance of type "Entry class".
 */
private pattern mayInstanceOfEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find scopeDisallowsNewEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find scopeDisallowsNewEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Synchronization class".
 */
private pattern mustInstanceOfSynchronization_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Synchronization class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSynchronization_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Synchronization class");
}

/**
 * An element may be an instance of type "Synchronization class".
 */
private pattern mayInstanceOfSynchronization_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find scopeDisallowsNewSynchronization_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find scopeDisallowsNewSynchronization_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSynchronization_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "State class".
 */
private pattern mustInstanceOfState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"State class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewState_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"State class");
}

/**
 * An element may be an instance of type "State class".
 */
private pattern mayInstanceOfState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find scopeDisallowsNewState_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find scopeDisallowsNewState_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularState class".
 */
private pattern mustInstanceOfRegularState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularState class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularState_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularState class");
}

/**
 * An element may be an instance of type "RegularState class".
 */
private pattern mayInstanceOfRegularState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularState_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularState_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeElement class".
 */
private pattern mustInstanceOfCompositeElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeElement class");
}

/**
 * An element may be an instance of type "CompositeElement class".
 */
private pattern mayInstanceOfCompositeElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCompositeElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Choice class".
 */
private pattern mustInstanceOfChoice_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Choice class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewChoice_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Choice class");
}

/**
 * An element may be an instance of type "Choice class".
 */
private pattern mayInstanceOfChoice_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find scopeDisallowsNewChoice_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find scopeDisallowsNewChoice_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfChoice_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Exit class".
 */
private pattern mustInstanceOfExit_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Exit class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExit_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Exit class");
}

/**
 * An element may be an instance of type "Exit class".
 */
private pattern mayInstanceOfExit_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find scopeDisallowsNewExit_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find scopeDisallowsNewExit_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExit_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FinalState class".
 */
private pattern mustInstanceOfFinalState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FinalState class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFinalState_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FinalState class");
}

/**
 * An element may be an instance of type "FinalState class".
 */
private pattern mayInstanceOfFinalState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find scopeDisallowsNewFinalState_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find scopeDisallowsNewFinalState_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFinalState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statechart class DefinedPart".
 */
private pattern mustInstanceOfStatechart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statechart class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatechart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statechart class DefinedPart");
}

/**
 * An element may be an instance of type "Statechart class DefinedPart".
 */
private pattern mayInstanceOfStatechart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfStatechart_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statechart class UndefinedPart".
 */
private pattern mustInstanceOfStatechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statechart class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statechart class UndefinedPart");
}

/**
 * An element may be an instance of type "Statechart class UndefinedPart".
 */
private pattern mayInstanceOfStatechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatechart_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeElement class DefinedPart".
 */
private pattern mustInstanceOfCompositeElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeElement class DefinedPart");
}

/**
 * An element may be an instance of type "CompositeElement class DefinedPart".
 */
private pattern mayInstanceOfCompositeElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfCompositeElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeElement class UndefinedPart".
 */
private pattern mustInstanceOfCompositeElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeElement class UndefinedPart");
}

/**
 * An element may be an instance of type "CompositeElement class UndefinedPart".
 */
private pattern mayInstanceOfCompositeElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []incomingTransitions reference Vertex(source,target)
 */
private pattern mustInRelationincomingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incomingTransitions reference Vertex");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>incomingTransitions reference Vertex(source,target)
 */
private pattern mayInRelationincomingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVertex_class(problem,interpretation,source);
	find mayInstanceOfTransition_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationtarget_reference_Transition(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationincomingTransitions_reference_Vertex(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingTransitions reference Vertex(source,target)
 */
private pattern mustInRelationoutgoingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingTransitions reference Vertex");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingTransitions reference Vertex(source,target)
 */
private pattern mayInRelationoutgoingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVertex_class(problem,interpretation,source);
	find mayInstanceOfTransition_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationsource_reference_Transition(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []vertices reference Region(source,target)
 */
private pattern mustInRelationvertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"vertices reference Region");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>vertices reference Region(source,target)
 */
private pattern mayInRelationvertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRegion_class(problem,interpretation,source);
	find mayInstanceOfVertex_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvertices_reference_Region(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []target reference Transition(source,target)
 */
private pattern mustInRelationtarget_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"target reference Transition");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>target reference Transition(source,target)
 */
private pattern mayInRelationtarget_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTransition_class(problem,interpretation,source);
	find mayInstanceOfVertex_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtarget_reference_Transition(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtarget_reference_Transition(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []source reference Transition(source,target)
 */
private pattern mustInRelationsource_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"source reference Transition");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>source reference Transition(source,target)
 */
private pattern mayInRelationsource_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTransition_class(problem,interpretation,source);
	find mayInstanceOfVertex_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationsource_reference_Transition(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsource_reference_Transition(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []regions reference CompositeElement(source,target)
 */
private pattern mustInRelationregions_reference_CompositeElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"regions reference CompositeElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>regions reference CompositeElement(source,target)
 */
private pattern mayInRelationregions_reference_CompositeElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfCompositeElement_class(problem,interpretation,source);
	find mayInstanceOfRegion_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries entryInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1, var_e1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	find mustInstanceOfEntry_class(problem,interpretation,var_e1);
	// r1 is exported
	// e1 is exported
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_e1;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1, var_e1)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_r1);
	find mayInstanceOfEntry_class(problem,interpretation,var_e1);
	// r1 is exported
	// e1 is exported
	find mayInstanceOfRegion_class(problem,interpretation,var_r1);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r1,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_e1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1, var_e1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	find mustInstanceOfEntry_class(problem,interpretation,var_e1);
	// r1 is exported
	// e1 is exported
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_e1;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries noEntryInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	// r1 is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r1,_var__0);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_r1);
	// r1 is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r1,_var__0);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	// r1 is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r1,_var__0);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries multipleEntryInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	// r is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e1);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e2);
	neg find mayEquivalent(problem, interpretation, var_e1, var_e2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	// r is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e1);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e2);
	var_e1 != var_e2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	// r is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e1);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e2);
	var_e1 != var_e2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries transition
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_src, var_trg)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfVertex_class(problem,interpretation,var_src);
	find mustInstanceOfVertex_class(problem,interpretation,var_trg);
	// t is exported
	// src is exported
	// trg is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_src;
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_trg;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_src, var_trg)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInstanceOfVertex_class(problem,interpretation,var_src);
	find mayInstanceOfVertex_class(problem,interpretation,var_trg);
	// t is exported
	// src is exported
	// trg is exported
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_src);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_trg);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_src, var_trg)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfVertex_class(problem,interpretation,var_src);
	find mustInstanceOfVertex_class(problem,interpretation,var_trg);
	// t is exported
	// src is exported
	// trg is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_src;
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_trg;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries incomingToEntry
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t,_var__0,var_e);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t,_var__0,var_e);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t,_var__0,var_e);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries noOutgoingTransitionFromEntry
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	// e is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_e,_var__1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	// e is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_e,_var__1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	// e is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_e,_var__1);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries multipleTransitionFromEntry
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	// e is exported
	// t1 is exported
	// t2 is exported
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t1;
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual1);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_t2;
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	find mayInstanceOfTransition_class(problem,interpretation,var_t1);
	find mayInstanceOfTransition_class(problem,interpretation,var_t2);
	// e is exported
	// t1 is exported
	// t2 is exported
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mayInstanceOfTransition_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_t1);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual1);
	find mayInstanceOfTransition_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_t2);
	var_t1 != var_t2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	// e is exported
	// t1 is exported
	// t2 is exported
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t1;
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual1);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_t2;
	var_t1 != var_t2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries outgoingFromExit
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInstanceOfExit_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mayInstanceOfExit_class(problem,interpretation,var_e);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mayInstanceOfTransition_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_t);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries outgoingFromFinal
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	// t is exported
	// f is exported
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_f,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInstanceOfFinalState_class(problem,interpretation,var_f);
	// t is exported
	// f is exported
	find mayInstanceOfFinalState_class(problem,interpretation,var_f);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_f,var_virtual0);
	find mayInstanceOfTransition_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_t);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	// t is exported
	// f is exported
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_f,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries noStateInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	// region is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(problem,interpretation,var_region,_var__0);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_region);
	// region is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(problem,interpretation,var_region,_var__0);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	// region is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(problem,interpretation,var_region,_var__0);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries StateInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region, var_state)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	find mustInstanceOfState_class(problem,interpretation,var_state);
	// region is exported
	// state is exported
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_region,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_state;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region, var_state)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_region);
	find mayInstanceOfState_class(problem,interpretation,var_state);
	// region is exported
	// state is exported
	find mayInstanceOfRegion_class(problem,interpretation,var_region);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_region,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_state);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region, var_state)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	find mustInstanceOfState_class(problem,interpretation,var_state);
	// region is exported
	// state is exported
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_region,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_state;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries choiceHasNoOutgoing
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_c,_var__1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_c,_var__1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_c,_var__1);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries choiceHasNoIncoming
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_c);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_c);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_c);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries synchHasNoOutgoing
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,_var__1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,_var__1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,_var__1);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries synchHasNoIncoming
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_s);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_s);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_s);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries SynchronizedIncomingInSameRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_v1,var_s);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_v2,var_s);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_v1;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v2;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_s,var_v1);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_s,var_v2);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_v1;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v2;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v1);
	find mayInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_v1,var_s);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_v2,var_s);
	var_t1 != var_t2;
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_v1);
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_v2);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v1);
	find mayInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_s,var_v1);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_s,var_v2);
	var_t1 != var_t2;
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_v1);
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_v2);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_v1,var_s);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_v2,var_s);
	var_t1 != var_t2;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_v1;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v2;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_s,var_v1);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_s,var_v2);
	var_t1 != var_t2;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_v1;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries notSynchronizingStates
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(problem,interpretation,var_s);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(problem,interpretation,var_s);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(problem,interpretation,var_s);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(problem,interpretation,var_s);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(problem,interpretation,var_s);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(problem,interpretation,var_s);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries hasMultipleOutgoingTrainsition
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_trg1);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v,var_trg2);
	neg find mayEquivalent(problem, interpretation, var_trg1, var_trg2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_trg1);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v,var_trg2);
	var_trg1 != var_trg2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_trg1);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v,var_trg2);
	var_trg1 != var_trg2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries hasMultipleIncomingTrainsition
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_src1,var_v);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_src2,var_v);
	neg find mayEquivalent(problem, interpretation, var_src1, var_src2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_src1,var_v);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_src2,var_v);
	var_src1 != var_src2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_src1,var_v);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_src2,var_v);
	var_src1 != var_src2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries SynchronizedRegionsAreNotSiblings
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v1,var_s);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v2,var_s);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual3);
	var_virtual3 == var_v2;
	neg find mayEquivalent(problem, interpretation, var_r1, var_r2);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v1);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_s,var_v2);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual3);
	var_virtual3 == var_v2;
	neg find mayEquivalent(problem, interpretation, var_r1, var_r2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v1);
	find mayInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v1,var_s);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v2,var_s);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_v1);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual3);
	find mayEquivalent(problem, interpretation, var_virtual3, var_v2);
	var_r1 != var_r2;
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v1);
	find mayInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v1);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_s,var_v2);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_v1);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual3);
	find mayEquivalent(problem, interpretation, var_virtual3, var_v2);
	var_r1 != var_r2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v1,var_s);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v2,var_s);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual3);
	var_virtual3 == var_v2;
	var_r1 != var_r2;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v1);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_s,var_v2);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual3);
	var_virtual3 == var_v2;
	var_r1 != var_r2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries child
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mustInstanceOfVertex_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_child;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mayInstanceOfVertex_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_parent,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_child);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mustInstanceOfVertex_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_child;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries SynchronizedRegionDoesNotHaveMultipleRegions
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_s);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_s);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_s);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries hasMultipleRegions
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_composite)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	// composite is exported
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_region1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual1);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_region2;
	neg find mayEquivalent(problem, interpretation, var_region1, var_region2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_composite)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	// composite is exported
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_region1);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual1);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_region2);
	var_region1 != var_region2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_composite)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	// composite is exported
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_region1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual1);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_region2;
	var_region1 != var_region2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries synchThree
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t3);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual2);
	var_virtual2 == var_s;
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
	neg find mayEquivalent(problem, interpretation, var_t2, var_t3);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t3);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t3);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual2);
	var_virtual2 == var_s;
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
	neg find mayEquivalent(problem, interpretation, var_t2, var_t3);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t3);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mayInstanceOfTransition_class(problem,interpretation,var_t1);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_s);
	find mayInstanceOfTransition_class(problem,interpretation,var_t2);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_s);
	find mayInstanceOfTransition_class(problem,interpretation,var_t3);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual2);
	find mayEquivalent(problem, interpretation, var_virtual2, var_s);
	var_t1 != var_t2;
	var_t2 != var_t3;
	var_t1 != var_t3;
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mayInstanceOfTransition_class(problem,interpretation,var_t1);
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_s);
	find mayInstanceOfTransition_class(problem,interpretation,var_t2);
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_s);
	find mayInstanceOfTransition_class(problem,interpretation,var_t3);
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual2);
	find mayEquivalent(problem, interpretation, var_virtual2, var_s);
	var_t1 != var_t2;
	var_t2 != var_t3;
	var_t1 != var_t3;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t3);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual2);
	var_virtual2 == var_s;
	var_t1 != var_t2;
	var_t2 != var_t3;
	var_t1 != var_t3;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t3);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual2);
	var_virtual2 == var_s;
	var_t1 != var_t2;
	var_t2 != var_t3;
	var_t1 != var_t3;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries twoSynch
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s2);
	// s1 is exported
	// s2 is exported
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s2);
	neg find mayEquivalent(problem, interpretation, var_s1, var_s2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s2);
	// s1 is exported
	// s2 is exported
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s2);
	var_s1 != var_s2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s2);
	// s1 is exported
	// s2 is exported
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s2);
	var_s1 != var_s2;
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,source,target); }or
	
	{ find mustInRelationvertices_reference_Region(problem,interpretation,source,target); }or
	
	{ find mustInRelationregions_reference_CompositeElement(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(problem,interpretation,var_r1);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(problem,interpretation,var_r);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(problem,interpretation,var_t,var_e);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(problem,interpretation,var_e);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(problem,interpretation,var_e,var_t1,var_t2);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(problem,interpretation,var_t,var_e);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(problem,interpretation,var_t,var_f);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(problem,interpretation,var_region);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(problem,interpretation,var_c);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(problem,interpretation,var_c);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(problem,interpretation,var_s);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(problem,interpretation,var_s);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(problem,interpretation,var_s,var_v1,var_v2);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(problem,interpretation,var_s);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(problem,interpretation,var_s,var_v1,var_v2);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(problem,interpretation,var_s,var_v);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(problem,interpretation,var_s);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(problem,interpretation,var_s1,var_s2);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_target_reference_Transition(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"target reference Transition");
	find mustInstanceOfTransition_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtarget_reference_Transition(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(problem,interpretation,var_r1);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(problem,interpretation,var_r);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(problem,interpretation,var_t,var_e);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(problem,interpretation,var_e);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(problem,interpretation,var_e,var_t1,var_t2);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(problem,interpretation,var_t,var_e);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(problem,interpretation,var_t,var_f);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(problem,interpretation,var_region);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(problem,interpretation,var_c);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(problem,interpretation,var_c);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(problem,interpretation,var_s);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(problem,interpretation,var_s);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(problem,interpretation,var_s,var_v1,var_v2);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(problem,interpretation,var_s);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(problem,interpretation,var_s,var_v1,var_v2);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(problem,interpretation,var_s,var_v);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(problem,interpretation,var_s);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(problem,interpretation,var_s1,var_s2);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPseudostate_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVertex_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFinalState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatechart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExit_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatechart_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatechart_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Entry_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Entry class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfEntry_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Entry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Entry class");
	find mayInstanceOfEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Choice_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Choice class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfChoice_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Choice_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Choice class");
	find mayInstanceOfChoice_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_State_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"State class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfState_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_State_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"State class");
	find mayInstanceOfState_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statechart_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statechart class UndefinedPart");
	find mayInstanceOfStatechart_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Transition_class_by_outgoingTransitions_reference_Vertex_with_source_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Transition class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingTransitions reference Vertex");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"source reference Transition");
	find mustInstanceOfVertex_class(problem,interpretation,container);
	find mayInstanceOfTransition_class(problem,interpretation,newObject);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Transition_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Transition class");
	find mayInstanceOfTransition_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Region_class_by_regions_reference_CompositeElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Region class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"regions reference CompositeElement");
	find mustInstanceOfCompositeElement_class(problem,interpretation,container);
	find mayInstanceOfRegion_class(problem,interpretation,newObject);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Region_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Region class");
	find mayInstanceOfRegion_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FinalState_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FinalState class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfFinalState_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FinalState_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FinalState class");
	find mayInstanceOfFinalState_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Exit_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Exit class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfExit_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Exit_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Exit class");
	find mayInstanceOfExit_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Synchronization_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Synchronization class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfSynchronization_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Synchronization_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Synchronization class");
	find mayInstanceOfSynchronization_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Entry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
}
pattern refineTypeTo_Choice_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
}
pattern refineTypeTo_State_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfState_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
}
pattern refineTypeTo_Statechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStatechart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
}
pattern refineTypeTo_Transition_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
}
pattern refineTypeTo_Region_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
}
pattern refineTypeTo_FinalState_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
}
pattern refineTypeTo_Exit_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
}
pattern refineTypeTo_Synchronization_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_incomingTransitions_reference_Vertex_and_target_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incomingTransitions reference Vertex");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"target reference Transition");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVertex_class(problem,interpretation,from);
	find mustInstanceOfTransition_class(problem,interpretation,to);
	find mayInRelationincomingTransitions_reference_Vertex(problem,interpretation,from,to);
	neg find mustInRelationincomingTransitions_reference_Vertex(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Pseudostate class".
 */
private pattern mustInstanceOfPseudostate_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pseudostate class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPseudostate_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pseudostate class");
}

/**
 * An element may be an instance of type "Pseudostate class".
 */
private pattern mayInstanceOfPseudostate_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewPseudostate_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewPseudostate_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPseudostate_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Vertex class".
 */
private pattern mustInstanceOfVertex_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Vertex class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVertex_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Vertex class");
}

/**
 * An element may be an instance of type "Vertex class".
 */
private pattern mayInstanceOfVertex_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewVertex_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewVertex_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVertex_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Region class".
 */
private pattern mustInstanceOfRegion_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Region class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegion_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Region class");
}

/**
 * An element may be an instance of type "Region class".
 */
private pattern mayInstanceOfRegion_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegion_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegion_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegion_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Transition class".
 */
private pattern mustInstanceOfTransition_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Transition class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewTransition_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Transition class");
}

/**
 * An element may be an instance of type "Transition class".
 */
private pattern mayInstanceOfTransition_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewTransition_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewTransition_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfTransition_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statechart class".
 */
private pattern mustInstanceOfStatechart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statechart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatechart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statechart class");
}

/**
 * An element may be an instance of type "Statechart class".
 */
private pattern mayInstanceOfStatechart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatechart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Entry class".
 */
private pattern mustInstanceOfEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Entry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Entry class");
}

/**
 * An element may be an instance of type "Entry class".
 */
private pattern mayInstanceOfEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Synchronization class".
 */
private pattern mustInstanceOfSynchronization_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Synchronization class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSynchronization_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Synchronization class");
}

/**
 * An element may be an instance of type "Synchronization class".
 */
private pattern mayInstanceOfSynchronization_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewSynchronization_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewSynchronization_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSynchronization_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "State class".
 */
private pattern mustInstanceOfState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"State class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewState_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"State class");
}

/**
 * An element may be an instance of type "State class".
 */
private pattern mayInstanceOfState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewState_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewState_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularState class".
 */
private pattern mustInstanceOfRegularState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularState class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularState_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularState class");
}

/**
 * An element may be an instance of type "RegularState class".
 */
private pattern mayInstanceOfRegularState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularState_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularState_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeElement class".
 */
private pattern mustInstanceOfCompositeElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeElement class");
}

/**
 * An element may be an instance of type "CompositeElement class".
 */
private pattern mayInstanceOfCompositeElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCompositeElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Choice class".
 */
private pattern mustInstanceOfChoice_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Choice class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewChoice_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Choice class");
}

/**
 * An element may be an instance of type "Choice class".
 */
private pattern mayInstanceOfChoice_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find scopeDisallowsNewChoice_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find scopeDisallowsNewChoice_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfChoice_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Exit class".
 */
private pattern mustInstanceOfExit_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Exit class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExit_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Exit class");
}

/**
 * An element may be an instance of type "Exit class".
 */
private pattern mayInstanceOfExit_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewExit_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewExit_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExit_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FinalState class".
 */
private pattern mustInstanceOfFinalState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FinalState class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFinalState_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FinalState class");
}

/**
 * An element may be an instance of type "FinalState class".
 */
private pattern mayInstanceOfFinalState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewFinalState_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewFinalState_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFinalState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statechart class DefinedPart".
 */
private pattern mustInstanceOfStatechart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statechart class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatechart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statechart class DefinedPart");
}

/**
 * An element may be an instance of type "Statechart class DefinedPart".
 */
private pattern mayInstanceOfStatechart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfStatechart_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statechart class UndefinedPart".
 */
private pattern mustInstanceOfStatechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statechart class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statechart class UndefinedPart");
}

/**
 * An element may be an instance of type "Statechart class UndefinedPart".
 */
private pattern mayInstanceOfStatechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatechart_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeElement class DefinedPart".
 */
private pattern mustInstanceOfCompositeElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeElement class DefinedPart");
}

/**
 * An element may be an instance of type "CompositeElement class DefinedPart".
 */
private pattern mayInstanceOfCompositeElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfCompositeElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeElement class UndefinedPart".
 */
private pattern mustInstanceOfCompositeElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeElement class UndefinedPart");
}

/**
 * An element may be an instance of type "CompositeElement class UndefinedPart".
 */
private pattern mayInstanceOfCompositeElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []incomingTransitions reference Vertex(source,target)
 */
private pattern mustInRelationincomingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incomingTransitions reference Vertex");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>incomingTransitions reference Vertex(source,target)
 */
private pattern mayInRelationincomingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVertex_class(problem,interpretation,source);
	find mayInstanceOfTransition_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationtarget_reference_Transition(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationincomingTransitions_reference_Vertex(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingTransitions reference Vertex(source,target)
 */
private pattern mustInRelationoutgoingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingTransitions reference Vertex");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingTransitions reference Vertex(source,target)
 */
private pattern mayInRelationoutgoingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVertex_class(problem,interpretation,source);
	find mayInstanceOfTransition_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationsource_reference_Transition(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []vertices reference Region(source,target)
 */
private pattern mustInRelationvertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"vertices reference Region");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>vertices reference Region(source,target)
 */
private pattern mayInRelationvertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRegion_class(problem,interpretation,source);
	find mayInstanceOfVertex_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvertices_reference_Region(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []target reference Transition(source,target)
 */
private pattern mustInRelationtarget_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"target reference Transition");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>target reference Transition(source,target)
 */
private pattern mayInRelationtarget_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTransition_class(problem,interpretation,source);
	find mayInstanceOfVertex_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtarget_reference_Transition(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtarget_reference_Transition(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []source reference Transition(source,target)
 */
private pattern mustInRelationsource_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"source reference Transition");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>source reference Transition(source,target)
 */
private pattern mayInRelationsource_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTransition_class(problem,interpretation,source);
	find mayInstanceOfVertex_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationsource_reference_Transition(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsource_reference_Transition(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []regions reference CompositeElement(source,target)
 */
private pattern mustInRelationregions_reference_CompositeElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"regions reference CompositeElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>regions reference CompositeElement(source,target)
 */
private pattern mayInRelationregions_reference_CompositeElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfCompositeElement_class(problem,interpretation,source);
	find mayInstanceOfRegion_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries entryInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1, var_e1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	find mustInstanceOfEntry_class(problem,interpretation,var_e1);
	// r1 is exported
	// e1 is exported
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_e1;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1, var_e1)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_r1);
	find mayInstanceOfEntry_class(problem,interpretation,var_e1);
	// r1 is exported
	// e1 is exported
	find mayInstanceOfRegion_class(problem,interpretation,var_r1);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r1,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_e1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1, var_e1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	find mustInstanceOfEntry_class(problem,interpretation,var_e1);
	// r1 is exported
	// e1 is exported
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_e1;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries noEntryInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	// r1 is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r1,_var__0);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_r1);
	// r1 is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r1,_var__0);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	// r1 is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r1,_var__0);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries multipleEntryInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	// r is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e1);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e2);
	neg find mayEquivalent(problem, interpretation, var_e1, var_e2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	// r is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e1);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e2);
	var_e1 != var_e2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	// r is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e1);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e2);
	var_e1 != var_e2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries transition
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_src, var_trg)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfVertex_class(problem,interpretation,var_src);
	find mustInstanceOfVertex_class(problem,interpretation,var_trg);
	// t is exported
	// src is exported
	// trg is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_src;
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_trg;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_src, var_trg)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInstanceOfVertex_class(problem,interpretation,var_src);
	find mayInstanceOfVertex_class(problem,interpretation,var_trg);
	// t is exported
	// src is exported
	// trg is exported
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_src);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_trg);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_src, var_trg)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfVertex_class(problem,interpretation,var_src);
	find mustInstanceOfVertex_class(problem,interpretation,var_trg);
	// t is exported
	// src is exported
	// trg is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_src;
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_trg;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries incomingToEntry
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t,_var__0,var_e);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t,_var__0,var_e);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t,_var__0,var_e);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries noOutgoingTransitionFromEntry
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	// e is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_e,_var__1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	// e is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_e,_var__1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	// e is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_e,_var__1);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries multipleTransitionFromEntry
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	// e is exported
	// t1 is exported
	// t2 is exported
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t1;
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual1);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_t2;
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	find mayInstanceOfTransition_class(problem,interpretation,var_t1);
	find mayInstanceOfTransition_class(problem,interpretation,var_t2);
	// e is exported
	// t1 is exported
	// t2 is exported
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mayInstanceOfTransition_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_t1);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual1);
	find mayInstanceOfTransition_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_t2);
	var_t1 != var_t2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	// e is exported
	// t1 is exported
	// t2 is exported
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t1;
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual1);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_t2;
	var_t1 != var_t2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries outgoingFromExit
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInstanceOfExit_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mayInstanceOfExit_class(problem,interpretation,var_e);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mayInstanceOfTransition_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_t);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries outgoingFromFinal
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	// t is exported
	// f is exported
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_f,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInstanceOfFinalState_class(problem,interpretation,var_f);
	// t is exported
	// f is exported
	find mayInstanceOfFinalState_class(problem,interpretation,var_f);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_f,var_virtual0);
	find mayInstanceOfTransition_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_t);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	// t is exported
	// f is exported
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_f,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries noStateInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	// region is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(problem,interpretation,var_region,_var__0);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_region);
	// region is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(problem,interpretation,var_region,_var__0);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	// region is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(problem,interpretation,var_region,_var__0);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries StateInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region, var_state)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	find mustInstanceOfState_class(problem,interpretation,var_state);
	// region is exported
	// state is exported
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_region,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_state;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region, var_state)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_region);
	find mayInstanceOfState_class(problem,interpretation,var_state);
	// region is exported
	// state is exported
	find mayInstanceOfRegion_class(problem,interpretation,var_region);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_region,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_state);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region, var_state)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	find mustInstanceOfState_class(problem,interpretation,var_state);
	// region is exported
	// state is exported
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_region,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_state;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries choiceHasNoOutgoing
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_c,_var__1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_c,_var__1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_c,_var__1);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries choiceHasNoIncoming
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_c);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_c);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_c);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries synchHasNoOutgoing
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,_var__1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,_var__1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,_var__1);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries synchHasNoIncoming
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_s);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_s);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_s);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries SynchronizedIncomingInSameRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_v1,var_s);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_v2,var_s);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_v1;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v2;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_s,var_v1);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_s,var_v2);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_v1;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v2;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v1);
	find mayInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_v1,var_s);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_v2,var_s);
	var_t1 != var_t2;
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_v1);
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_v2);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v1);
	find mayInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_s,var_v1);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_s,var_v2);
	var_t1 != var_t2;
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_v1);
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_v2);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_v1,var_s);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_v2,var_s);
	var_t1 != var_t2;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_v1;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v2;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_s,var_v1);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_s,var_v2);
	var_t1 != var_t2;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_v1;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries notSynchronizingStates
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(problem,interpretation,var_s);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(problem,interpretation,var_s);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(problem,interpretation,var_s);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(problem,interpretation,var_s);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(problem,interpretation,var_s);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(problem,interpretation,var_s);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries hasMultipleOutgoingTrainsition
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_trg1);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v,var_trg2);
	neg find mayEquivalent(problem, interpretation, var_trg1, var_trg2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_trg1);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v,var_trg2);
	var_trg1 != var_trg2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_trg1);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v,var_trg2);
	var_trg1 != var_trg2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries hasMultipleIncomingTrainsition
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_src1,var_v);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_src2,var_v);
	neg find mayEquivalent(problem, interpretation, var_src1, var_src2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_src1,var_v);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_src2,var_v);
	var_src1 != var_src2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_src1,var_v);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_src2,var_v);
	var_src1 != var_src2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries SynchronizedRegionsAreNotSiblings
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v1,var_s);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v2,var_s);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual3);
	var_virtual3 == var_v2;
	neg find mayEquivalent(problem, interpretation, var_r1, var_r2);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v1);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_s,var_v2);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual3);
	var_virtual3 == var_v2;
	neg find mayEquivalent(problem, interpretation, var_r1, var_r2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v1);
	find mayInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v1,var_s);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v2,var_s);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_v1);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual3);
	find mayEquivalent(problem, interpretation, var_virtual3, var_v2);
	var_r1 != var_r2;
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v1);
	find mayInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v1);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_s,var_v2);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_v1);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual3);
	find mayEquivalent(problem, interpretation, var_virtual3, var_v2);
	var_r1 != var_r2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v1,var_s);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v2,var_s);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual3);
	var_virtual3 == var_v2;
	var_r1 != var_r2;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v1);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_s,var_v2);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual3);
	var_virtual3 == var_v2;
	var_r1 != var_r2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries child
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mustInstanceOfVertex_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_child;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mayInstanceOfVertex_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_parent,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_child);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mustInstanceOfVertex_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_child;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries SynchronizedRegionDoesNotHaveMultipleRegions
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_s);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_s);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_s);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries hasMultipleRegions
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_composite)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	// composite is exported
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_region1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual1);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_region2;
	neg find mayEquivalent(problem, interpretation, var_region1, var_region2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_composite)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	// composite is exported
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_region1);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual1);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_region2);
	var_region1 != var_region2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_composite)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	// composite is exported
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_region1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual1);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_region2;
	var_region1 != var_region2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries synchThree
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t3);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual2);
	var_virtual2 == var_s;
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
	neg find mayEquivalent(problem, interpretation, var_t2, var_t3);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t3);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t3);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual2);
	var_virtual2 == var_s;
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
	neg find mayEquivalent(problem, interpretation, var_t2, var_t3);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t3);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mayInstanceOfTransition_class(problem,interpretation,var_t1);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_s);
	find mayInstanceOfTransition_class(problem,interpretation,var_t2);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_s);
	find mayInstanceOfTransition_class(problem,interpretation,var_t3);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual2);
	find mayEquivalent(problem, interpretation, var_virtual2, var_s);
	var_t1 != var_t2;
	var_t2 != var_t3;
	var_t1 != var_t3;
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mayInstanceOfTransition_class(problem,interpretation,var_t1);
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_s);
	find mayInstanceOfTransition_class(problem,interpretation,var_t2);
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_s);
	find mayInstanceOfTransition_class(problem,interpretation,var_t3);
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual2);
	find mayEquivalent(problem, interpretation, var_virtual2, var_s);
	var_t1 != var_t2;
	var_t2 != var_t3;
	var_t1 != var_t3;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t3);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual2);
	var_virtual2 == var_s;
	var_t1 != var_t2;
	var_t2 != var_t3;
	var_t1 != var_t3;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t3);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual2);
	var_virtual2 == var_s;
	var_t1 != var_t2;
	var_t2 != var_t3;
	var_t1 != var_t3;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries twoSynch
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s2);
	// s1 is exported
	// s2 is exported
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s2);
	neg find mayEquivalent(problem, interpretation, var_s1, var_s2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s2);
	// s1 is exported
	// s2 is exported
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s2);
	var_s1 != var_s2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s2);
	// s1 is exported
	// s2 is exported
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s2);
	var_s1 != var_s2;
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,source,target); }or
	
	{ find mustInRelationvertices_reference_Region(problem,interpretation,source,target); }or
	
	{ find mustInRelationregions_reference_CompositeElement(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(problem,interpretation,var_r1);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(problem,interpretation,var_r);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(problem,interpretation,var_t,var_e);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(problem,interpretation,var_e);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(problem,interpretation,var_e,var_t1,var_t2);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(problem,interpretation,var_t,var_e);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(problem,interpretation,var_t,var_f);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(problem,interpretation,var_region);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(problem,interpretation,var_c);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(problem,interpretation,var_c);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(problem,interpretation,var_s);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(problem,interpretation,var_s);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(problem,interpretation,var_s,var_v1,var_v2);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(problem,interpretation,var_s);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(problem,interpretation,var_s,var_v1,var_v2);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(problem,interpretation,var_s,var_v);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(problem,interpretation,var_s);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(problem,interpretation,var_s1,var_s2);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_target_reference_Transition(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"target reference Transition");
	find mustInstanceOfTransition_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtarget_reference_Transition(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(problem,interpretation,var_r1);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(problem,interpretation,var_r);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(problem,interpretation,var_t,var_e);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(problem,interpretation,var_e);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(problem,interpretation,var_e,var_t1,var_t2);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(problem,interpretation,var_t,var_e);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(problem,interpretation,var_t,var_f);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(problem,interpretation,var_region);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(problem,interpretation,var_c);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(problem,interpretation,var_c);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(problem,interpretation,var_s);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(problem,interpretation,var_s);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(problem,interpretation,var_s,var_v1,var_v2);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(problem,interpretation,var_s);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(problem,interpretation,var_s,var_v1,var_v2);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(problem,interpretation,var_s,var_v);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(problem,interpretation,var_s);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(problem,interpretation,var_s1,var_s2);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPseudostate_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVertex_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFinalState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatechart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExit_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatechart_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatechart_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_State_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"State class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfState_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_State_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"State class");
	find mayInstanceOfState_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FinalState_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FinalState class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfFinalState_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FinalState_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FinalState class");
	find mayInstanceOfFinalState_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Choice_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Choice class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfChoice_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Choice_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Choice class");
	find mayInstanceOfChoice_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Entry_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Entry class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfEntry_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Entry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Entry class");
	find mayInstanceOfEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statechart_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statechart class UndefinedPart");
	find mayInstanceOfStatechart_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Exit_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Exit class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfExit_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Exit_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Exit class");
	find mayInstanceOfExit_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Transition_class_by_outgoingTransitions_reference_Vertex_with_source_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Transition class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingTransitions reference Vertex");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"source reference Transition");
	find mustInstanceOfVertex_class(problem,interpretation,container);
	find mayInstanceOfTransition_class(problem,interpretation,newObject);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Transition_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Transition class");
	find mayInstanceOfTransition_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Region_class_by_regions_reference_CompositeElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Region class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"regions reference CompositeElement");
	find mustInstanceOfCompositeElement_class(problem,interpretation,container);
	find mayInstanceOfRegion_class(problem,interpretation,newObject);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Region_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Region class");
	find mayInstanceOfRegion_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Synchronization_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Synchronization class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfSynchronization_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Synchronization_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Synchronization class");
	find mayInstanceOfSynchronization_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_State_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfState_class(problem,interpretation,element);
	neg find mustInstanceOfState_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
}
pattern refineTypeTo_FinalState_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
}
pattern refineTypeTo_Choice_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
}
pattern refineTypeTo_Entry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
}
pattern refineTypeTo_Statechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStatechart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
}
pattern refineTypeTo_Exit_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
}
pattern refineTypeTo_Transition_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
}
pattern refineTypeTo_Region_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
}
pattern refineTypeTo_Synchronization_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_incomingTransitions_reference_Vertex_and_target_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incomingTransitions reference Vertex");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"target reference Transition");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVertex_class(problem,interpretation,from);
	find mustInstanceOfTransition_class(problem,interpretation,to);
	find mayInRelationincomingTransitions_reference_Vertex(problem,interpretation,from,to);
	neg find mustInRelationincomingTransitions_reference_Vertex(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Pseudostate class".
 */
private pattern mustInstanceOfPseudostate_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pseudostate class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPseudostate_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pseudostate class");
}

/**
 * An element may be an instance of type "Pseudostate class".
 */
private pattern mayInstanceOfPseudostate_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find scopeDisallowsNewPseudostate_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find scopeDisallowsNewPseudostate_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPseudostate_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Vertex class".
 */
private pattern mustInstanceOfVertex_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Vertex class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVertex_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Vertex class");
}

/**
 * An element may be an instance of type "Vertex class".
 */
private pattern mayInstanceOfVertex_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find scopeDisallowsNewVertex_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find scopeDisallowsNewVertex_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVertex_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Region class".
 */
private pattern mustInstanceOfRegion_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Region class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegion_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Region class");
}

/**
 * An element may be an instance of type "Region class".
 */
private pattern mayInstanceOfRegion_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegion_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegion_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegion_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Transition class".
 */
private pattern mustInstanceOfTransition_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Transition class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewTransition_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Transition class");
}

/**
 * An element may be an instance of type "Transition class".
 */
private pattern mayInstanceOfTransition_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewTransition_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewTransition_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfTransition_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statechart class".
 */
private pattern mustInstanceOfStatechart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statechart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatechart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statechart class");
}

/**
 * An element may be an instance of type "Statechart class".
 */
private pattern mayInstanceOfStatechart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatechart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Entry class".
 */
private pattern mustInstanceOfEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Entry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Entry class");
}

/**
 * An element may be an instance of type "Entry class".
 */
private pattern mayInstanceOfEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find scopeDisallowsNewEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find scopeDisallowsNewEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Synchronization class".
 */
private pattern mustInstanceOfSynchronization_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Synchronization class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSynchronization_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Synchronization class");
}

/**
 * An element may be an instance of type "Synchronization class".
 */
private pattern mayInstanceOfSynchronization_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find scopeDisallowsNewSynchronization_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find scopeDisallowsNewSynchronization_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSynchronization_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "State class".
 */
private pattern mustInstanceOfState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"State class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewState_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"State class");
}

/**
 * An element may be an instance of type "State class".
 */
private pattern mayInstanceOfState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find scopeDisallowsNewState_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find scopeDisallowsNewState_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularState class".
 */
private pattern mustInstanceOfRegularState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularState class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularState_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularState class");
}

/**
 * An element may be an instance of type "RegularState class".
 */
private pattern mayInstanceOfRegularState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularState_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularState_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeElement class".
 */
private pattern mustInstanceOfCompositeElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeElement class");
}

/**
 * An element may be an instance of type "CompositeElement class".
 */
private pattern mayInstanceOfCompositeElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCompositeElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Choice class".
 */
private pattern mustInstanceOfChoice_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Choice class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewChoice_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Choice class");
}

/**
 * An element may be an instance of type "Choice class".
 */
private pattern mayInstanceOfChoice_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find scopeDisallowsNewChoice_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find scopeDisallowsNewChoice_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfChoice_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Exit class".
 */
private pattern mustInstanceOfExit_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Exit class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExit_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Exit class");
}

/**
 * An element may be an instance of type "Exit class".
 */
private pattern mayInstanceOfExit_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find scopeDisallowsNewExit_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find scopeDisallowsNewExit_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExit_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FinalState class".
 */
private pattern mustInstanceOfFinalState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FinalState class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFinalState_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FinalState class");
}

/**
 * An element may be an instance of type "FinalState class".
 */
private pattern mayInstanceOfFinalState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find scopeDisallowsNewFinalState_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find scopeDisallowsNewFinalState_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFinalState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statechart class DefinedPart".
 */
private pattern mustInstanceOfStatechart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statechart class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatechart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statechart class DefinedPart");
}

/**
 * An element may be an instance of type "Statechart class DefinedPart".
 */
private pattern mayInstanceOfStatechart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfStatechart_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statechart class UndefinedPart".
 */
private pattern mustInstanceOfStatechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statechart class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statechart class UndefinedPart");
}

/**
 * An element may be an instance of type "Statechart class UndefinedPart".
 */
private pattern mayInstanceOfStatechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatechart_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeElement class DefinedPart".
 */
private pattern mustInstanceOfCompositeElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeElement class DefinedPart");
}

/**
 * An element may be an instance of type "CompositeElement class DefinedPart".
 */
private pattern mayInstanceOfCompositeElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfCompositeElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeElement class UndefinedPart".
 */
private pattern mustInstanceOfCompositeElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeElement class UndefinedPart");
}

/**
 * An element may be an instance of type "CompositeElement class UndefinedPart".
 */
private pattern mayInstanceOfCompositeElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []incomingTransitions reference Vertex(source,target)
 */
private pattern mustInRelationincomingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incomingTransitions reference Vertex");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>incomingTransitions reference Vertex(source,target)
 */
private pattern mayInRelationincomingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVertex_class(problem,interpretation,source);
	find mayInstanceOfTransition_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationtarget_reference_Transition(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationincomingTransitions_reference_Vertex(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingTransitions reference Vertex(source,target)
 */
private pattern mustInRelationoutgoingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingTransitions reference Vertex");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingTransitions reference Vertex(source,target)
 */
private pattern mayInRelationoutgoingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVertex_class(problem,interpretation,source);
	find mayInstanceOfTransition_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationsource_reference_Transition(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []vertices reference Region(source,target)
 */
private pattern mustInRelationvertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"vertices reference Region");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>vertices reference Region(source,target)
 */
private pattern mayInRelationvertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRegion_class(problem,interpretation,source);
	find mayInstanceOfVertex_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvertices_reference_Region(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []target reference Transition(source,target)
 */
private pattern mustInRelationtarget_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"target reference Transition");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>target reference Transition(source,target)
 */
private pattern mayInRelationtarget_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTransition_class(problem,interpretation,source);
	find mayInstanceOfVertex_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtarget_reference_Transition(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtarget_reference_Transition(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []source reference Transition(source,target)
 */
private pattern mustInRelationsource_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"source reference Transition");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>source reference Transition(source,target)
 */
private pattern mayInRelationsource_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTransition_class(problem,interpretation,source);
	find mayInstanceOfVertex_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationsource_reference_Transition(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsource_reference_Transition(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []regions reference CompositeElement(source,target)
 */
private pattern mustInRelationregions_reference_CompositeElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"regions reference CompositeElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>regions reference CompositeElement(source,target)
 */
private pattern mayInRelationregions_reference_CompositeElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfCompositeElement_class(problem,interpretation,source);
	find mayInstanceOfRegion_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries entryInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1, var_e1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	find mustInstanceOfEntry_class(problem,interpretation,var_e1);
	// r1 is exported
	// e1 is exported
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_e1;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1, var_e1)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_r1);
	find mayInstanceOfEntry_class(problem,interpretation,var_e1);
	// r1 is exported
	// e1 is exported
	find mayInstanceOfRegion_class(problem,interpretation,var_r1);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r1,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_e1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1, var_e1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	find mustInstanceOfEntry_class(problem,interpretation,var_e1);
	// r1 is exported
	// e1 is exported
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_e1;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries noEntryInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	// r1 is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r1,_var__0);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_r1);
	// r1 is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r1,_var__0);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	// r1 is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r1,_var__0);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries multipleEntryInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	// r is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e1);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e2);
	neg find mayEquivalent(problem, interpretation, var_e1, var_e2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	// r is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e1);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e2);
	var_e1 != var_e2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	// r is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e1);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e2);
	var_e1 != var_e2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries transition
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_src, var_trg)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfVertex_class(problem,interpretation,var_src);
	find mustInstanceOfVertex_class(problem,interpretation,var_trg);
	// t is exported
	// src is exported
	// trg is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_src;
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_trg;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_src, var_trg)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInstanceOfVertex_class(problem,interpretation,var_src);
	find mayInstanceOfVertex_class(problem,interpretation,var_trg);
	// t is exported
	// src is exported
	// trg is exported
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_src);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_trg);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_src, var_trg)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfVertex_class(problem,interpretation,var_src);
	find mustInstanceOfVertex_class(problem,interpretation,var_trg);
	// t is exported
	// src is exported
	// trg is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_src;
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_trg;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries incomingToEntry
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t,_var__0,var_e);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t,_var__0,var_e);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t,_var__0,var_e);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries noOutgoingTransitionFromEntry
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	// e is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_e,_var__1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	// e is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_e,_var__1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	// e is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_e,_var__1);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries multipleTransitionFromEntry
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	// e is exported
	// t1 is exported
	// t2 is exported
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t1;
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual1);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_t2;
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	find mayInstanceOfTransition_class(problem,interpretation,var_t1);
	find mayInstanceOfTransition_class(problem,interpretation,var_t2);
	// e is exported
	// t1 is exported
	// t2 is exported
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mayInstanceOfTransition_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_t1);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual1);
	find mayInstanceOfTransition_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_t2);
	var_t1 != var_t2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	// e is exported
	// t1 is exported
	// t2 is exported
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t1;
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual1);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_t2;
	var_t1 != var_t2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries outgoingFromExit
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInstanceOfExit_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mayInstanceOfExit_class(problem,interpretation,var_e);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mayInstanceOfTransition_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_t);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries outgoingFromFinal
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	// t is exported
	// f is exported
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_f,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInstanceOfFinalState_class(problem,interpretation,var_f);
	// t is exported
	// f is exported
	find mayInstanceOfFinalState_class(problem,interpretation,var_f);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_f,var_virtual0);
	find mayInstanceOfTransition_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_t);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	// t is exported
	// f is exported
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_f,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries noStateInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	// region is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(problem,interpretation,var_region,_var__0);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_region);
	// region is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(problem,interpretation,var_region,_var__0);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	// region is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(problem,interpretation,var_region,_var__0);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries StateInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region, var_state)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	find mustInstanceOfState_class(problem,interpretation,var_state);
	// region is exported
	// state is exported
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_region,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_state;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region, var_state)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_region);
	find mayInstanceOfState_class(problem,interpretation,var_state);
	// region is exported
	// state is exported
	find mayInstanceOfRegion_class(problem,interpretation,var_region);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_region,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_state);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region, var_state)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	find mustInstanceOfState_class(problem,interpretation,var_state);
	// region is exported
	// state is exported
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_region,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_state;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries choiceHasNoOutgoing
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_c,_var__1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_c,_var__1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_c,_var__1);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries choiceHasNoIncoming
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_c);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_c);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_c);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries synchHasNoOutgoing
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,_var__1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,_var__1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,_var__1);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries synchHasNoIncoming
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_s);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_s);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_s);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries SynchronizedIncomingInSameRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_v1,var_s);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_v2,var_s);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_v1;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v2;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_s,var_v1);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_s,var_v2);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_v1;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v2;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v1);
	find mayInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_v1,var_s);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_v2,var_s);
	var_t1 != var_t2;
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_v1);
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_v2);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v1);
	find mayInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_s,var_v1);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_s,var_v2);
	var_t1 != var_t2;
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_v1);
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_v2);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_v1,var_s);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_v2,var_s);
	var_t1 != var_t2;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_v1;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v2;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_s,var_v1);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_s,var_v2);
	var_t1 != var_t2;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_v1;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries notSynchronizingStates
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(problem,interpretation,var_s);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(problem,interpretation,var_s);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(problem,interpretation,var_s);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(problem,interpretation,var_s);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(problem,interpretation,var_s);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(problem,interpretation,var_s);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries hasMultipleOutgoingTrainsition
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_trg1);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v,var_trg2);
	neg find mayEquivalent(problem, interpretation, var_trg1, var_trg2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_trg1);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v,var_trg2);
	var_trg1 != var_trg2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_trg1);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v,var_trg2);
	var_trg1 != var_trg2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries hasMultipleIncomingTrainsition
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_src1,var_v);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_src2,var_v);
	neg find mayEquivalent(problem, interpretation, var_src1, var_src2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_src1,var_v);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_src2,var_v);
	var_src1 != var_src2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_src1,var_v);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_src2,var_v);
	var_src1 != var_src2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries SynchronizedRegionsAreNotSiblings
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v1,var_s);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v2,var_s);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual3);
	var_virtual3 == var_v2;
	neg find mayEquivalent(problem, interpretation, var_r1, var_r2);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v1);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_s,var_v2);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual3);
	var_virtual3 == var_v2;
	neg find mayEquivalent(problem, interpretation, var_r1, var_r2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v1);
	find mayInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v1,var_s);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v2,var_s);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_v1);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual3);
	find mayEquivalent(problem, interpretation, var_virtual3, var_v2);
	var_r1 != var_r2;
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v1);
	find mayInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v1);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_s,var_v2);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_v1);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual3);
	find mayEquivalent(problem, interpretation, var_virtual3, var_v2);
	var_r1 != var_r2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v1,var_s);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v2,var_s);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual3);
	var_virtual3 == var_v2;
	var_r1 != var_r2;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v1);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_s,var_v2);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual3);
	var_virtual3 == var_v2;
	var_r1 != var_r2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries child
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mustInstanceOfVertex_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_child;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mayInstanceOfVertex_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_parent,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_child);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mustInstanceOfVertex_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_child;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries SynchronizedRegionDoesNotHaveMultipleRegions
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_s);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_s);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_s);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries hasMultipleRegions
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_composite)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	// composite is exported
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_region1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual1);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_region2;
	neg find mayEquivalent(problem, interpretation, var_region1, var_region2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_composite)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	// composite is exported
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_region1);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual1);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_region2);
	var_region1 != var_region2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_composite)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	// composite is exported
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_region1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual1);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_region2;
	var_region1 != var_region2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries synchThree
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t3);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual2);
	var_virtual2 == var_s;
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
	neg find mayEquivalent(problem, interpretation, var_t2, var_t3);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t3);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t3);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual2);
	var_virtual2 == var_s;
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
	neg find mayEquivalent(problem, interpretation, var_t2, var_t3);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t3);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mayInstanceOfTransition_class(problem,interpretation,var_t1);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_s);
	find mayInstanceOfTransition_class(problem,interpretation,var_t2);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_s);
	find mayInstanceOfTransition_class(problem,interpretation,var_t3);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual2);
	find mayEquivalent(problem, interpretation, var_virtual2, var_s);
	var_t1 != var_t2;
	var_t2 != var_t3;
	var_t1 != var_t3;
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mayInstanceOfTransition_class(problem,interpretation,var_t1);
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_s);
	find mayInstanceOfTransition_class(problem,interpretation,var_t2);
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_s);
	find mayInstanceOfTransition_class(problem,interpretation,var_t3);
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual2);
	find mayEquivalent(problem, interpretation, var_virtual2, var_s);
	var_t1 != var_t2;
	var_t2 != var_t3;
	var_t1 != var_t3;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t3);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual2);
	var_virtual2 == var_s;
	var_t1 != var_t2;
	var_t2 != var_t3;
	var_t1 != var_t3;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t3);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual2);
	var_virtual2 == var_s;
	var_t1 != var_t2;
	var_t2 != var_t3;
	var_t1 != var_t3;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries twoSynch
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s2);
	// s1 is exported
	// s2 is exported
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s2);
	neg find mayEquivalent(problem, interpretation, var_s1, var_s2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s2);
	// s1 is exported
	// s2 is exported
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s2);
	var_s1 != var_s2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s2);
	// s1 is exported
	// s2 is exported
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s2);
	var_s1 != var_s2;
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,source,target); }or
	
	{ find mustInRelationvertices_reference_Region(problem,interpretation,source,target); }or
	
	{ find mustInRelationregions_reference_CompositeElement(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(problem,interpretation,var_r1);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(problem,interpretation,var_r);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(problem,interpretation,var_t,var_e);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(problem,interpretation,var_e);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(problem,interpretation,var_e,var_t1,var_t2);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(problem,interpretation,var_t,var_e);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(problem,interpretation,var_t,var_f);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(problem,interpretation,var_region);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(problem,interpretation,var_c);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(problem,interpretation,var_c);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(problem,interpretation,var_s);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(problem,interpretation,var_s);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(problem,interpretation,var_s,var_v1,var_v2);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(problem,interpretation,var_s);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(problem,interpretation,var_s,var_v1,var_v2);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(problem,interpretation,var_s,var_v);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(problem,interpretation,var_s);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(problem,interpretation,var_s1,var_s2);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_target_reference_Transition(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"target reference Transition");
	find mustInstanceOfTransition_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtarget_reference_Transition(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(problem,interpretation,var_r1);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(problem,interpretation,var_r);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(problem,interpretation,var_t,var_e);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(problem,interpretation,var_e);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(problem,interpretation,var_e,var_t1,var_t2);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(problem,interpretation,var_t,var_e);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(problem,interpretation,var_t,var_f);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(problem,interpretation,var_region);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(problem,interpretation,var_c);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(problem,interpretation,var_c);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(problem,interpretation,var_s);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(problem,interpretation,var_s);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(problem,interpretation,var_s,var_v1,var_v2);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(problem,interpretation,var_s);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(problem,interpretation,var_s,var_v1,var_v2);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(problem,interpretation,var_s,var_v);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(problem,interpretation,var_s);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(problem,interpretation,var_s1,var_s2);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPseudostate_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVertex_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFinalState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatechart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExit_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatechart_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatechart_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Entry_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Entry class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfEntry_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Entry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Entry class");
	find mayInstanceOfEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FinalState_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FinalState class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfFinalState_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FinalState_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FinalState class");
	find mayInstanceOfFinalState_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Synchronization_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Synchronization class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfSynchronization_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Synchronization_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Synchronization class");
	find mayInstanceOfSynchronization_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Transition_class_by_outgoingTransitions_reference_Vertex_with_source_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Transition class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingTransitions reference Vertex");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"source reference Transition");
	find mustInstanceOfVertex_class(problem,interpretation,container);
	find mayInstanceOfTransition_class(problem,interpretation,newObject);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Transition_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Transition class");
	find mayInstanceOfTransition_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Choice_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Choice class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfChoice_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Choice_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Choice class");
	find mayInstanceOfChoice_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statechart_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statechart class UndefinedPart");
	find mayInstanceOfStatechart_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Region_class_by_regions_reference_CompositeElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Region class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"regions reference CompositeElement");
	find mustInstanceOfCompositeElement_class(problem,interpretation,container);
	find mayInstanceOfRegion_class(problem,interpretation,newObject);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Region_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Region class");
	find mayInstanceOfRegion_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_State_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"State class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfState_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_State_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"State class");
	find mayInstanceOfState_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Exit_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Exit class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfExit_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Exit_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Exit class");
	find mayInstanceOfExit_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Entry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
}
pattern refineTypeTo_FinalState_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
}
pattern refineTypeTo_Synchronization_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
}
pattern refineTypeTo_Transition_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
}
pattern refineTypeTo_Choice_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
}
pattern refineTypeTo_Statechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStatechart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
}
pattern refineTypeTo_Region_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
}
pattern refineTypeTo_State_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfState_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfState_class(problem,interpretation,element);
}
pattern refineTypeTo_Exit_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_incomingTransitions_reference_Vertex_and_target_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incomingTransitions reference Vertex");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"target reference Transition");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVertex_class(problem,interpretation,from);
	find mustInstanceOfTransition_class(problem,interpretation,to);
	find mayInRelationincomingTransitions_reference_Vertex(problem,interpretation,from,to);
	neg find mustInRelationincomingTransitions_reference_Vertex(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Pseudostate class".
 */
private pattern mustInstanceOfPseudostate_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pseudostate class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPseudostate_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pseudostate class");
}

/**
 * An element may be an instance of type "Pseudostate class".
 */
private pattern mayInstanceOfPseudostate_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewPseudostate_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewPseudostate_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPseudostate_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Vertex class".
 */
private pattern mustInstanceOfVertex_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Vertex class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVertex_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Vertex class");
}

/**
 * An element may be an instance of type "Vertex class".
 */
private pattern mayInstanceOfVertex_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewVertex_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewVertex_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVertex_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Region class".
 */
private pattern mustInstanceOfRegion_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Region class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegion_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Region class");
}

/**
 * An element may be an instance of type "Region class".
 */
private pattern mayInstanceOfRegion_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegion_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegion_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegion_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Transition class".
 */
private pattern mustInstanceOfTransition_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Transition class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewTransition_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Transition class");
}

/**
 * An element may be an instance of type "Transition class".
 */
private pattern mayInstanceOfTransition_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewTransition_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewTransition_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfTransition_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statechart class".
 */
private pattern mustInstanceOfStatechart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statechart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatechart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statechart class");
}

/**
 * An element may be an instance of type "Statechart class".
 */
private pattern mayInstanceOfStatechart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatechart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Entry class".
 */
private pattern mustInstanceOfEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Entry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Entry class");
}

/**
 * An element may be an instance of type "Entry class".
 */
private pattern mayInstanceOfEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Synchronization class".
 */
private pattern mustInstanceOfSynchronization_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Synchronization class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSynchronization_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Synchronization class");
}

/**
 * An element may be an instance of type "Synchronization class".
 */
private pattern mayInstanceOfSynchronization_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewSynchronization_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewSynchronization_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSynchronization_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "State class".
 */
private pattern mustInstanceOfState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"State class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewState_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"State class");
}

/**
 * An element may be an instance of type "State class".
 */
private pattern mayInstanceOfState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewState_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewState_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularState class".
 */
private pattern mustInstanceOfRegularState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularState class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularState_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularState class");
}

/**
 * An element may be an instance of type "RegularState class".
 */
private pattern mayInstanceOfRegularState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularState_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularState_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeElement class".
 */
private pattern mustInstanceOfCompositeElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeElement class");
}

/**
 * An element may be an instance of type "CompositeElement class".
 */
private pattern mayInstanceOfCompositeElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCompositeElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Choice class".
 */
private pattern mustInstanceOfChoice_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Choice class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewChoice_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Choice class");
}

/**
 * An element may be an instance of type "Choice class".
 */
private pattern mayInstanceOfChoice_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewChoice_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewChoice_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfChoice_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Exit class".
 */
private pattern mustInstanceOfExit_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Exit class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExit_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Exit class");
}

/**
 * An element may be an instance of type "Exit class".
 */
private pattern mayInstanceOfExit_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewExit_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewExit_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExit_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FinalState class".
 */
private pattern mustInstanceOfFinalState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FinalState class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFinalState_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FinalState class");
}

/**
 * An element may be an instance of type "FinalState class".
 */
private pattern mayInstanceOfFinalState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewFinalState_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewFinalState_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFinalState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statechart class DefinedPart".
 */
private pattern mustInstanceOfStatechart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statechart class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatechart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statechart class DefinedPart");
}

/**
 * An element may be an instance of type "Statechart class DefinedPart".
 */
private pattern mayInstanceOfStatechart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfStatechart_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statechart class UndefinedPart".
 */
private pattern mustInstanceOfStatechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statechart class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statechart class UndefinedPart");
}

/**
 * An element may be an instance of type "Statechart class UndefinedPart".
 */
private pattern mayInstanceOfStatechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatechart_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeElement class DefinedPart".
 */
private pattern mustInstanceOfCompositeElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeElement class DefinedPart");
}

/**
 * An element may be an instance of type "CompositeElement class DefinedPart".
 */
private pattern mayInstanceOfCompositeElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfCompositeElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeElement class UndefinedPart".
 */
private pattern mustInstanceOfCompositeElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeElement class UndefinedPart");
}

/**
 * An element may be an instance of type "CompositeElement class UndefinedPart".
 */
private pattern mayInstanceOfCompositeElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []incomingTransitions reference Vertex(source,target)
 */
private pattern mustInRelationincomingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incomingTransitions reference Vertex");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>incomingTransitions reference Vertex(source,target)
 */
private pattern mayInRelationincomingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVertex_class(problem,interpretation,source);
	find mayInstanceOfTransition_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationtarget_reference_Transition(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationincomingTransitions_reference_Vertex(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingTransitions reference Vertex(source,target)
 */
private pattern mustInRelationoutgoingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingTransitions reference Vertex");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingTransitions reference Vertex(source,target)
 */
private pattern mayInRelationoutgoingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVertex_class(problem,interpretation,source);
	find mayInstanceOfTransition_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationsource_reference_Transition(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []vertices reference Region(source,target)
 */
private pattern mustInRelationvertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"vertices reference Region");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>vertices reference Region(source,target)
 */
private pattern mayInRelationvertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRegion_class(problem,interpretation,source);
	find mayInstanceOfVertex_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvertices_reference_Region(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []target reference Transition(source,target)
 */
private pattern mustInRelationtarget_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"target reference Transition");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>target reference Transition(source,target)
 */
private pattern mayInRelationtarget_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTransition_class(problem,interpretation,source);
	find mayInstanceOfVertex_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtarget_reference_Transition(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtarget_reference_Transition(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []source reference Transition(source,target)
 */
private pattern mustInRelationsource_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"source reference Transition");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>source reference Transition(source,target)
 */
private pattern mayInRelationsource_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTransition_class(problem,interpretation,source);
	find mayInstanceOfVertex_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationsource_reference_Transition(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsource_reference_Transition(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []regions reference CompositeElement(source,target)
 */
private pattern mustInRelationregions_reference_CompositeElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"regions reference CompositeElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>regions reference CompositeElement(source,target)
 */
private pattern mayInRelationregions_reference_CompositeElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfCompositeElement_class(problem,interpretation,source);
	find mayInstanceOfRegion_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries entryInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1, var_e1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	find mustInstanceOfEntry_class(problem,interpretation,var_e1);
	// r1 is exported
	// e1 is exported
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_e1;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1, var_e1)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_r1);
	find mayInstanceOfEntry_class(problem,interpretation,var_e1);
	// r1 is exported
	// e1 is exported
	find mayInstanceOfRegion_class(problem,interpretation,var_r1);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r1,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_e1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1, var_e1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	find mustInstanceOfEntry_class(problem,interpretation,var_e1);
	// r1 is exported
	// e1 is exported
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_e1;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries noEntryInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	// r1 is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r1,_var__0);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_r1);
	// r1 is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r1,_var__0);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	// r1 is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r1,_var__0);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries multipleEntryInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	// r is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e1);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e2);
	neg find mayEquivalent(problem, interpretation, var_e1, var_e2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	// r is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e1);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e2);
	var_e1 != var_e2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	// r is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e1);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e2);
	var_e1 != var_e2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries transition
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_src, var_trg)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfVertex_class(problem,interpretation,var_src);
	find mustInstanceOfVertex_class(problem,interpretation,var_trg);
	// t is exported
	// src is exported
	// trg is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_src;
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_trg;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_src, var_trg)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInstanceOfVertex_class(problem,interpretation,var_src);
	find mayInstanceOfVertex_class(problem,interpretation,var_trg);
	// t is exported
	// src is exported
	// trg is exported
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_src);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_trg);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_src, var_trg)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfVertex_class(problem,interpretation,var_src);
	find mustInstanceOfVertex_class(problem,interpretation,var_trg);
	// t is exported
	// src is exported
	// trg is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_src;
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_trg;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries incomingToEntry
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t,_var__0,var_e);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t,_var__0,var_e);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t,_var__0,var_e);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries noOutgoingTransitionFromEntry
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	// e is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_e,_var__1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	// e is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_e,_var__1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	// e is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_e,_var__1);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries multipleTransitionFromEntry
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	// e is exported
	// t1 is exported
	// t2 is exported
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t1;
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual1);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_t2;
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	find mayInstanceOfTransition_class(problem,interpretation,var_t1);
	find mayInstanceOfTransition_class(problem,interpretation,var_t2);
	// e is exported
	// t1 is exported
	// t2 is exported
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mayInstanceOfTransition_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_t1);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual1);
	find mayInstanceOfTransition_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_t2);
	var_t1 != var_t2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	// e is exported
	// t1 is exported
	// t2 is exported
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t1;
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual1);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_t2;
	var_t1 != var_t2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries outgoingFromExit
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInstanceOfExit_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mayInstanceOfExit_class(problem,interpretation,var_e);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mayInstanceOfTransition_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_t);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries outgoingFromFinal
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	// t is exported
	// f is exported
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_f,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInstanceOfFinalState_class(problem,interpretation,var_f);
	// t is exported
	// f is exported
	find mayInstanceOfFinalState_class(problem,interpretation,var_f);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_f,var_virtual0);
	find mayInstanceOfTransition_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_t);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	// t is exported
	// f is exported
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_f,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries noStateInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	// region is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(problem,interpretation,var_region,_var__0);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_region);
	// region is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(problem,interpretation,var_region,_var__0);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	// region is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(problem,interpretation,var_region,_var__0);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries StateInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region, var_state)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	find mustInstanceOfState_class(problem,interpretation,var_state);
	// region is exported
	// state is exported
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_region,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_state;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region, var_state)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_region);
	find mayInstanceOfState_class(problem,interpretation,var_state);
	// region is exported
	// state is exported
	find mayInstanceOfRegion_class(problem,interpretation,var_region);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_region,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_state);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region, var_state)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	find mustInstanceOfState_class(problem,interpretation,var_state);
	// region is exported
	// state is exported
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_region,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_state;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries choiceHasNoOutgoing
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_c,_var__1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_c,_var__1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_c,_var__1);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries choiceHasNoIncoming
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_c);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_c);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_c);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries synchHasNoOutgoing
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,_var__1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,_var__1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,_var__1);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries synchHasNoIncoming
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_s);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_s);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_s);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries SynchronizedIncomingInSameRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_v1,var_s);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_v2,var_s);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_v1;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v2;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_s,var_v1);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_s,var_v2);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_v1;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v2;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v1);
	find mayInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_v1,var_s);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_v2,var_s);
	var_t1 != var_t2;
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_v1);
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_v2);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v1);
	find mayInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_s,var_v1);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_s,var_v2);
	var_t1 != var_t2;
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_v1);
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_v2);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_v1,var_s);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_v2,var_s);
	var_t1 != var_t2;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_v1;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v2;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_s,var_v1);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_s,var_v2);
	var_t1 != var_t2;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_v1;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries notSynchronizingStates
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(problem,interpretation,var_s);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(problem,interpretation,var_s);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(problem,interpretation,var_s);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(problem,interpretation,var_s);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(problem,interpretation,var_s);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(problem,interpretation,var_s);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries hasMultipleOutgoingTrainsition
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_trg1);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v,var_trg2);
	neg find mayEquivalent(problem, interpretation, var_trg1, var_trg2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_trg1);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v,var_trg2);
	var_trg1 != var_trg2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_trg1);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v,var_trg2);
	var_trg1 != var_trg2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries hasMultipleIncomingTrainsition
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_src1,var_v);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_src2,var_v);
	neg find mayEquivalent(problem, interpretation, var_src1, var_src2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_src1,var_v);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_src2,var_v);
	var_src1 != var_src2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_src1,var_v);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_src2,var_v);
	var_src1 != var_src2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries SynchronizedRegionsAreNotSiblings
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v1,var_s);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v2,var_s);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual3);
	var_virtual3 == var_v2;
	neg find mayEquivalent(problem, interpretation, var_r1, var_r2);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v1);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_s,var_v2);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual3);
	var_virtual3 == var_v2;
	neg find mayEquivalent(problem, interpretation, var_r1, var_r2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v1);
	find mayInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v1,var_s);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v2,var_s);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_v1);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual3);
	find mayEquivalent(problem, interpretation, var_virtual3, var_v2);
	var_r1 != var_r2;
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v1);
	find mayInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v1);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_s,var_v2);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_v1);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual3);
	find mayEquivalent(problem, interpretation, var_virtual3, var_v2);
	var_r1 != var_r2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v1,var_s);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v2,var_s);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual3);
	var_virtual3 == var_v2;
	var_r1 != var_r2;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v1);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_s,var_v2);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual3);
	var_virtual3 == var_v2;
	var_r1 != var_r2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries child
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mustInstanceOfVertex_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_child;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mayInstanceOfVertex_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_parent,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_child);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mustInstanceOfVertex_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_child;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries SynchronizedRegionDoesNotHaveMultipleRegions
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_s);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_s);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_s);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries hasMultipleRegions
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_composite)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	// composite is exported
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_region1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual1);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_region2;
	neg find mayEquivalent(problem, interpretation, var_region1, var_region2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_composite)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	// composite is exported
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_region1);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual1);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_region2);
	var_region1 != var_region2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_composite)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	// composite is exported
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_region1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual1);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_region2;
	var_region1 != var_region2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries synchThree
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t3);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual2);
	var_virtual2 == var_s;
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
	neg find mayEquivalent(problem, interpretation, var_t2, var_t3);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t3);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t3);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual2);
	var_virtual2 == var_s;
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
	neg find mayEquivalent(problem, interpretation, var_t2, var_t3);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t3);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mayInstanceOfTransition_class(problem,interpretation,var_t1);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_s);
	find mayInstanceOfTransition_class(problem,interpretation,var_t2);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_s);
	find mayInstanceOfTransition_class(problem,interpretation,var_t3);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual2);
	find mayEquivalent(problem, interpretation, var_virtual2, var_s);
	var_t1 != var_t2;
	var_t2 != var_t3;
	var_t1 != var_t3;
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mayInstanceOfTransition_class(problem,interpretation,var_t1);
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_s);
	find mayInstanceOfTransition_class(problem,interpretation,var_t2);
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_s);
	find mayInstanceOfTransition_class(problem,interpretation,var_t3);
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual2);
	find mayEquivalent(problem, interpretation, var_virtual2, var_s);
	var_t1 != var_t2;
	var_t2 != var_t3;
	var_t1 != var_t3;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t3);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual2);
	var_virtual2 == var_s;
	var_t1 != var_t2;
	var_t2 != var_t3;
	var_t1 != var_t3;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t3);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual2);
	var_virtual2 == var_s;
	var_t1 != var_t2;
	var_t2 != var_t3;
	var_t1 != var_t3;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries twoSynch
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s2);
	// s1 is exported
	// s2 is exported
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s2);
	neg find mayEquivalent(problem, interpretation, var_s1, var_s2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s2);
	// s1 is exported
	// s2 is exported
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s2);
	var_s1 != var_s2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s2);
	// s1 is exported
	// s2 is exported
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s2);
	var_s1 != var_s2;
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,source,target); }or
	
	{ find mustInRelationvertices_reference_Region(problem,interpretation,source,target); }or
	
	{ find mustInRelationregions_reference_CompositeElement(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(problem,interpretation,var_r1);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(problem,interpretation,var_r);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(problem,interpretation,var_t,var_e);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(problem,interpretation,var_e);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(problem,interpretation,var_e,var_t1,var_t2);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(problem,interpretation,var_t,var_e);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(problem,interpretation,var_t,var_f);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(problem,interpretation,var_region);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(problem,interpretation,var_c);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(problem,interpretation,var_c);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(problem,interpretation,var_s);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(problem,interpretation,var_s);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(problem,interpretation,var_s,var_v1,var_v2);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(problem,interpretation,var_s);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(problem,interpretation,var_s,var_v1,var_v2);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(problem,interpretation,var_s,var_v);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(problem,interpretation,var_s);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(problem,interpretation,var_s1,var_s2);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_target_reference_Transition(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"target reference Transition");
	find mustInstanceOfTransition_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtarget_reference_Transition(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(problem,interpretation,var_r1);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(problem,interpretation,var_r);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(problem,interpretation,var_t,var_e);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(problem,interpretation,var_e);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(problem,interpretation,var_e,var_t1,var_t2);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(problem,interpretation,var_t,var_e);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(problem,interpretation,var_t,var_f);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(problem,interpretation,var_region);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(problem,interpretation,var_c);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(problem,interpretation,var_c);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(problem,interpretation,var_s);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(problem,interpretation,var_s);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(problem,interpretation,var_s,var_v1,var_v2);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(problem,interpretation,var_s);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(problem,interpretation,var_s,var_v1,var_v2);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(problem,interpretation,var_s,var_v);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(problem,interpretation,var_s);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(problem,interpretation,var_s1,var_s2);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPseudostate_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVertex_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFinalState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatechart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExit_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatechart_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatechart_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Transition_class_by_outgoingTransitions_reference_Vertex_with_source_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Transition class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingTransitions reference Vertex");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"source reference Transition");
	find mustInstanceOfVertex_class(problem,interpretation,container);
	find mayInstanceOfTransition_class(problem,interpretation,newObject);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Transition_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Transition class");
	find mayInstanceOfTransition_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Synchronization_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Synchronization class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfSynchronization_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Synchronization_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Synchronization class");
	find mayInstanceOfSynchronization_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_State_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"State class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfState_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_State_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"State class");
	find mayInstanceOfState_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Exit_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Exit class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfExit_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Exit_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Exit class");
	find mayInstanceOfExit_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Choice_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Choice class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfChoice_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Choice_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Choice class");
	find mayInstanceOfChoice_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FinalState_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FinalState class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfFinalState_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FinalState_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FinalState class");
	find mayInstanceOfFinalState_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Region_class_by_regions_reference_CompositeElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Region class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"regions reference CompositeElement");
	find mustInstanceOfCompositeElement_class(problem,interpretation,container);
	find mayInstanceOfRegion_class(problem,interpretation,newObject);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Region_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Region class");
	find mayInstanceOfRegion_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Entry_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Entry class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfEntry_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Entry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Entry class");
	find mayInstanceOfEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statechart_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statechart class UndefinedPart");
	find mayInstanceOfStatechart_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Transition_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
}
pattern refineTypeTo_Synchronization_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
}
pattern refineTypeTo_State_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfState_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
}
pattern refineTypeTo_Exit_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_Choice_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_FinalState_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
}
pattern refineTypeTo_Region_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
}
pattern refineTypeTo_Entry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
}
pattern refineTypeTo_Statechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStatechart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_incomingTransitions_reference_Vertex_and_target_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incomingTransitions reference Vertex");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"target reference Transition");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVertex_class(problem,interpretation,from);
	find mustInstanceOfTransition_class(problem,interpretation,to);
	find mayInRelationincomingTransitions_reference_Vertex(problem,interpretation,from,to);
	neg find mustInRelationincomingTransitions_reference_Vertex(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Pseudostate class".
 */
private pattern mustInstanceOfPseudostate_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pseudostate class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPseudostate_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pseudostate class");
}

/**
 * An element may be an instance of type "Pseudostate class".
 */
private pattern mayInstanceOfPseudostate_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewPseudostate_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewPseudostate_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPseudostate_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Vertex class".
 */
private pattern mustInstanceOfVertex_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Vertex class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVertex_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Vertex class");
}

/**
 * An element may be an instance of type "Vertex class".
 */
private pattern mayInstanceOfVertex_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewVertex_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewVertex_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVertex_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Region class".
 */
private pattern mustInstanceOfRegion_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Region class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegion_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Region class");
}

/**
 * An element may be an instance of type "Region class".
 */
private pattern mayInstanceOfRegion_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegion_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegion_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegion_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Transition class".
 */
private pattern mustInstanceOfTransition_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Transition class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewTransition_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Transition class");
}

/**
 * An element may be an instance of type "Transition class".
 */
private pattern mayInstanceOfTransition_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewTransition_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewTransition_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfTransition_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statechart class".
 */
private pattern mustInstanceOfStatechart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statechart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatechart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statechart class");
}

/**
 * An element may be an instance of type "Statechart class".
 */
private pattern mayInstanceOfStatechart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatechart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Entry class".
 */
private pattern mustInstanceOfEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Entry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Entry class");
}

/**
 * An element may be an instance of type "Entry class".
 */
private pattern mayInstanceOfEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Synchronization class".
 */
private pattern mustInstanceOfSynchronization_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Synchronization class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSynchronization_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Synchronization class");
}

/**
 * An element may be an instance of type "Synchronization class".
 */
private pattern mayInstanceOfSynchronization_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewSynchronization_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewSynchronization_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSynchronization_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "State class".
 */
private pattern mustInstanceOfState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"State class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewState_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"State class");
}

/**
 * An element may be an instance of type "State class".
 */
private pattern mayInstanceOfState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find scopeDisallowsNewState_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find scopeDisallowsNewState_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularState class".
 */
private pattern mustInstanceOfRegularState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularState class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularState_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularState class");
}

/**
 * An element may be an instance of type "RegularState class".
 */
private pattern mayInstanceOfRegularState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularState_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularState_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeElement class".
 */
private pattern mustInstanceOfCompositeElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeElement class");
}

/**
 * An element may be an instance of type "CompositeElement class".
 */
private pattern mayInstanceOfCompositeElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCompositeElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Choice class".
 */
private pattern mustInstanceOfChoice_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Choice class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewChoice_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Choice class");
}

/**
 * An element may be an instance of type "Choice class".
 */
private pattern mayInstanceOfChoice_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewChoice_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewChoice_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfChoice_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Exit class".
 */
private pattern mustInstanceOfExit_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Exit class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExit_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Exit class");
}

/**
 * An element may be an instance of type "Exit class".
 */
private pattern mayInstanceOfExit_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewExit_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewExit_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExit_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FinalState class".
 */
private pattern mustInstanceOfFinalState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FinalState class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFinalState_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FinalState class");
}

/**
 * An element may be an instance of type "FinalState class".
 */
private pattern mayInstanceOfFinalState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFinalState_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFinalState_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFinalState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statechart class DefinedPart".
 */
private pattern mustInstanceOfStatechart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statechart class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatechart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statechart class DefinedPart");
}

/**
 * An element may be an instance of type "Statechart class DefinedPart".
 */
private pattern mayInstanceOfStatechart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfStatechart_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statechart class UndefinedPart".
 */
private pattern mustInstanceOfStatechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statechart class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statechart class UndefinedPart");
}

/**
 * An element may be an instance of type "Statechart class UndefinedPart".
 */
private pattern mayInstanceOfStatechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatechart_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeElement class DefinedPart".
 */
private pattern mustInstanceOfCompositeElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeElement class DefinedPart");
}

/**
 * An element may be an instance of type "CompositeElement class DefinedPart".
 */
private pattern mayInstanceOfCompositeElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfCompositeElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeElement class UndefinedPart".
 */
private pattern mustInstanceOfCompositeElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeElement class UndefinedPart");
}

/**
 * An element may be an instance of type "CompositeElement class UndefinedPart".
 */
private pattern mayInstanceOfCompositeElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []incomingTransitions reference Vertex(source,target)
 */
private pattern mustInRelationincomingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incomingTransitions reference Vertex");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>incomingTransitions reference Vertex(source,target)
 */
private pattern mayInRelationincomingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVertex_class(problem,interpretation,source);
	find mayInstanceOfTransition_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationtarget_reference_Transition(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationincomingTransitions_reference_Vertex(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingTransitions reference Vertex(source,target)
 */
private pattern mustInRelationoutgoingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingTransitions reference Vertex");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingTransitions reference Vertex(source,target)
 */
private pattern mayInRelationoutgoingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVertex_class(problem,interpretation,source);
	find mayInstanceOfTransition_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationsource_reference_Transition(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []vertices reference Region(source,target)
 */
private pattern mustInRelationvertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"vertices reference Region");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>vertices reference Region(source,target)
 */
private pattern mayInRelationvertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRegion_class(problem,interpretation,source);
	find mayInstanceOfVertex_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvertices_reference_Region(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []target reference Transition(source,target)
 */
private pattern mustInRelationtarget_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"target reference Transition");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>target reference Transition(source,target)
 */
private pattern mayInRelationtarget_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTransition_class(problem,interpretation,source);
	find mayInstanceOfVertex_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtarget_reference_Transition(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtarget_reference_Transition(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []source reference Transition(source,target)
 */
private pattern mustInRelationsource_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"source reference Transition");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>source reference Transition(source,target)
 */
private pattern mayInRelationsource_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTransition_class(problem,interpretation,source);
	find mayInstanceOfVertex_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationsource_reference_Transition(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsource_reference_Transition(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []regions reference CompositeElement(source,target)
 */
private pattern mustInRelationregions_reference_CompositeElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"regions reference CompositeElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>regions reference CompositeElement(source,target)
 */
private pattern mayInRelationregions_reference_CompositeElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfCompositeElement_class(problem,interpretation,source);
	find mayInstanceOfRegion_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries entryInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1, var_e1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	find mustInstanceOfEntry_class(problem,interpretation,var_e1);
	// r1 is exported
	// e1 is exported
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_e1;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1, var_e1)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_r1);
	find mayInstanceOfEntry_class(problem,interpretation,var_e1);
	// r1 is exported
	// e1 is exported
	find mayInstanceOfRegion_class(problem,interpretation,var_r1);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r1,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_e1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1, var_e1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	find mustInstanceOfEntry_class(problem,interpretation,var_e1);
	// r1 is exported
	// e1 is exported
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_e1;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries noEntryInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	// r1 is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r1,_var__0);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_r1);
	// r1 is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r1,_var__0);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	// r1 is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r1,_var__0);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries multipleEntryInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	// r is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e1);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e2);
	neg find mayEquivalent(problem, interpretation, var_e1, var_e2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	// r is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e1);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e2);
	var_e1 != var_e2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	// r is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e1);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e2);
	var_e1 != var_e2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries transition
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_src, var_trg)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfVertex_class(problem,interpretation,var_src);
	find mustInstanceOfVertex_class(problem,interpretation,var_trg);
	// t is exported
	// src is exported
	// trg is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_src;
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_trg;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_src, var_trg)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInstanceOfVertex_class(problem,interpretation,var_src);
	find mayInstanceOfVertex_class(problem,interpretation,var_trg);
	// t is exported
	// src is exported
	// trg is exported
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_src);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_trg);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_src, var_trg)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfVertex_class(problem,interpretation,var_src);
	find mustInstanceOfVertex_class(problem,interpretation,var_trg);
	// t is exported
	// src is exported
	// trg is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_src;
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_trg;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries incomingToEntry
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t,_var__0,var_e);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t,_var__0,var_e);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t,_var__0,var_e);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries noOutgoingTransitionFromEntry
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	// e is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_e,_var__1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	// e is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_e,_var__1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	// e is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_e,_var__1);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries multipleTransitionFromEntry
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	// e is exported
	// t1 is exported
	// t2 is exported
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t1;
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual1);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_t2;
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	find mayInstanceOfTransition_class(problem,interpretation,var_t1);
	find mayInstanceOfTransition_class(problem,interpretation,var_t2);
	// e is exported
	// t1 is exported
	// t2 is exported
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mayInstanceOfTransition_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_t1);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual1);
	find mayInstanceOfTransition_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_t2);
	var_t1 != var_t2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	// e is exported
	// t1 is exported
	// t2 is exported
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t1;
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual1);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_t2;
	var_t1 != var_t2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries outgoingFromExit
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInstanceOfExit_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mayInstanceOfExit_class(problem,interpretation,var_e);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mayInstanceOfTransition_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_t);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries outgoingFromFinal
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	// t is exported
	// f is exported
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_f,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInstanceOfFinalState_class(problem,interpretation,var_f);
	// t is exported
	// f is exported
	find mayInstanceOfFinalState_class(problem,interpretation,var_f);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_f,var_virtual0);
	find mayInstanceOfTransition_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_t);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	// t is exported
	// f is exported
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_f,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries noStateInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	// region is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(problem,interpretation,var_region,_var__0);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_region);
	// region is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(problem,interpretation,var_region,_var__0);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	// region is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(problem,interpretation,var_region,_var__0);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries StateInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region, var_state)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	find mustInstanceOfState_class(problem,interpretation,var_state);
	// region is exported
	// state is exported
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_region,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_state;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region, var_state)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_region);
	find mayInstanceOfState_class(problem,interpretation,var_state);
	// region is exported
	// state is exported
	find mayInstanceOfRegion_class(problem,interpretation,var_region);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_region,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_state);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region, var_state)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	find mustInstanceOfState_class(problem,interpretation,var_state);
	// region is exported
	// state is exported
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_region,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_state;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries choiceHasNoOutgoing
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_c,_var__1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_c,_var__1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_c,_var__1);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries choiceHasNoIncoming
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_c);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_c);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_c);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries synchHasNoOutgoing
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,_var__1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,_var__1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,_var__1);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries synchHasNoIncoming
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_s);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_s);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_s);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries SynchronizedIncomingInSameRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_v1,var_s);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_v2,var_s);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_v1;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v2;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_s,var_v1);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_s,var_v2);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_v1;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v2;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v1);
	find mayInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_v1,var_s);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_v2,var_s);
	var_t1 != var_t2;
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_v1);
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_v2);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v1);
	find mayInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_s,var_v1);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_s,var_v2);
	var_t1 != var_t2;
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_v1);
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_v2);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_v1,var_s);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_v2,var_s);
	var_t1 != var_t2;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_v1;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v2;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_s,var_v1);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_s,var_v2);
	var_t1 != var_t2;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_v1;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries notSynchronizingStates
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(problem,interpretation,var_s);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(problem,interpretation,var_s);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(problem,interpretation,var_s);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(problem,interpretation,var_s);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(problem,interpretation,var_s);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(problem,interpretation,var_s);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries hasMultipleOutgoingTrainsition
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_trg1);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v,var_trg2);
	neg find mayEquivalent(problem, interpretation, var_trg1, var_trg2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_trg1);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v,var_trg2);
	var_trg1 != var_trg2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_trg1);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v,var_trg2);
	var_trg1 != var_trg2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries hasMultipleIncomingTrainsition
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_src1,var_v);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_src2,var_v);
	neg find mayEquivalent(problem, interpretation, var_src1, var_src2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_src1,var_v);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_src2,var_v);
	var_src1 != var_src2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_src1,var_v);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_src2,var_v);
	var_src1 != var_src2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries SynchronizedRegionsAreNotSiblings
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v1,var_s);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v2,var_s);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual3);
	var_virtual3 == var_v2;
	neg find mayEquivalent(problem, interpretation, var_r1, var_r2);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v1);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_s,var_v2);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual3);
	var_virtual3 == var_v2;
	neg find mayEquivalent(problem, interpretation, var_r1, var_r2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v1);
	find mayInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v1,var_s);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v2,var_s);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_v1);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual3);
	find mayEquivalent(problem, interpretation, var_virtual3, var_v2);
	var_r1 != var_r2;
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v1);
	find mayInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v1);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_s,var_v2);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_v1);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual3);
	find mayEquivalent(problem, interpretation, var_virtual3, var_v2);
	var_r1 != var_r2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v1,var_s);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v2,var_s);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual3);
	var_virtual3 == var_v2;
	var_r1 != var_r2;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v1);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_s,var_v2);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual3);
	var_virtual3 == var_v2;
	var_r1 != var_r2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries child
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mustInstanceOfVertex_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_child;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mayInstanceOfVertex_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_parent,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_child);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mustInstanceOfVertex_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_child;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries SynchronizedRegionDoesNotHaveMultipleRegions
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_s);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_s);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_s);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries hasMultipleRegions
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_composite)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	// composite is exported
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_region1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual1);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_region2;
	neg find mayEquivalent(problem, interpretation, var_region1, var_region2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_composite)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	// composite is exported
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_region1);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual1);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_region2);
	var_region1 != var_region2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_composite)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	// composite is exported
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_region1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual1);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_region2;
	var_region1 != var_region2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries synchThree
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t3);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual2);
	var_virtual2 == var_s;
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
	neg find mayEquivalent(problem, interpretation, var_t2, var_t3);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t3);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t3);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual2);
	var_virtual2 == var_s;
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
	neg find mayEquivalent(problem, interpretation, var_t2, var_t3);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t3);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mayInstanceOfTransition_class(problem,interpretation,var_t1);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_s);
	find mayInstanceOfTransition_class(problem,interpretation,var_t2);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_s);
	find mayInstanceOfTransition_class(problem,interpretation,var_t3);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual2);
	find mayEquivalent(problem, interpretation, var_virtual2, var_s);
	var_t1 != var_t2;
	var_t2 != var_t3;
	var_t1 != var_t3;
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mayInstanceOfTransition_class(problem,interpretation,var_t1);
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_s);
	find mayInstanceOfTransition_class(problem,interpretation,var_t2);
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_s);
	find mayInstanceOfTransition_class(problem,interpretation,var_t3);
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual2);
	find mayEquivalent(problem, interpretation, var_virtual2, var_s);
	var_t1 != var_t2;
	var_t2 != var_t3;
	var_t1 != var_t3;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t3);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual2);
	var_virtual2 == var_s;
	var_t1 != var_t2;
	var_t2 != var_t3;
	var_t1 != var_t3;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t3);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual2);
	var_virtual2 == var_s;
	var_t1 != var_t2;
	var_t2 != var_t3;
	var_t1 != var_t3;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries twoSynch
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s2);
	// s1 is exported
	// s2 is exported
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s2);
	neg find mayEquivalent(problem, interpretation, var_s1, var_s2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s2);
	// s1 is exported
	// s2 is exported
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s2);
	var_s1 != var_s2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s2);
	// s1 is exported
	// s2 is exported
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s2);
	var_s1 != var_s2;
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,source,target); }or
	
	{ find mustInRelationvertices_reference_Region(problem,interpretation,source,target); }or
	
	{ find mustInRelationregions_reference_CompositeElement(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(problem,interpretation,var_r1);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(problem,interpretation,var_r);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(problem,interpretation,var_t,var_e);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(problem,interpretation,var_e);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(problem,interpretation,var_e,var_t1,var_t2);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(problem,interpretation,var_t,var_e);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(problem,interpretation,var_t,var_f);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(problem,interpretation,var_region);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(problem,interpretation,var_c);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(problem,interpretation,var_c);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(problem,interpretation,var_s);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(problem,interpretation,var_s);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(problem,interpretation,var_s,var_v1,var_v2);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(problem,interpretation,var_s);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(problem,interpretation,var_s,var_v1,var_v2);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(problem,interpretation,var_s,var_v);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(problem,interpretation,var_s);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(problem,interpretation,var_s1,var_s2);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_target_reference_Transition(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"target reference Transition");
	find mustInstanceOfTransition_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtarget_reference_Transition(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(problem,interpretation,var_r1);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(problem,interpretation,var_r);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(problem,interpretation,var_t,var_e);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(problem,interpretation,var_e);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(problem,interpretation,var_e,var_t1,var_t2);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(problem,interpretation,var_t,var_e);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(problem,interpretation,var_t,var_f);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(problem,interpretation,var_region);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(problem,interpretation,var_c);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(problem,interpretation,var_c);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(problem,interpretation,var_s);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(problem,interpretation,var_s);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(problem,interpretation,var_s,var_v1,var_v2);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(problem,interpretation,var_s);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(problem,interpretation,var_s,var_v1,var_v2);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(problem,interpretation,var_s,var_v);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(problem,interpretation,var_s);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(problem,interpretation,var_s1,var_s2);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPseudostate_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVertex_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExit_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFinalState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatechart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatechart_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatechart_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_State_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"State class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfState_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_State_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"State class");
	find mayInstanceOfState_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FinalState_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FinalState class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfFinalState_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FinalState_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FinalState class");
	find mayInstanceOfFinalState_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Synchronization_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Synchronization class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfSynchronization_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Synchronization_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Synchronization class");
	find mayInstanceOfSynchronization_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Region_class_by_regions_reference_CompositeElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Region class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"regions reference CompositeElement");
	find mustInstanceOfCompositeElement_class(problem,interpretation,container);
	find mayInstanceOfRegion_class(problem,interpretation,newObject);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Region_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Region class");
	find mayInstanceOfRegion_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Entry_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Entry class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfEntry_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Entry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Entry class");
	find mayInstanceOfEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Exit_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Exit class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfExit_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Exit_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Exit class");
	find mayInstanceOfExit_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Choice_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Choice class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfChoice_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Choice_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Choice class");
	find mayInstanceOfChoice_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Transition_class_by_outgoingTransitions_reference_Vertex_with_source_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Transition class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingTransitions reference Vertex");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"source reference Transition");
	find mustInstanceOfVertex_class(problem,interpretation,container);
	find mayInstanceOfTransition_class(problem,interpretation,newObject);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Transition_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Transition class");
	find mayInstanceOfTransition_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statechart_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statechart class UndefinedPart");
	find mayInstanceOfStatechart_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_State_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfState_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfState_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
}
pattern refineTypeTo_FinalState_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
}
pattern refineTypeTo_Synchronization_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
}
pattern refineTypeTo_Region_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
}
pattern refineTypeTo_Entry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
}
pattern refineTypeTo_Exit_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
}
pattern refineTypeTo_Choice_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
}
pattern refineTypeTo_Transition_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
}
pattern refineTypeTo_Statechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStatechart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_incomingTransitions_reference_Vertex_and_target_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incomingTransitions reference Vertex");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"target reference Transition");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVertex_class(problem,interpretation,from);
	find mustInstanceOfTransition_class(problem,interpretation,to);
	find mayInRelationincomingTransitions_reference_Vertex(problem,interpretation,from,to);
	neg find mustInRelationincomingTransitions_reference_Vertex(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Pseudostate class".
 */
private pattern mustInstanceOfPseudostate_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pseudostate class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPseudostate_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pseudostate class");
}

/**
 * An element may be an instance of type "Pseudostate class".
 */
private pattern mayInstanceOfPseudostate_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find scopeDisallowsNewPseudostate_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find scopeDisallowsNewPseudostate_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPseudostate_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Vertex class".
 */
private pattern mustInstanceOfVertex_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Vertex class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVertex_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Vertex class");
}

/**
 * An element may be an instance of type "Vertex class".
 */
private pattern mayInstanceOfVertex_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find scopeDisallowsNewVertex_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find scopeDisallowsNewVertex_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVertex_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Region class".
 */
private pattern mustInstanceOfRegion_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Region class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegion_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Region class");
}

/**
 * An element may be an instance of type "Region class".
 */
private pattern mayInstanceOfRegion_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegion_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegion_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegion_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Transition class".
 */
private pattern mustInstanceOfTransition_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Transition class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewTransition_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Transition class");
}

/**
 * An element may be an instance of type "Transition class".
 */
private pattern mayInstanceOfTransition_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewTransition_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find scopeDisallowsNewTransition_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfTransition_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statechart class".
 */
private pattern mustInstanceOfStatechart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statechart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatechart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statechart class");
}

/**
 * An element may be an instance of type "Statechart class".
 */
private pattern mayInstanceOfStatechart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatechart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Entry class".
 */
private pattern mustInstanceOfEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Entry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Entry class");
}

/**
 * An element may be an instance of type "Entry class".
 */
private pattern mayInstanceOfEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find scopeDisallowsNewEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find scopeDisallowsNewEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Synchronization class".
 */
private pattern mustInstanceOfSynchronization_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Synchronization class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSynchronization_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Synchronization class");
}

/**
 * An element may be an instance of type "Synchronization class".
 */
private pattern mayInstanceOfSynchronization_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find scopeDisallowsNewSynchronization_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find scopeDisallowsNewSynchronization_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSynchronization_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "State class".
 */
private pattern mustInstanceOfState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"State class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewState_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"State class");
}

/**
 * An element may be an instance of type "State class".
 */
private pattern mayInstanceOfState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find scopeDisallowsNewState_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find scopeDisallowsNewState_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularState class".
 */
private pattern mustInstanceOfRegularState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularState class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularState_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularState class");
}

/**
 * An element may be an instance of type "RegularState class".
 */
private pattern mayInstanceOfRegularState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularState_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularState_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeElement class".
 */
private pattern mustInstanceOfCompositeElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeElement class");
}

/**
 * An element may be an instance of type "CompositeElement class".
 */
private pattern mayInstanceOfCompositeElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCompositeElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Choice class".
 */
private pattern mustInstanceOfChoice_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Choice class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewChoice_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Choice class");
}

/**
 * An element may be an instance of type "Choice class".
 */
private pattern mayInstanceOfChoice_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find scopeDisallowsNewChoice_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find scopeDisallowsNewChoice_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfChoice_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Exit class".
 */
private pattern mustInstanceOfExit_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Exit class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExit_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Exit class");
}

/**
 * An element may be an instance of type "Exit class".
 */
private pattern mayInstanceOfExit_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find scopeDisallowsNewExit_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find scopeDisallowsNewExit_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExit_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FinalState class".
 */
private pattern mustInstanceOfFinalState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FinalState class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFinalState_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FinalState class");
}

/**
 * An element may be an instance of type "FinalState class".
 */
private pattern mayInstanceOfFinalState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find scopeDisallowsNewFinalState_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find scopeDisallowsNewFinalState_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFinalState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statechart class DefinedPart".
 */
private pattern mustInstanceOfStatechart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statechart class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatechart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statechart class DefinedPart");
}

/**
 * An element may be an instance of type "Statechart class DefinedPart".
 */
private pattern mayInstanceOfStatechart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfStatechart_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statechart class UndefinedPart".
 */
private pattern mustInstanceOfStatechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statechart class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statechart class UndefinedPart");
}

/**
 * An element may be an instance of type "Statechart class UndefinedPart".
 */
private pattern mayInstanceOfStatechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatechart_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeElement class DefinedPart".
 */
private pattern mustInstanceOfCompositeElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeElement class DefinedPart");
}

/**
 * An element may be an instance of type "CompositeElement class DefinedPart".
 */
private pattern mayInstanceOfCompositeElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfCompositeElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeElement class UndefinedPart".
 */
private pattern mustInstanceOfCompositeElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeElement class UndefinedPart");
}

/**
 * An element may be an instance of type "CompositeElement class UndefinedPart".
 */
private pattern mayInstanceOfCompositeElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []incomingTransitions reference Vertex(source,target)
 */
private pattern mustInRelationincomingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incomingTransitions reference Vertex");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>incomingTransitions reference Vertex(source,target)
 */
private pattern mayInRelationincomingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVertex_class(problem,interpretation,source);
	find mayInstanceOfTransition_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationtarget_reference_Transition(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationincomingTransitions_reference_Vertex(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingTransitions reference Vertex(source,target)
 */
private pattern mustInRelationoutgoingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingTransitions reference Vertex");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingTransitions reference Vertex(source,target)
 */
private pattern mayInRelationoutgoingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVertex_class(problem,interpretation,source);
	find mayInstanceOfTransition_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationsource_reference_Transition(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []vertices reference Region(source,target)
 */
private pattern mustInRelationvertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"vertices reference Region");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>vertices reference Region(source,target)
 */
private pattern mayInRelationvertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRegion_class(problem,interpretation,source);
	find mayInstanceOfVertex_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvertices_reference_Region(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []target reference Transition(source,target)
 */
private pattern mustInRelationtarget_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"target reference Transition");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>target reference Transition(source,target)
 */
private pattern mayInRelationtarget_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTransition_class(problem,interpretation,source);
	find mayInstanceOfVertex_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtarget_reference_Transition(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtarget_reference_Transition(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []source reference Transition(source,target)
 */
private pattern mustInRelationsource_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"source reference Transition");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>source reference Transition(source,target)
 */
private pattern mayInRelationsource_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTransition_class(problem,interpretation,source);
	find mayInstanceOfVertex_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationsource_reference_Transition(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsource_reference_Transition(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []regions reference CompositeElement(source,target)
 */
private pattern mustInRelationregions_reference_CompositeElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"regions reference CompositeElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>regions reference CompositeElement(source,target)
 */
private pattern mayInRelationregions_reference_CompositeElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfCompositeElement_class(problem,interpretation,source);
	find mayInstanceOfRegion_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries entryInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1, var_e1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	find mustInstanceOfEntry_class(problem,interpretation,var_e1);
	// r1 is exported
	// e1 is exported
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_e1;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1, var_e1)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_r1);
	find mayInstanceOfEntry_class(problem,interpretation,var_e1);
	// r1 is exported
	// e1 is exported
	find mayInstanceOfRegion_class(problem,interpretation,var_r1);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r1,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_e1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1, var_e1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	find mustInstanceOfEntry_class(problem,interpretation,var_e1);
	// r1 is exported
	// e1 is exported
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_e1;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries noEntryInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	// r1 is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r1,_var__0);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_r1);
	// r1 is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r1,_var__0);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	// r1 is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r1,_var__0);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries multipleEntryInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	// r is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e1);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e2);
	neg find mayEquivalent(problem, interpretation, var_e1, var_e2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	// r is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e1);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e2);
	var_e1 != var_e2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	// r is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e1);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_entryInRegion(problem,interpretation,var_r,var_e2);
	var_e1 != var_e2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries transition
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_src, var_trg)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfVertex_class(problem,interpretation,var_src);
	find mustInstanceOfVertex_class(problem,interpretation,var_trg);
	// t is exported
	// src is exported
	// trg is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_src;
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_trg;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_src, var_trg)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInstanceOfVertex_class(problem,interpretation,var_src);
	find mayInstanceOfVertex_class(problem,interpretation,var_trg);
	// t is exported
	// src is exported
	// trg is exported
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_src);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_trg);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_src, var_trg)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfVertex_class(problem,interpretation,var_src);
	find mustInstanceOfVertex_class(problem,interpretation,var_trg);
	// t is exported
	// src is exported
	// trg is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_src;
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_trg;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries incomingToEntry
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t,_var__0,var_e);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t,_var__0,var_e);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t,_var__0,var_e);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries noOutgoingTransitionFromEntry
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	// e is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_e,_var__1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	// e is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_e,_var__1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	// e is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_e,_var__1);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries multipleTransitionFromEntry
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	// e is exported
	// t1 is exported
	// t2 is exported
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t1;
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual1);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_t2;
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	find mayInstanceOfTransition_class(problem,interpretation,var_t1);
	find mayInstanceOfTransition_class(problem,interpretation,var_t2);
	// e is exported
	// t1 is exported
	// t2 is exported
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mayInstanceOfTransition_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_t1);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual1);
	find mayInstanceOfTransition_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_t2);
	var_t1 != var_t2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	// e is exported
	// t1 is exported
	// t2 is exported
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t1;
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual1);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_t2;
	var_t1 != var_t2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries outgoingFromExit
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInstanceOfExit_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mayInstanceOfExit_class(problem,interpretation,var_e);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mayInstanceOfTransition_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_t);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	// t is exported
	// e is exported
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries outgoingFromFinal
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	// t is exported
	// f is exported
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_f,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
	find mayInstanceOfFinalState_class(problem,interpretation,var_f);
	// t is exported
	// f is exported
	find mayInstanceOfFinalState_class(problem,interpretation,var_f);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_f,var_virtual0);
	find mayInstanceOfTransition_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_t);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	// t is exported
	// f is exported
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_f,var_virtual0);
	find mustInstanceOfTransition_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_t;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries noStateInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	// region is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(problem,interpretation,var_region,_var__0);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_region);
	// region is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(problem,interpretation,var_region,_var__0);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	// region is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(problem,interpretation,var_region,_var__0);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries StateInRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region, var_state)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	find mustInstanceOfState_class(problem,interpretation,var_state);
	// region is exported
	// state is exported
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_region,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_state;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region, var_state)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_region);
	find mayInstanceOfState_class(problem,interpretation,var_state);
	// region is exported
	// state is exported
	find mayInstanceOfRegion_class(problem,interpretation,var_region);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_region,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_state);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_StateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region, var_state)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	find mustInstanceOfState_class(problem,interpretation,var_state);
	// region is exported
	// state is exported
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_region,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_state;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries choiceHasNoOutgoing
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_c,_var__1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_c,_var__1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_c,_var__1);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries choiceHasNoIncoming
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_c);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_c);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	// c is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_c);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries synchHasNoOutgoing
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,_var__1);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,_var__1);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,_var__1);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries synchHasNoIncoming
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_s);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_s);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,_var__1,var_s);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries SynchronizedIncomingInSameRegion
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_v1,var_s);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_v2,var_s);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_v1;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v2;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_s,var_v1);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_s,var_v2);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_v1;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v2;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v1);
	find mayInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_v1,var_s);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_v2,var_s);
	var_t1 != var_t2;
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_v1);
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_v2);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v1);
	find mayInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_s,var_v1);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_s,var_v2);
	var_t1 != var_t2;
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_v1);
	find mayInstanceOfRegion_class(problem,interpretation,var_r);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_v2);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_v1,var_s);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_v2,var_s);
	var_t1 != var_t2;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_v1;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v2;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t1,var_s,var_v1);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,var_t2,var_s,var_v2);
	var_t1 != var_t2;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_v1;
	find mustInstanceOfRegion_class(problem,interpretation,var_r);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries notSynchronizingStates
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(problem,interpretation,var_s);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(problem,interpretation,var_s);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(problem,interpretation,var_s);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(problem,interpretation,var_s);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(problem,interpretation,var_s);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(problem,interpretation,var_s);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries hasMultipleOutgoingTrainsition
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_trg1);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v,var_trg2);
	neg find mayEquivalent(problem, interpretation, var_trg1, var_trg2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_trg1);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v,var_trg2);
	var_trg1 != var_trg2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleOutgoingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_trg1);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v,var_trg2);
	var_trg1 != var_trg2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries hasMultipleIncomingTrainsition
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_src1,var_v);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_src2,var_v);
	neg find mayEquivalent(problem, interpretation, var_src1, var_src2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_src1,var_v);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_src2,var_v);
	var_src1 != var_src2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleIncomingTrainsition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_v);
	// v is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_src1,var_v);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_src2,var_v);
	var_src1 != var_src2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries SynchronizedRegionsAreNotSiblings
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v1,var_s);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v2,var_s);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual3);
	var_virtual3 == var_v2;
	neg find mayEquivalent(problem, interpretation, var_r1, var_r2);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v1);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_s,var_v2);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual3);
	var_virtual3 == var_v2;
	neg find mayEquivalent(problem, interpretation, var_r1, var_r2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v1);
	find mayInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v1,var_s);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v2,var_s);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_v1);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual3);
	find mayEquivalent(problem, interpretation, var_virtual3, var_v2);
	var_r1 != var_r2;
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v1);
	find mayInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v1);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_s,var_v2);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_v1);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual3);
	find mayEquivalent(problem, interpretation, var_virtual3, var_v2);
	var_r1 != var_r2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v1,var_s);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_v2,var_s);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual3);
	var_virtual3 == var_v2;
	var_r1 != var_r2;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v1);
	find mustInstanceOfVertex_class(problem,interpretation,var_v2);
	// s is exported
	// v1 is exported
	// v2 is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v1);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__1,var_s,var_v2);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r1);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r1,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_v1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_r2);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_r2,var_virtual2);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual2);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual2,var_virtual3);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual3);
	var_virtual3 == var_v2;
	var_r1 != var_r2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries child
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mustInstanceOfVertex_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_child;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mayInstanceOfVertex_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_parent,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_child);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mustInstanceOfVertex_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_parent);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_virtual0,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_child;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries SynchronizedRegionDoesNotHaveMultipleRegions
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_s);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_s);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mayInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_v,var_s);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	find mustInstanceOfVertex_class(problem,interpretation,var_v);
	// s is exported
	// v is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_transition(problem,interpretation,_var__0,var_s,var_v);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_child(problem,interpretation,var_c,var_v);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(problem,interpretation,var_c);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries hasMultipleRegions
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_composite)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	// composite is exported
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_region1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual1);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_region2;
	neg find mayEquivalent(problem, interpretation, var_region1, var_region2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_composite)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	// composite is exported
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_region1);
	find mayInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual1);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_region2);
	var_region1 != var_region2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_hasMultipleRegions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_composite)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	// composite is exported
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_region1;
	find mustInstanceOfCompositeElement_class(problem,interpretation,var_composite);
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,var_composite,var_virtual1);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_region2;
	var_region1 != var_region2;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries synchThree
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t3);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual2);
	var_virtual2 == var_s;
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
	neg find mayEquivalent(problem, interpretation, var_t2, var_t3);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t3);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t3);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual2);
	var_virtual2 == var_s;
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
	neg find mayEquivalent(problem, interpretation, var_t2, var_t3);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t3);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mayInstanceOfTransition_class(problem,interpretation,var_t1);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_s);
	find mayInstanceOfTransition_class(problem,interpretation,var_t2);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_s);
	find mayInstanceOfTransition_class(problem,interpretation,var_t3);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual2);
	find mayEquivalent(problem, interpretation, var_virtual2, var_s);
	var_t1 != var_t2;
	var_t2 != var_t3;
	var_t1 != var_t3;
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mayInstanceOfTransition_class(problem,interpretation,var_t1);
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_s);
	find mayInstanceOfTransition_class(problem,interpretation,var_t2);
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_s);
	find mayInstanceOfTransition_class(problem,interpretation,var_t3);
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mayInstanceOfVertex_class(problem,interpretation,var_virtual2);
	find mayEquivalent(problem, interpretation, var_virtual2, var_s);
	var_t1 != var_t2;
	var_t2 != var_t3;
	var_t1 != var_t3;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t3);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual2);
	var_virtual2 == var_s;
	var_t1 != var_t2;
	var_t2 != var_t3;
	var_t1 != var_t3;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s);
	// s is exported
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t1,var_virtual0);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t2,var_virtual1);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_s;
	find mustInstanceOfTransition_class(problem,interpretation,var_t3);
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t3,var_virtual2);
	find mustInstanceOfVertex_class(problem,interpretation,var_virtual2);
	var_virtual2 == var_s;
	var_t1 != var_t2;
	var_t2 != var_t3;
	var_t1 != var_t3;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test yakindu queries twoSynch
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s2);
	// s1 is exported
	// s2 is exported
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s2);
	neg find mayEquivalent(problem, interpretation, var_s1, var_s2);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s2);
	// s1 is exported
	// s2 is exported
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mayInstanceOfSynchronization_class(problem,interpretation,var_s2);
	var_s1 != var_s2;
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s2);
	// s1 is exported
	// s2 is exported
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s1);
	find mustInstanceOfSynchronization_class(problem,interpretation,var_s2);
	var_s1 != var_s2;
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,source,target); }or
	
	{ find mustInRelationvertices_reference_Region(problem,interpretation,source,target); }or
	
	{ find mustInRelationregions_reference_CompositeElement(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(problem,interpretation,var_r1);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(problem,interpretation,var_r);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(problem,interpretation,var_t,var_e);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(problem,interpretation,var_e);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(problem,interpretation,var_e,var_t1,var_t2);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(problem,interpretation,var_t,var_e);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(problem,interpretation,var_t,var_f);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(problem,interpretation,var_region);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(problem,interpretation,var_c);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(problem,interpretation,var_c);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(problem,interpretation,var_s);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(problem,interpretation,var_s);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(problem,interpretation,var_s,var_v1,var_v2);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(problem,interpretation,var_s);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(problem,interpretation,var_s,var_v1,var_v2);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(problem,interpretation,var_s,var_v);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(problem,interpretation,var_s);
}
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(problem,interpretation,var_s1,var_s2);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_target_reference_Transition(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"target reference Transition");
	find mustInstanceOfTransition_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtarget_reference_Transition(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noEntryInRegion(problem,interpretation,var_r1);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleEntryInRegion(problem,interpretation,var_r);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_incomingToEntry(problem,interpretation,var_t,var_e);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noOutgoingTransitionFromEntry(problem,interpretation,var_e);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_multipleTransitionFromEntry(problem,interpretation,var_e,var_t1,var_t2);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromExit(problem,interpretation,var_t,var_e);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_outgoingFromFinal(problem,interpretation,var_t,var_f);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_noStateInRegion(problem,interpretation,var_region);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoOutgoing(problem,interpretation,var_c);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_choiceHasNoIncoming(problem,interpretation,var_c);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoOutgoing(problem,interpretation,var_s);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchHasNoIncoming(problem,interpretation,var_s);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedIncomingInSameRegion(problem,interpretation,var_s,var_v1,var_v2);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_notSynchronizingStates(problem,interpretation,var_s);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v1, var_v2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionsAreNotSiblings(problem,interpretation,var_s,var_v1,var_v2);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s, var_v)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_SynchronizedRegionDoesNotHaveMultipleRegions(problem,interpretation,var_s,var_v);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_synchThree(problem,interpretation,var_s);
}
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(problem:LogicProblem, interpretation:PartialInterpretation,
	var_s1, var_s2)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_yakindu_queries_twoSynch(problem,interpretation,var_s1,var_s2);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPseudostate_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVertex_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExit_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFinalState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatechart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatechart_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatechart_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Choice_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Choice class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfChoice_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Choice_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Choice class");
	find mayInstanceOfChoice_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statechart_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statechart class UndefinedPart");
	find mayInstanceOfStatechart_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FinalState_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FinalState class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfFinalState_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FinalState_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FinalState class");
	find mayInstanceOfFinalState_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Region_class_by_regions_reference_CompositeElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Region class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"regions reference CompositeElement");
	find mustInstanceOfCompositeElement_class(problem,interpretation,container);
	find mayInstanceOfRegion_class(problem,interpretation,newObject);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Region_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Region class");
	find mayInstanceOfRegion_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Entry_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Entry class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfEntry_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Entry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Entry class");
	find mayInstanceOfEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Exit_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Exit class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfExit_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Exit_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Exit class");
	find mayInstanceOfExit_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_State_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"State class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfState_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_State_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"State class");
	find mayInstanceOfState_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Transition_class_by_outgoingTransitions_reference_Vertex_with_source_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Transition class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingTransitions reference Vertex");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"source reference Transition");
	find mustInstanceOfVertex_class(problem,interpretation,container);
	find mayInstanceOfTransition_class(problem,interpretation,newObject);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Transition_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Transition class");
	find mayInstanceOfTransition_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Synchronization_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Synchronization class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfSynchronization_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Synchronization_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Synchronization class");
	find mayInstanceOfSynchronization_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Choice_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
}
pattern refineTypeTo_Statechart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStatechart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
}
pattern refineTypeTo_FinalState_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
}
pattern refineTypeTo_Region_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
}
pattern refineTypeTo_Entry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
}
pattern refineTypeTo_Exit_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
}
pattern refineTypeTo_State_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfState_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfState_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
}
pattern refineTypeTo_Transition_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
}
pattern refineTypeTo_Synchronization_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_incomingTransitions_reference_Vertex_and_target_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incomingTransitions reference Vertex");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"target reference Transition");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVertex_class(problem,interpretation,from);
	find mustInstanceOfTransition_class(problem,interpretation,to);
	find mayInRelationincomingTransitions_reference_Vertex(problem,interpretation,from,to);
	neg find mustInRelationincomingTransitions_reference_Vertex(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FileSystem class".
 */
private pattern mustInstanceOfFileSystem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FileSystem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFileSystem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FileSystem class");
}

/**
 * An element may be an instance of type "FileSystem class".
 */
private pattern mayInstanceOfFileSystem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewFileSystem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewFileSystem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFileSystem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FSObject class".
 */
private pattern mustInstanceOfFSObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FSObject class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFSObject_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FSObject class");
}

/**
 * An element may be an instance of type "FSObject class".
 */
private pattern mayInstanceOfFSObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find scopeDisallowsNewFSObject_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find scopeDisallowsNewFSObject_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFSObject_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Dir class".
 */
private pattern mustInstanceOfDir_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Dir class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewDir_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Dir class");
}

/**
 * An element may be an instance of type "Dir class".
 */
private pattern mayInstanceOfDir_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find scopeDisallowsNewDir_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find scopeDisallowsNewDir_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfDir_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "File class".
 */
private pattern mustInstanceOfFile_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"File class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFile_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"File class");
}

/**
 * An element may be an instance of type "File class".
 */
private pattern mayInstanceOfFile_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find scopeDisallowsNewFile_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find scopeDisallowsNewFile_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFile_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Model class".
 */
private pattern mustInstanceOfModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Model class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Model class");
}

/**
 * An element may be an instance of type "Model class".
 */
private pattern mayInstanceOfModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Model class DefinedPart".
 */
private pattern mustInstanceOfModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Model class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Model class DefinedPart");
}

/**
 * An element may be an instance of type "Model class DefinedPart".
 */
private pattern mayInstanceOfModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Model class UndefinedPart".
 */
private pattern mustInstanceOfModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Model class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Model class UndefinedPart");
}

/**
 * An element may be an instance of type "Model class UndefinedPart".
 */
private pattern mayInstanceOfModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []root reference FileSystem(source,target)
 */
private pattern mustInRelationroot_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"root reference FileSystem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>root reference FileSystem(source,target)
 */
private pattern mayInRelationroot_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFileSystem_class(problem,interpretation,source);
	find mayInstanceOfDir_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationroot_reference_FileSystem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationroot_reference_FileSystem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []live reference FileSystem(source,target)
 */
 private pattern mustInRelationlive_reference_FileSystem(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []live reference FileSystem(source,target)
 */
 private pattern mayInRelationlive_reference_FileSystem(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []parent reference FSObject(source,target)
 */
private pattern mustInRelationparent_reference_FSObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FSObject");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FSObject(source,target)
 */
private pattern mayInRelationparent_reference_FSObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFSObject_class(problem,interpretation,source);
	find mayInstanceOfDir_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FSObject(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FSObject(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []contents reference Dir(source,target)
 */
private pattern mustInRelationcontents_reference_Dir(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"contents reference Dir");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>contents reference Dir(source,target)
 */
private pattern mayInRelationcontents_reference_Dir(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfDir_class(problem,interpretation,source);
	find mayInstanceOfFSObject_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FSObject(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationcontents_reference_Dir(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []filesystems reference Model(source,target)
 */
private pattern mustInRelationfilesystems_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"filesystems reference Model");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>filesystems reference Model(source,target)
 */
private pattern mayInRelationfilesystems_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfModel_class(problem,interpretation,source);
	find mayInstanceOfFileSystem_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfilesystems_reference_Model(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfilesystems_reference_Model(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []otherFSObjects reference Model(source,target)
 */
private pattern mustInRelationotherFSObjects_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"otherFSObjects reference Model");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>otherFSObjects reference Model(source,target)
 */
private pattern mayInRelationotherFSObjects_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfModel_class(problem,interpretation,source);
	find mayInstanceOfFSObject_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationotherFSObjects_reference_Model(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test filesystem queries patternContent
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1, var_o2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFSObject_class(problem,interpretation,var_o1);
	find mustInstanceOfFSObject_class(problem,interpretation,var_o2);
	// o1 is exported
	// o2 is exported
	find mustInstanceOfDir_class(problem,interpretation,var_o1);
	find mustInRelationcontents_reference_Dir(problem,interpretation,var_o1,var_virtual0);
	find mustInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_o2;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1, var_o2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFSObject_class(problem,interpretation,var_o1);
	find mayInstanceOfFSObject_class(problem,interpretation,var_o2);
	// o1 is exported
	// o2 is exported
	find mayInstanceOfDir_class(problem,interpretation,var_o1);
	find mayInRelationcontents_reference_Dir(problem,interpretation,var_o1,var_virtual0);
	find mayInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_o2);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1, var_o2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFSObject_class(problem,interpretation,var_o1);
	find mustInstanceOfFSObject_class(problem,interpretation,var_o2);
	// o1 is exported
	// o2 is exported
	find mustInstanceOfDir_class(problem,interpretation,var_o1);
	find mustInRelationcontents_reference_Dir(problem,interpretation,var_o1,var_virtual0);
	find mustInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_o2;
}
private pattern twoParam_mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(var_o1, var_o2) {
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(_,_,var_o1, var_o2);
}
private pattern twoParam_mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(var_o1, var_o2) {
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(_,_,var_o1, var_o2);
}
private pattern twoParam_currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(var_o1, var_o2) {
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(_,_,var_o1, var_o2);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test filesystem queries live
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_this, var_l)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInstanceOfFSObject_class(problem,interpretation,var_l);
	// this is exported
	// l is exported
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInRelationroot_reference_FileSystem(problem,interpretation,var_this,var_virtual0);
	find mustInstanceOfDir_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_l;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInstanceOfFSObject_class(problem,interpretation,var_l);
	// this is exported
	// l is exported
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInRelationroot_reference_FileSystem(problem,interpretation,var_this,var_virtual0);
	find mustInstanceOfDir_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_root;
	find twoParam_mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent+(var_root,var_l);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_this, var_l)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mayInstanceOfFSObject_class(problem,interpretation,var_l);
	// this is exported
	// l is exported
	find mayInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mayInRelationroot_reference_FileSystem(problem,interpretation,var_this,var_virtual0);
	find mayInstanceOfDir_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_l);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mayInstanceOfFSObject_class(problem,interpretation,var_l);
	// this is exported
	// l is exported
	find mayInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mayInRelationroot_reference_FileSystem(problem,interpretation,var_this,var_virtual0);
	find mayInstanceOfDir_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_root);
	find twoParam_mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent+(var_root,var_l);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_this, var_l)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInstanceOfFSObject_class(problem,interpretation,var_l);
	// this is exported
	// l is exported
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInRelationroot_reference_FileSystem(problem,interpretation,var_this,var_virtual0);
	find mustInstanceOfDir_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_l;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInstanceOfFSObject_class(problem,interpretation,var_l);
	// this is exported
	// l is exported
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInRelationroot_reference_FileSystem(problem,interpretation,var_this,var_virtual0);
	find mustInstanceOfDir_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_root;
	find twoParam_currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent+(var_root,var_l);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test filesystem queries contentInNotLive
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInstanceOfFSObject_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInRelationcontents_reference_Dir(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_child;
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,_var__0,var_parent);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInstanceOfFSObject_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInRelationcontents_reference_Dir(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_child;
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,_var__0,var_child);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfDir_class(problem,interpretation,var_parent);
	find mayInstanceOfFSObject_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mayInstanceOfDir_class(problem,interpretation,var_parent);
	find mayInRelationcontents_reference_Dir(problem,interpretation,var_parent,var_virtual0);
	find mayInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_child);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,_var__0,var_parent);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfDir_class(problem,interpretation,var_parent);
	find mayInstanceOfFSObject_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mayInstanceOfDir_class(problem,interpretation,var_parent);
	find mayInRelationcontents_reference_Dir(problem,interpretation,var_parent,var_virtual0);
	find mayInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_child);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,_var__0,var_child);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInstanceOfFSObject_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInRelationcontents_reference_Dir(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_child;
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,_var__0,var_parent);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInstanceOfFSObject_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInRelationcontents_reference_Dir(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_child;
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,_var__0,var_child);
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationroot_reference_FileSystem(problem,interpretation,source,target); }or
	
	{ find mustInRelationcontents_reference_Dir(problem,interpretation,source,target); }or
	
	{ find mustInRelationfilesystems_reference_Model(problem,interpretation,source,target); }or
	
	{ find mustInRelationotherFSObjects_reference_Model(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(problem,interpretation,var_parent,var_child);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_root_reference_FileSystem(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"root reference FileSystem");
	find mustInstanceOfFileSystem_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationroot_reference_FileSystem(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_filesystems_reference_Model(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"filesystems reference Model");
	find mustInstanceOfModel_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationfilesystems_reference_Model(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(problem,interpretation,var_parent,var_child);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFile_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFSObject_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFileSystem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfDir_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FileSystem_class_by_filesystems_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FileSystem class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"filesystems reference Model");
	find mustInstanceOfModel_class(problem,interpretation,container);
	find mayInstanceOfFileSystem_class(problem,interpretation,newObject);
	find mayInRelationfilesystems_reference_Model(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FileSystem_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FileSystem class");
	find mayInstanceOfFileSystem_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_File_class_by_contents_reference_Dir_with_parent_reference_FSObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"File class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"contents reference Dir");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FSObject");
	find mustInstanceOfDir_class(problem,interpretation,container);
	find mayInstanceOfFile_class(problem,interpretation,newObject);
	find mayInRelationcontents_reference_Dir(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_File_class_by_otherFSObjects_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"File class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"otherFSObjects reference Model");
	find mustInstanceOfModel_class(problem,interpretation,container);
	find mayInstanceOfFile_class(problem,interpretation,newObject);
	find mayInRelationotherFSObjects_reference_Model(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_File_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"File class");
	find mayInstanceOfFile_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Model_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Model class UndefinedPart");
	find mayInstanceOfModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dir_class_by_root_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dir class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"root reference FileSystem");
	find mustInstanceOfFileSystem_class(problem,interpretation,container);
	find mayInstanceOfDir_class(problem,interpretation,newObject);
	find mayInRelationroot_reference_FileSystem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dir_class_by_contents_reference_Dir_with_parent_reference_FSObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dir class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"contents reference Dir");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FSObject");
	find mustInstanceOfDir_class(problem,interpretation,container);
	find mayInstanceOfDir_class(problem,interpretation,newObject);
	find mayInRelationcontents_reference_Dir(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dir_class_by_otherFSObjects_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dir class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"otherFSObjects reference Model");
	find mustInstanceOfModel_class(problem,interpretation,container);
	find mayInstanceOfDir_class(problem,interpretation,newObject);
	find mayInRelationotherFSObjects_reference_Model(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dir_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dir class");
	find mayInstanceOfDir_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FileSystem_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
}
pattern refineTypeTo_File_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
}
pattern refineTypeTo_Model_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
}
pattern refineTypeTo_Dir_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_live_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"live reference FileSystem");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFileSystem_class(problem,interpretation,from);
	find mustInstanceOfFSObject_class(problem,interpretation,to);
	find mayInRelationlive_reference_FileSystem(problem,interpretation,from,to);
	neg find mustInRelationlive_reference_FileSystem(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FileSystem class".
 */
private pattern mustInstanceOfFileSystem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FileSystem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFileSystem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FileSystem class");
}

/**
 * An element may be an instance of type "FileSystem class".
 */
private pattern mayInstanceOfFileSystem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFileSystem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFileSystem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFileSystem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FSObject class".
 */
private pattern mustInstanceOfFSObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FSObject class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFSObject_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FSObject class");
}

/**
 * An element may be an instance of type "FSObject class".
 */
private pattern mayInstanceOfFSObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFSObject_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFSObject_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFSObject_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Dir class".
 */
private pattern mustInstanceOfDir_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Dir class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewDir_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Dir class");
}

/**
 * An element may be an instance of type "Dir class".
 */
private pattern mayInstanceOfDir_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewDir_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewDir_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfDir_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "File class".
 */
private pattern mustInstanceOfFile_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"File class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFile_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"File class");
}

/**
 * An element may be an instance of type "File class".
 */
private pattern mayInstanceOfFile_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find scopeDisallowsNewFile_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find scopeDisallowsNewFile_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFile_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Model class".
 */
private pattern mustInstanceOfModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Model class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Model class");
}

/**
 * An element may be an instance of type "Model class".
 */
private pattern mayInstanceOfModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Model class DefinedPart".
 */
private pattern mustInstanceOfModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Model class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Model class DefinedPart");
}

/**
 * An element may be an instance of type "Model class DefinedPart".
 */
private pattern mayInstanceOfModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Model class UndefinedPart".
 */
private pattern mustInstanceOfModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Model class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Model class UndefinedPart");
}

/**
 * An element may be an instance of type "Model class UndefinedPart".
 */
private pattern mayInstanceOfModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []root reference FileSystem(source,target)
 */
private pattern mustInRelationroot_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"root reference FileSystem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>root reference FileSystem(source,target)
 */
private pattern mayInRelationroot_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFileSystem_class(problem,interpretation,source);
	find mayInstanceOfDir_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationroot_reference_FileSystem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationroot_reference_FileSystem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []live reference FileSystem(source,target)
 */
 private pattern mustInRelationlive_reference_FileSystem(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []live reference FileSystem(source,target)
 */
 private pattern mayInRelationlive_reference_FileSystem(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []parent reference FSObject(source,target)
 */
private pattern mustInRelationparent_reference_FSObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FSObject");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FSObject(source,target)
 */
private pattern mayInRelationparent_reference_FSObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFSObject_class(problem,interpretation,source);
	find mayInstanceOfDir_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FSObject(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FSObject(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []contents reference Dir(source,target)
 */
private pattern mustInRelationcontents_reference_Dir(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"contents reference Dir");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>contents reference Dir(source,target)
 */
private pattern mayInRelationcontents_reference_Dir(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfDir_class(problem,interpretation,source);
	find mayInstanceOfFSObject_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FSObject(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationcontents_reference_Dir(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []filesystems reference Model(source,target)
 */
private pattern mustInRelationfilesystems_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"filesystems reference Model");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>filesystems reference Model(source,target)
 */
private pattern mayInRelationfilesystems_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfModel_class(problem,interpretation,source);
	find mayInstanceOfFileSystem_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfilesystems_reference_Model(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfilesystems_reference_Model(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []otherFSObjects reference Model(source,target)
 */
private pattern mustInRelationotherFSObjects_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"otherFSObjects reference Model");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>otherFSObjects reference Model(source,target)
 */
private pattern mayInRelationotherFSObjects_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfModel_class(problem,interpretation,source);
	find mayInstanceOfFSObject_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationotherFSObjects_reference_Model(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test filesystem queries patternContent
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1, var_o2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFSObject_class(problem,interpretation,var_o1);
	find mustInstanceOfFSObject_class(problem,interpretation,var_o2);
	// o1 is exported
	// o2 is exported
	find mustInstanceOfDir_class(problem,interpretation,var_o1);
	find mustInRelationcontents_reference_Dir(problem,interpretation,var_o1,var_virtual0);
	find mustInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_o2;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1, var_o2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFSObject_class(problem,interpretation,var_o1);
	find mayInstanceOfFSObject_class(problem,interpretation,var_o2);
	// o1 is exported
	// o2 is exported
	find mayInstanceOfDir_class(problem,interpretation,var_o1);
	find mayInRelationcontents_reference_Dir(problem,interpretation,var_o1,var_virtual0);
	find mayInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_o2);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1, var_o2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFSObject_class(problem,interpretation,var_o1);
	find mustInstanceOfFSObject_class(problem,interpretation,var_o2);
	// o1 is exported
	// o2 is exported
	find mustInstanceOfDir_class(problem,interpretation,var_o1);
	find mustInRelationcontents_reference_Dir(problem,interpretation,var_o1,var_virtual0);
	find mustInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_o2;
}
private pattern twoParam_mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(var_o1, var_o2) {
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(_,_,var_o1, var_o2);
}
private pattern twoParam_mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(var_o1, var_o2) {
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(_,_,var_o1, var_o2);
}
private pattern twoParam_currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(var_o1, var_o2) {
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(_,_,var_o1, var_o2);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test filesystem queries live
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_this, var_l)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInstanceOfFSObject_class(problem,interpretation,var_l);
	// this is exported
	// l is exported
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInRelationroot_reference_FileSystem(problem,interpretation,var_this,var_virtual0);
	find mustInstanceOfDir_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_l;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInstanceOfFSObject_class(problem,interpretation,var_l);
	// this is exported
	// l is exported
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInRelationroot_reference_FileSystem(problem,interpretation,var_this,var_virtual0);
	find mustInstanceOfDir_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_root;
	find twoParam_mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent+(var_root,var_l);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_this, var_l)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mayInstanceOfFSObject_class(problem,interpretation,var_l);
	// this is exported
	// l is exported
	find mayInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mayInRelationroot_reference_FileSystem(problem,interpretation,var_this,var_virtual0);
	find mayInstanceOfDir_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_l);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mayInstanceOfFSObject_class(problem,interpretation,var_l);
	// this is exported
	// l is exported
	find mayInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mayInRelationroot_reference_FileSystem(problem,interpretation,var_this,var_virtual0);
	find mayInstanceOfDir_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_root);
	find twoParam_mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent+(var_root,var_l);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_this, var_l)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInstanceOfFSObject_class(problem,interpretation,var_l);
	// this is exported
	// l is exported
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInRelationroot_reference_FileSystem(problem,interpretation,var_this,var_virtual0);
	find mustInstanceOfDir_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_l;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInstanceOfFSObject_class(problem,interpretation,var_l);
	// this is exported
	// l is exported
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInRelationroot_reference_FileSystem(problem,interpretation,var_this,var_virtual0);
	find mustInstanceOfDir_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_root;
	find twoParam_currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent+(var_root,var_l);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test filesystem queries contentInNotLive
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInstanceOfFSObject_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInRelationcontents_reference_Dir(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_child;
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,_var__0,var_parent);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInstanceOfFSObject_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInRelationcontents_reference_Dir(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_child;
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,_var__0,var_child);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfDir_class(problem,interpretation,var_parent);
	find mayInstanceOfFSObject_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mayInstanceOfDir_class(problem,interpretation,var_parent);
	find mayInRelationcontents_reference_Dir(problem,interpretation,var_parent,var_virtual0);
	find mayInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_child);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,_var__0,var_parent);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfDir_class(problem,interpretation,var_parent);
	find mayInstanceOfFSObject_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mayInstanceOfDir_class(problem,interpretation,var_parent);
	find mayInRelationcontents_reference_Dir(problem,interpretation,var_parent,var_virtual0);
	find mayInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_child);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,_var__0,var_child);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInstanceOfFSObject_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInRelationcontents_reference_Dir(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_child;
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,_var__0,var_parent);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInstanceOfFSObject_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInRelationcontents_reference_Dir(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_child;
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,_var__0,var_child);
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationroot_reference_FileSystem(problem,interpretation,source,target); }or
	
	{ find mustInRelationcontents_reference_Dir(problem,interpretation,source,target); }or
	
	{ find mustInRelationfilesystems_reference_Model(problem,interpretation,source,target); }or
	
	{ find mustInRelationotherFSObjects_reference_Model(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(problem,interpretation,var_parent,var_child);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_root_reference_FileSystem(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"root reference FileSystem");
	find mustInstanceOfFileSystem_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationroot_reference_FileSystem(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_filesystems_reference_Model(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"filesystems reference Model");
	find mustInstanceOfModel_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationfilesystems_reference_Model(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(problem,interpretation,var_parent,var_child);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFile_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFSObject_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFileSystem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfDir_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Model_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Model class UndefinedPart");
	find mayInstanceOfModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_File_class_by_contents_reference_Dir_with_parent_reference_FSObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"File class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"contents reference Dir");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FSObject");
	find mustInstanceOfDir_class(problem,interpretation,container);
	find mayInstanceOfFile_class(problem,interpretation,newObject);
	find mayInRelationcontents_reference_Dir(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_File_class_by_otherFSObjects_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"File class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"otherFSObjects reference Model");
	find mustInstanceOfModel_class(problem,interpretation,container);
	find mayInstanceOfFile_class(problem,interpretation,newObject);
	find mayInRelationotherFSObjects_reference_Model(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_File_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"File class");
	find mayInstanceOfFile_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FileSystem_class_by_filesystems_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FileSystem class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"filesystems reference Model");
	find mustInstanceOfModel_class(problem,interpretation,container);
	find mayInstanceOfFileSystem_class(problem,interpretation,newObject);
	find mayInRelationfilesystems_reference_Model(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FileSystem_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FileSystem class");
	find mayInstanceOfFileSystem_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dir_class_by_root_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dir class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"root reference FileSystem");
	find mustInstanceOfFileSystem_class(problem,interpretation,container);
	find mayInstanceOfDir_class(problem,interpretation,newObject);
	find mayInRelationroot_reference_FileSystem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dir_class_by_contents_reference_Dir_with_parent_reference_FSObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dir class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"contents reference Dir");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FSObject");
	find mustInstanceOfDir_class(problem,interpretation,container);
	find mayInstanceOfDir_class(problem,interpretation,newObject);
	find mayInRelationcontents_reference_Dir(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dir_class_by_otherFSObjects_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dir class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"otherFSObjects reference Model");
	find mustInstanceOfModel_class(problem,interpretation,container);
	find mayInstanceOfDir_class(problem,interpretation,newObject);
	find mayInRelationotherFSObjects_reference_Model(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dir_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dir class");
	find mayInstanceOfDir_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Model_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
}
pattern refineTypeTo_File_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
}
pattern refineTypeTo_FileSystem_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
}
pattern refineTypeTo_Dir_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_live_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"live reference FileSystem");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFileSystem_class(problem,interpretation,from);
	find mustInstanceOfFSObject_class(problem,interpretation,to);
	find mayInRelationlive_reference_FileSystem(problem,interpretation,from,to);
	neg find mustInRelationlive_reference_FileSystem(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FileSystem class".
 */
private pattern mustInstanceOfFileSystem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FileSystem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFileSystem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FileSystem class");
}

/**
 * An element may be an instance of type "FileSystem class".
 */
private pattern mayInstanceOfFileSystem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFileSystem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFileSystem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFileSystem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FSObject class".
 */
private pattern mustInstanceOfFSObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FSObject class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFSObject_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FSObject class");
}

/**
 * An element may be an instance of type "FSObject class".
 */
private pattern mayInstanceOfFSObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFSObject_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFSObject_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFSObject_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Dir class".
 */
private pattern mustInstanceOfDir_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Dir class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewDir_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Dir class");
}

/**
 * An element may be an instance of type "Dir class".
 */
private pattern mayInstanceOfDir_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewDir_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewDir_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfDir_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "File class".
 */
private pattern mustInstanceOfFile_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"File class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFile_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"File class");
}

/**
 * An element may be an instance of type "File class".
 */
private pattern mayInstanceOfFile_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFile_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFile_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFile_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Model class".
 */
private pattern mustInstanceOfModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Model class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Model class");
}

/**
 * An element may be an instance of type "Model class".
 */
private pattern mayInstanceOfModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Model class DefinedPart".
 */
private pattern mustInstanceOfModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Model class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Model class DefinedPart");
}

/**
 * An element may be an instance of type "Model class DefinedPart".
 */
private pattern mayInstanceOfModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Model class UndefinedPart".
 */
private pattern mustInstanceOfModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Model class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Model class UndefinedPart");
}

/**
 * An element may be an instance of type "Model class UndefinedPart".
 */
private pattern mayInstanceOfModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find scopeDisallowsNewModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []root reference FileSystem(source,target)
 */
private pattern mustInRelationroot_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"root reference FileSystem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>root reference FileSystem(source,target)
 */
private pattern mayInRelationroot_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFileSystem_class(problem,interpretation,source);
	find mayInstanceOfDir_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationroot_reference_FileSystem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationroot_reference_FileSystem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []live reference FileSystem(source,target)
 */
 private pattern mustInRelationlive_reference_FileSystem(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []live reference FileSystem(source,target)
 */
 private pattern mayInRelationlive_reference_FileSystem(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []parent reference FSObject(source,target)
 */
private pattern mustInRelationparent_reference_FSObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FSObject");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FSObject(source,target)
 */
private pattern mayInRelationparent_reference_FSObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFSObject_class(problem,interpretation,source);
	find mayInstanceOfDir_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FSObject(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FSObject(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []contents reference Dir(source,target)
 */
private pattern mustInRelationcontents_reference_Dir(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"contents reference Dir");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>contents reference Dir(source,target)
 */
private pattern mayInRelationcontents_reference_Dir(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfDir_class(problem,interpretation,source);
	find mayInstanceOfFSObject_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FSObject(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationcontents_reference_Dir(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []filesystems reference Model(source,target)
 */
private pattern mustInRelationfilesystems_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"filesystems reference Model");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>filesystems reference Model(source,target)
 */
private pattern mayInRelationfilesystems_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfModel_class(problem,interpretation,source);
	find mayInstanceOfFileSystem_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfilesystems_reference_Model(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfilesystems_reference_Model(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []otherFSObjects reference Model(source,target)
 */
private pattern mustInRelationotherFSObjects_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"otherFSObjects reference Model");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>otherFSObjects reference Model(source,target)
 */
private pattern mayInRelationotherFSObjects_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfModel_class(problem,interpretation,source);
	find mayInstanceOfFSObject_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationotherFSObjects_reference_Model(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test filesystem queries patternContent
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1, var_o2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFSObject_class(problem,interpretation,var_o1);
	find mustInstanceOfFSObject_class(problem,interpretation,var_o2);
	// o1 is exported
	// o2 is exported
	find mustInstanceOfDir_class(problem,interpretation,var_o1);
	find mustInRelationcontents_reference_Dir(problem,interpretation,var_o1,var_virtual0);
	find mustInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_o2;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1, var_o2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFSObject_class(problem,interpretation,var_o1);
	find mayInstanceOfFSObject_class(problem,interpretation,var_o2);
	// o1 is exported
	// o2 is exported
	find mayInstanceOfDir_class(problem,interpretation,var_o1);
	find mayInRelationcontents_reference_Dir(problem,interpretation,var_o1,var_virtual0);
	find mayInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_o2);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1, var_o2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFSObject_class(problem,interpretation,var_o1);
	find mustInstanceOfFSObject_class(problem,interpretation,var_o2);
	// o1 is exported
	// o2 is exported
	find mustInstanceOfDir_class(problem,interpretation,var_o1);
	find mustInRelationcontents_reference_Dir(problem,interpretation,var_o1,var_virtual0);
	find mustInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_o2;
}
private pattern twoParam_mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(var_o1, var_o2) {
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(_,_,var_o1, var_o2);
}
private pattern twoParam_mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(var_o1, var_o2) {
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(_,_,var_o1, var_o2);
}
private pattern twoParam_currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(var_o1, var_o2) {
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(_,_,var_o1, var_o2);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test filesystem queries live
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_this, var_l)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInstanceOfFSObject_class(problem,interpretation,var_l);
	// this is exported
	// l is exported
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInRelationroot_reference_FileSystem(problem,interpretation,var_this,var_virtual0);
	find mustInstanceOfDir_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_l;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInstanceOfFSObject_class(problem,interpretation,var_l);
	// this is exported
	// l is exported
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInRelationroot_reference_FileSystem(problem,interpretation,var_this,var_virtual0);
	find mustInstanceOfDir_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_root;
	find twoParam_mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent+(var_root,var_l);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_this, var_l)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mayInstanceOfFSObject_class(problem,interpretation,var_l);
	// this is exported
	// l is exported
	find mayInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mayInRelationroot_reference_FileSystem(problem,interpretation,var_this,var_virtual0);
	find mayInstanceOfDir_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_l);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mayInstanceOfFSObject_class(problem,interpretation,var_l);
	// this is exported
	// l is exported
	find mayInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mayInRelationroot_reference_FileSystem(problem,interpretation,var_this,var_virtual0);
	find mayInstanceOfDir_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_root);
	find twoParam_mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent+(var_root,var_l);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_this, var_l)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInstanceOfFSObject_class(problem,interpretation,var_l);
	// this is exported
	// l is exported
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInRelationroot_reference_FileSystem(problem,interpretation,var_this,var_virtual0);
	find mustInstanceOfDir_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_l;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInstanceOfFSObject_class(problem,interpretation,var_l);
	// this is exported
	// l is exported
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInRelationroot_reference_FileSystem(problem,interpretation,var_this,var_virtual0);
	find mustInstanceOfDir_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_root;
	find twoParam_currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent+(var_root,var_l);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test filesystem queries contentInNotLive
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInstanceOfFSObject_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInRelationcontents_reference_Dir(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_child;
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,_var__0,var_parent);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInstanceOfFSObject_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInRelationcontents_reference_Dir(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_child;
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,_var__0,var_child);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfDir_class(problem,interpretation,var_parent);
	find mayInstanceOfFSObject_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mayInstanceOfDir_class(problem,interpretation,var_parent);
	find mayInRelationcontents_reference_Dir(problem,interpretation,var_parent,var_virtual0);
	find mayInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_child);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,_var__0,var_parent);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfDir_class(problem,interpretation,var_parent);
	find mayInstanceOfFSObject_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mayInstanceOfDir_class(problem,interpretation,var_parent);
	find mayInRelationcontents_reference_Dir(problem,interpretation,var_parent,var_virtual0);
	find mayInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_child);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,_var__0,var_child);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInstanceOfFSObject_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInRelationcontents_reference_Dir(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_child;
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,_var__0,var_parent);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInstanceOfFSObject_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInRelationcontents_reference_Dir(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_child;
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,_var__0,var_child);
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationroot_reference_FileSystem(problem,interpretation,source,target); }or
	
	{ find mustInRelationcontents_reference_Dir(problem,interpretation,source,target); }or
	
	{ find mustInRelationfilesystems_reference_Model(problem,interpretation,source,target); }or
	
	{ find mustInRelationotherFSObjects_reference_Model(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(problem,interpretation,var_parent,var_child);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_root_reference_FileSystem(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"root reference FileSystem");
	find mustInstanceOfFileSystem_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationroot_reference_FileSystem(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_filesystems_reference_Model(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"filesystems reference Model");
	find mustInstanceOfModel_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationfilesystems_reference_Model(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(problem,interpretation,var_parent,var_child);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFile_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFSObject_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFileSystem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfDir_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Dir_class_by_root_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dir class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"root reference FileSystem");
	find mustInstanceOfFileSystem_class(problem,interpretation,container);
	find mayInstanceOfDir_class(problem,interpretation,newObject);
	find mayInRelationroot_reference_FileSystem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dir_class_by_contents_reference_Dir_with_parent_reference_FSObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dir class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"contents reference Dir");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FSObject");
	find mustInstanceOfDir_class(problem,interpretation,container);
	find mayInstanceOfDir_class(problem,interpretation,newObject);
	find mayInRelationcontents_reference_Dir(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dir_class_by_otherFSObjects_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dir class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"otherFSObjects reference Model");
	find mustInstanceOfModel_class(problem,interpretation,container);
	find mayInstanceOfDir_class(problem,interpretation,newObject);
	find mayInRelationotherFSObjects_reference_Model(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dir_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dir class");
	find mayInstanceOfDir_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_File_class_by_contents_reference_Dir_with_parent_reference_FSObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"File class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"contents reference Dir");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FSObject");
	find mustInstanceOfDir_class(problem,interpretation,container);
	find mayInstanceOfFile_class(problem,interpretation,newObject);
	find mayInRelationcontents_reference_Dir(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_File_class_by_otherFSObjects_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"File class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"otherFSObjects reference Model");
	find mustInstanceOfModel_class(problem,interpretation,container);
	find mayInstanceOfFile_class(problem,interpretation,newObject);
	find mayInRelationotherFSObjects_reference_Model(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_File_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"File class");
	find mayInstanceOfFile_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Model_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Model class UndefinedPart");
	find mayInstanceOfModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FileSystem_class_by_filesystems_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FileSystem class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"filesystems reference Model");
	find mustInstanceOfModel_class(problem,interpretation,container);
	find mayInstanceOfFileSystem_class(problem,interpretation,newObject);
	find mayInRelationfilesystems_reference_Model(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FileSystem_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FileSystem class");
	find mayInstanceOfFileSystem_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Dir_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
}
pattern refineTypeTo_File_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
}
pattern refineTypeTo_Model_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,element);
}
pattern refineTypeTo_FileSystem_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_live_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"live reference FileSystem");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFileSystem_class(problem,interpretation,from);
	find mustInstanceOfFSObject_class(problem,interpretation,to);
	find mayInRelationlive_reference_FileSystem(problem,interpretation,from,to);
	neg find mustInRelationlive_reference_FileSystem(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FileSystem class".
 */
private pattern mustInstanceOfFileSystem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FileSystem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFileSystem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FileSystem class");
}

/**
 * An element may be an instance of type "FileSystem class".
 */
private pattern mayInstanceOfFileSystem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewFileSystem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewFileSystem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFileSystem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FSObject class".
 */
private pattern mustInstanceOfFSObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FSObject class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFSObject_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FSObject class");
}

/**
 * An element may be an instance of type "FSObject class".
 */
private pattern mayInstanceOfFSObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFSObject_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFSObject_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFSObject_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Dir class".
 */
private pattern mustInstanceOfDir_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Dir class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewDir_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Dir class");
}

/**
 * An element may be an instance of type "Dir class".
 */
private pattern mayInstanceOfDir_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewDir_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewDir_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfDir_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "File class".
 */
private pattern mustInstanceOfFile_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"File class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFile_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"File class");
}

/**
 * An element may be an instance of type "File class".
 */
private pattern mayInstanceOfFile_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFile_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFile_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFile_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Model class".
 */
private pattern mustInstanceOfModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Model class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Model class");
}

/**
 * An element may be an instance of type "Model class".
 */
private pattern mayInstanceOfModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Model class DefinedPart".
 */
private pattern mustInstanceOfModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Model class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Model class DefinedPart");
}

/**
 * An element may be an instance of type "Model class DefinedPart".
 */
private pattern mayInstanceOfModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Model class UndefinedPart".
 */
private pattern mustInstanceOfModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Model class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Model class UndefinedPart");
}

/**
 * An element may be an instance of type "Model class UndefinedPart".
 */
private pattern mayInstanceOfModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []root reference FileSystem(source,target)
 */
private pattern mustInRelationroot_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"root reference FileSystem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>root reference FileSystem(source,target)
 */
private pattern mayInRelationroot_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFileSystem_class(problem,interpretation,source);
	find mayInstanceOfDir_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationroot_reference_FileSystem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationroot_reference_FileSystem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []live reference FileSystem(source,target)
 */
 private pattern mustInRelationlive_reference_FileSystem(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []live reference FileSystem(source,target)
 */
 private pattern mayInRelationlive_reference_FileSystem(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []parent reference FSObject(source,target)
 */
private pattern mustInRelationparent_reference_FSObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FSObject");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FSObject(source,target)
 */
private pattern mayInRelationparent_reference_FSObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFSObject_class(problem,interpretation,source);
	find mayInstanceOfDir_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FSObject(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FSObject(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []contents reference Dir(source,target)
 */
private pattern mustInRelationcontents_reference_Dir(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"contents reference Dir");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>contents reference Dir(source,target)
 */
private pattern mayInRelationcontents_reference_Dir(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfDir_class(problem,interpretation,source);
	find mayInstanceOfFSObject_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FSObject(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationcontents_reference_Dir(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []filesystems reference Model(source,target)
 */
private pattern mustInRelationfilesystems_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"filesystems reference Model");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>filesystems reference Model(source,target)
 */
private pattern mayInRelationfilesystems_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfModel_class(problem,interpretation,source);
	find mayInstanceOfFileSystem_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfilesystems_reference_Model(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfilesystems_reference_Model(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []otherFSObjects reference Model(source,target)
 */
private pattern mustInRelationotherFSObjects_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"otherFSObjects reference Model");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>otherFSObjects reference Model(source,target)
 */
private pattern mayInRelationotherFSObjects_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfModel_class(problem,interpretation,source);
	find mayInstanceOfFSObject_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationotherFSObjects_reference_Model(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test filesystem queries patternContent
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1, var_o2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFSObject_class(problem,interpretation,var_o1);
	find mustInstanceOfFSObject_class(problem,interpretation,var_o2);
	// o1 is exported
	// o2 is exported
	find mustInstanceOfDir_class(problem,interpretation,var_o1);
	find mustInRelationcontents_reference_Dir(problem,interpretation,var_o1,var_virtual0);
	find mustInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_o2;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1, var_o2)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFSObject_class(problem,interpretation,var_o1);
	find mayInstanceOfFSObject_class(problem,interpretation,var_o2);
	// o1 is exported
	// o2 is exported
	find mayInstanceOfDir_class(problem,interpretation,var_o1);
	find mayInRelationcontents_reference_Dir(problem,interpretation,var_o1,var_virtual0);
	find mayInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_o2);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_o1, var_o2)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFSObject_class(problem,interpretation,var_o1);
	find mustInstanceOfFSObject_class(problem,interpretation,var_o2);
	// o1 is exported
	// o2 is exported
	find mustInstanceOfDir_class(problem,interpretation,var_o1);
	find mustInRelationcontents_reference_Dir(problem,interpretation,var_o1,var_virtual0);
	find mustInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_o2;
}
private pattern twoParam_mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(var_o1, var_o2) {
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(_,_,var_o1, var_o2);
}
private pattern twoParam_mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(var_o1, var_o2) {
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(_,_,var_o1, var_o2);
}
private pattern twoParam_currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(var_o1, var_o2) {
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent(_,_,var_o1, var_o2);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test filesystem queries live
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_this, var_l)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInstanceOfFSObject_class(problem,interpretation,var_l);
	// this is exported
	// l is exported
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInRelationroot_reference_FileSystem(problem,interpretation,var_this,var_virtual0);
	find mustInstanceOfDir_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_l;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInstanceOfFSObject_class(problem,interpretation,var_l);
	// this is exported
	// l is exported
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInRelationroot_reference_FileSystem(problem,interpretation,var_this,var_virtual0);
	find mustInstanceOfDir_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_root;
	find twoParam_mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent+(var_root,var_l);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_this, var_l)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mayInstanceOfFSObject_class(problem,interpretation,var_l);
	// this is exported
	// l is exported
	find mayInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mayInRelationroot_reference_FileSystem(problem,interpretation,var_this,var_virtual0);
	find mayInstanceOfDir_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_l);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mayInstanceOfFSObject_class(problem,interpretation,var_l);
	// this is exported
	// l is exported
	find mayInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mayInRelationroot_reference_FileSystem(problem,interpretation,var_this,var_virtual0);
	find mayInstanceOfDir_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_root);
	find twoParam_mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent+(var_root,var_l);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_this, var_l)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInstanceOfFSObject_class(problem,interpretation,var_l);
	// this is exported
	// l is exported
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInRelationroot_reference_FileSystem(problem,interpretation,var_this,var_virtual0);
	find mustInstanceOfDir_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_l;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInstanceOfFSObject_class(problem,interpretation,var_l);
	// this is exported
	// l is exported
	find mustInstanceOfFileSystem_class(problem,interpretation,var_this);
	find mustInRelationroot_reference_FileSystem(problem,interpretation,var_this,var_virtual0);
	find mustInstanceOfDir_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_root;
	find twoParam_currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_patternContent+(var_root,var_l);
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test filesystem queries contentInNotLive
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInstanceOfFSObject_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInRelationcontents_reference_Dir(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_child;
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,_var__0,var_parent);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInstanceOfFSObject_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInRelationcontents_reference_Dir(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_child;
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,_var__0,var_child);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfDir_class(problem,interpretation,var_parent);
	find mayInstanceOfFSObject_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mayInstanceOfDir_class(problem,interpretation,var_parent);
	find mayInRelationcontents_reference_Dir(problem,interpretation,var_parent,var_virtual0);
	find mayInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_child);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,_var__0,var_parent);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfDir_class(problem,interpretation,var_parent);
	find mayInstanceOfFSObject_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mayInstanceOfDir_class(problem,interpretation,var_parent);
	find mayInRelationcontents_reference_Dir(problem,interpretation,var_parent,var_virtual0);
	find mayInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_child);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,_var__0,var_child);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInstanceOfFSObject_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInRelationcontents_reference_Dir(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_child;
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,_var__0,var_parent);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInstanceOfFSObject_class(problem,interpretation,var_child);
	// parent is exported
	// child is exported
	find mustInstanceOfDir_class(problem,interpretation,var_parent);
	find mustInRelationcontents_reference_Dir(problem,interpretation,var_parent,var_virtual0);
	find mustInstanceOfFSObject_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_child;
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_live(problem,interpretation,_var__0,var_child);
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationroot_reference_FileSystem(problem,interpretation,source,target); }or
	
	{ find mustInRelationcontents_reference_Dir(problem,interpretation,source,target); }or
	
	{ find mustInRelationfilesystems_reference_Model(problem,interpretation,source,target); }or
	
	{ find mustInRelationotherFSObjects_reference_Model(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(problem,interpretation,var_parent,var_child);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_root_reference_FileSystem(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"root reference FileSystem");
	find mustInstanceOfFileSystem_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationroot_reference_FileSystem(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_filesystems_reference_Model(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"filesystems reference Model");
	find mustInstanceOfModel_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationfilesystems_reference_Model(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(problem:LogicProblem, interpretation:PartialInterpretation,
	var_parent, var_child)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_filesystem_queries_contentInNotLive(problem,interpretation,var_parent,var_child);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFile_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFSObject_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFileSystem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfDir_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Dir_class_by_root_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dir class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"root reference FileSystem");
	find mustInstanceOfFileSystem_class(problem,interpretation,container);
	find mayInstanceOfDir_class(problem,interpretation,newObject);
	find mayInRelationroot_reference_FileSystem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dir_class_by_contents_reference_Dir_with_parent_reference_FSObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dir class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"contents reference Dir");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FSObject");
	find mustInstanceOfDir_class(problem,interpretation,container);
	find mayInstanceOfDir_class(problem,interpretation,newObject);
	find mayInRelationcontents_reference_Dir(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dir_class_by_otherFSObjects_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dir class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"otherFSObjects reference Model");
	find mustInstanceOfModel_class(problem,interpretation,container);
	find mayInstanceOfDir_class(problem,interpretation,newObject);
	find mayInRelationotherFSObjects_reference_Model(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dir_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dir class");
	find mayInstanceOfDir_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FileSystem_class_by_filesystems_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FileSystem class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"filesystems reference Model");
	find mustInstanceOfModel_class(problem,interpretation,container);
	find mayInstanceOfFileSystem_class(problem,interpretation,newObject);
	find mayInRelationfilesystems_reference_Model(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FileSystem_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FileSystem class");
	find mayInstanceOfFileSystem_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Model_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Model class UndefinedPart");
	find mayInstanceOfModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_File_class_by_contents_reference_Dir_with_parent_reference_FSObject(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"File class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"contents reference Dir");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FSObject");
	find mustInstanceOfDir_class(problem,interpretation,container);
	find mayInstanceOfFile_class(problem,interpretation,newObject);
	find mayInRelationcontents_reference_Dir(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_File_class_by_otherFSObjects_reference_Model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"File class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"otherFSObjects reference Model");
	find mustInstanceOfModel_class(problem,interpretation,container);
	find mayInstanceOfFile_class(problem,interpretation,newObject);
	find mayInRelationotherFSObjects_reference_Model(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_File_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"File class");
	find mayInstanceOfFile_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Dir_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
}
pattern refineTypeTo_FileSystem_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
}
pattern refineTypeTo_Model_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFSObject_class(problem,interpretation,element);
}
pattern refineTypeTo_File_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfDir_class(problem,interpretation,element);
	neg find mustInstanceOfFileSystem_class(problem,interpretation,element);
	neg find mustInstanceOfFile_class(problem,interpretation,element);
	neg find mustInstanceOfModel_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_live_reference_FileSystem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"live reference FileSystem");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFileSystem_class(problem,interpretation,from);
	find mustInstanceOfFSObject_class(problem,interpretation,to);
	find mayInRelationlive_reference_FileSystem(problem,interpretation,from,to);
	neg find mustInRelationlive_reference_FileSystem(problem,interpretation,from,to);
}
