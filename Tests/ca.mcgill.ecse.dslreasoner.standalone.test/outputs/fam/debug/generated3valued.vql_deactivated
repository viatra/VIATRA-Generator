import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
 private pattern mustInRelationmodel_reference_FunctionalElement(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_model(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
 private pattern mayInRelationmodel_reference_FunctionalElement(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_model(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam queries terminatorAndInformation
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_I);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mayInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_In);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam queries rootElements
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Root;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mayInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_Root);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Root;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam queries parent
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mustInstanceOfFunction_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Par;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_Func);
	find mayInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mayInstanceOfFunction_class(problem,interpretation,var_Func);
	find mayInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mayInstanceOfFunction_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_Par);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mustInstanceOfFunction_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Par;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam queries model
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
 private pattern mustInRelationmodel_reference_FunctionalElement(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_model(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
 private pattern mayInRelationmodel_reference_FunctionalElement(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_model(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam queries terminatorAndInformation
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_I);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mayInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_In);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam queries rootElements
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Root;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mayInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_Root);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Root;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam queries parent
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mustInstanceOfFunction_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Par;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_Func);
	find mayInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mayInstanceOfFunction_class(problem,interpretation,var_Func);
	find mayInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mayInstanceOfFunction_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_Par);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mustInstanceOfFunction_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Par;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam queries model
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam queries terminatorAndInformation
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_I);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mayInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_In);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class");
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class");
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam queries terminatorAndInformation
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_I);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mayInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_In);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class");
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class");
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class");
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class");
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class");
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam queries terminatorAndInformation
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_I);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mayInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_In);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class");
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam queries terminatorAndInformation
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_I);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mayInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_In);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class");
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam queries terminatorAndInformation
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_I);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mayInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_In);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class");
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class");
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam queries terminatorAndInformation
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_I);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mayInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_In);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FunctionalArchitectureModel_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class");
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam queries terminatorAndInformation
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_I);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mayInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_In);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam queries terminatorAndInformation
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_I);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mayInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_In);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_queries_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FunctionalArchitectureModel_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class");
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class");
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class");
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class");
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
