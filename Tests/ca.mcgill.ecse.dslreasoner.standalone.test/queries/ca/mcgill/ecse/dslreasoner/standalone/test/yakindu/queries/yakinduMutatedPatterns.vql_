package ca.mcgill.ecse.dslreasoner.standalone.test.yakindu.queries

import epackage "YakinduMetamodel"

/////////
// Entry
/////////

pattern entryInRegion_M0(r1 : Region, e1 : Entry) {
	Region.vertices(r1, e1);
}
pattern entryInRegion_M1(r1 : Region, e1) {
	Region.vertices(r1, e1);
}
pattern entryInRegion_M2(r1 : Region, e1: Entry) {
	// For positive constraint
	Region(r1);Entry(e1);
}


//@Constraint(severity="error", message="error", key = {r1})
pattern noEntryInRegion_M0(r1 : Region) {
	neg find entryInRegion_M0(r1, _);
}
pattern noEntryInRegion_M1(r1 : Region) {
	neg find entryInRegion_M1(r1, _);
}
pattern noEntryInRegion_M2(r1 : Region) {
	neg find entryInRegion_M2(r1, _);
}
pattern noEntryInRegion_M3(r1 : Region) {
	find entryInRegion_M0(r1, _);
}
pattern noEntryInRegion_M4(r1 : Region) {
	find entryInRegion_M1(r1, _);
}
pattern noEntryInRegion_M5(r1 : Region) {
	find entryInRegion_M2(r1, _);
}

//@Constraint(severity="error", message="error", key = {r})
pattern multipleEntryInRegion_M0(r : Region) {
	find entryInRegion_M0(r, e1);
	find entryInRegion_M0(r, e2);
	e1 != e2;
}
pattern multipleEntryInRegion_M1(r : Region) {
	find entryInRegion_M1(r, e1);
	find entryInRegion_M0(r, e2);
	e1 != e2;
}
pattern multipleEntryInRegion_M2(r : Region) {
	find entryInRegion_M2(r, e1);
	find entryInRegion_M0(r, e2);
	e1 != e2;
}
pattern multipleEntryInRegion_M3(r : Region) {
	find entryInRegion_M0(r, e1);
	find entryInRegion_M1(r, e2);
	e1 != e2;
}
pattern multipleEntryInRegion_M4(r : Region) {
	find entryInRegion_M2(r, e1);
	find entryInRegion_M2(r, e2);
	e1 != e2;
}
pattern multipleEntryInRegion_M5(r : Region) {
	find entryInRegion_M0(r, e1);
	find entryInRegion_M0(r, e2);
}


pattern transition_M0(t : Transition, src : Vertex, trg : Vertex) {
	Transition.source(t, src);
	Transition.target(t, trg);
}
pattern transition_M1(t : Transition, src : Vertex, trg : Vertex) {
	Transition.source(t, src);
	Vertex(trg);
}
pattern transition_M2(t : Transition, src : Vertex, trg : Vertex) {
	Vertex(src);
	Transition.target(t, trg);
}
pattern transition_M3(t : Transition, src : Vertex, trg : Vertex) {
	Transition.source(t_x, src);
	Transition.target(t, trg);
}
pattern transition_M4(t : Transition, src : Vertex, trg : Vertex) {
	Transition.source(t, src);
	Transition.target(t_x, trg);
}

//@Constraint(severity="error", message="error", key = {e})
pattern incomingToEntry_M0(t : Transition, e : Entry) {
	find transition_M0(t, _, e);
}
pattern incomingToEntry_1(t : Transition, e) {
	find transition_M0(t, _, e);
}
pattern incomingToEntry_2(t : Transition, e : Entry) {
	find transition_M1(t, _, e);
}
pattern incomingToEntry_3(t : Transition, e : Entry) {
	find transition_M2(t, _, e);
}
pattern incomingToEntry_4(t : Transition, e : Entry) {
	find transition_M3(t, _, e);
}
pattern incomingToEntry_5(t : Transition, e : Entry) {
	find transition_M4(t, _, e);
}

pattern noOutgoingTransitionFromEntry_M0(e : Entry) {
	neg find transition_M0(_, e, _);
}

pattern noOutgoingTransitionFromEntry_M1(e) {
	Vertex(e);
	neg find transition_M0(_, e, _);
}
pattern noOutgoingTransitionFromEntry_M2(e : Entry) {
	neg find transition_M1(_, e, _);
}
pattern noOutgoingTransitionFromEntry_M3(e : Entry) {
	neg find transition_M2(_, e, _);
}
pattern noOutgoingTransitionFromEntry_M4(e : Entry) {
	neg find transition_M3(_, e, _);
}
pattern noOutgoingTransitionFromEntry_M5(e : Entry) {
	neg find transition_M4(_, e, _);
}


//@Constraint(severity="error", message="error", key = {e})
pattern multipleTransitionFromEntry_M0(e : Entry, t1 : Transition, t2: Transition) {
	Entry.outgoingTransitions(e,t1);
	Entry.outgoingTransitions(e,t2);
	t1!=t2;
}
pattern multipleTransitionFromEntry_M1(e, t1 : Transition, t2: Transition) {
	Entry.outgoingTransitions(e,t1);
	Entry.outgoingTransitions(e,t2);
	t1!=t2;
}
pattern multipleTransitionFromEntry_M2(e : Entry, t1 : Transition, t2: Transition) {
	Transition(t1);
	Entry.outgoingTransitions(e,t2);
	t1!=t2;
}
pattern multipleTransitionFromEntry_M3(e : Entry, t1 : Transition, t2: Transition) {
	Entry.outgoingTransitions(e,t1);
	Transition(t2);
	t1!=t2;
}
pattern multipleTransitionFromEntry_M4(e : Entry, t1 : Transition, t2: Transition) {
	Entry.outgoingTransitions(e,t1);
	Entry.outgoingTransitions(e,t2);
}

/////////
// Exit
/////////

//@Constraint(severity="error", message="error", key = {e})
pattern outgoingFromExit_M0(t : Transition, e : Exit) {
	Exit.outgoingTransitions(e,t);
}
pattern outgoingFromExit_M1(t : Transition, e) {
	Vertex.outgoingTransitions(e,t);
}
pattern outgoingFromExit_M2(t : Transition, e : Exit) {
	Transition(t);
	Exit(e);
}

/////////
// Final
/////////

//@Constraint(severity="error", message="error", key = {f})
pattern outgoingFromFinal_M0(t : Transition, f : FinalState) {
	FinalState.outgoingTransitions(f,t);
}
pattern outgoingFromFinal_M1(t : Transition, f) {
	Vertex.outgoingTransitions(f,t);
}
pattern outgoingFromFinal_M2(t : Transition, f : FinalState) {
	Transition(t);
	FinalState(f);
}

/////////
// State vs Region
/////////

//@Constraint(severity="error", message="error", key = {region})
pattern noStateInRegion_M0(region: Region) {
	neg find StateInRegion_M0(region,_);
}
pattern noStateInRegion_M1(region: Region) {
	neg find StateInRegion_M1(region,_);
}
pattern noStateInRegion_M2(region: Region) {
	neg find StateInRegion_M2(region,_);
}
pattern noStateInRegion_M3(region: Region) {
	find StateInRegion_M0(region,_);
}

pattern StateInRegion_M0(region: Region, state: State) {
	Region.vertices(region,state);
}
pattern StateInRegion_M1(region: Region, state) {
	Region.vertices(region,state);
}
pattern StateInRegion_M2(region: Region, state:State) {
	Region(region);State(state);
}

/////////
// Choice
/////////

@Constraint(severity="error", message="error", key = {c})
pattern choiceHasNoOutgoing_M0(c : Choice) {
	neg find transition_M0(_, c, _);
}
pattern choiceHasNoOutgoing_M1(c:Vertex) {
	neg find transition_M0(_, c, _);
}
pattern choiceHasNoOutgoing_M2(c : Choice) {
	neg find transition_M1(_, c, _);
}
pattern choiceHasNoOutgoing_M3(c : Choice) {
	neg find transition_M2(_, c, _);
}
pattern choiceHasNoOutgoing_M4(c : Choice) {
	neg find transition_M3(_, c, _);
}
pattern choiceHasNoOutgoing_M5(c : Choice) {
	neg find transition_M4(_, c, _);
}
pattern choiceHasNoOutgoing_M6(c : Choice) {
	find transition_M0(_, c, _);
}

@Constraint(severity="error", message="error", key = {c})
pattern choiceHasNoIncoming_M0(c: Choice) {
	neg find transition_M0(_, _, c);
}
pattern choiceHasNoIncoming_M1(c:Vertex) {
	neg find transition_M0(_, _, c);
}
pattern choiceHasNoIncoming_M2(c: Choice) {
	neg find transition_M1(_, _, c);
}
pattern choiceHasNoIncoming_M3(c: Choice) {
	neg find transition_M2(_, _, c);
}
pattern choiceHasNoIncoming_M4(c: Choice) {
	neg find transition_M3(_, _, c);
}
pattern choiceHasNoIncoming_M5(c: Choice) {
	neg find transition_M4(_, _, c);
}
pattern choiceHasNoIncoming_M6(c: Choice) {
	find transition_M0(_, _, c);
}
